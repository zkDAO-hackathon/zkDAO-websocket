{
	"address": "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707",
	"abi": [
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_governorToken",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_timelock",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_governor",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_verifier",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_linkAddress",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_factory",
					"type": "address"
				}
			],
			"stateMutability": "nonpayable",
			"type": "constructor"
		},
		{
			"inputs": [],
			"name": "AMOUNT_MISMATCH",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "daoId",
					"type": "uint256"
				}
			],
			"name": "DAONotFound",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "daoId",
					"type": "uint256"
				}
			],
			"name": "DAO_NOT_FOUND",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "FailedDeployment",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INSUFFICIENT_ALLOWANCE",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INSUFFICIENT_FUNDS",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INVALID_NULLIFIER",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INVALID_PROPOSAL_ID",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INVALID_VOTE_TYPE",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "balance",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "needed",
					"type": "uint256"
				}
			],
			"name": "InsufficientBalance",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "InvalidArrayLength",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "InvalidParameters",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "MISMATCH",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "UNAUTHORIZED",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "UnauthorizedCaller",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				}
			],
			"name": "UnexpectedRequestID",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "ZK_PROOF_FAILED",
			"type": "error"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": false,
					"internalType": "bool",
					"name": "enabled",
					"type": "bool"
				}
			],
			"name": "AutomationToggled",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "id",
					"type": "uint256"
				},
				{
					"indexed": true,
					"internalType": "address",
					"name": "deployer",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "token",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "timelock",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "governor",
					"type": "address"
				}
			],
			"name": "DaoCreated",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "symbol",
							"type": "string"
						}
					],
					"indexed": false,
					"internalType": "struct IZKDAO.GovernorTokenParams",
					"name": "tokenParams",
					"type": "tuple"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "minDelay",
					"type": "uint256"
				},
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "description",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "logo",
							"type": "string"
						},
						{
							"internalType": "uint48",
							"name": "votingDelay",
							"type": "uint48"
						},
						{
							"internalType": "uint32",
							"name": "votingPeriod",
							"type": "uint32"
						},
						{
							"internalType": "uint256",
							"name": "proposalThreshold",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "quorumFraction",
							"type": "uint256"
						}
					],
					"indexed": false,
					"internalType": "struct IZKDAO.GovernorParams",
					"name": "governorParams",
					"type": "tuple"
				},
				{
					"indexed": false,
					"internalType": "address[]",
					"name": "to",
					"type": "address[]"
				},
				{
					"indexed": false,
					"internalType": "uint256[]",
					"name": "amounts",
					"type": "uint256[]"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "value",
					"type": "uint256"
				}
			],
			"name": "PaidForDaoCreation",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "id",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "snapshot",
					"type": "uint256"
				}
			],
			"name": "ProposalDequeued",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "address",
					"name": "dao",
					"type": "address"
				},
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "daoId",
					"type": "uint256"
				},
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "proposalId",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "snapshot",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "voteToken",
					"type": "address"
				}
			],
			"name": "ProposalQueued",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				},
				{
					"indexed": false,
					"internalType": "string",
					"name": "source",
					"type": "string"
				},
				{
					"indexed": false,
					"internalType": "string[]",
					"name": "args",
					"type": "string[]"
				}
			],
			"name": "RequestSent",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				},
				{
					"indexed": false,
					"internalType": "bytes",
					"name": "response",
					"type": "bytes"
				},
				{
					"indexed": false,
					"internalType": "bytes",
					"name": "err",
					"type": "bytes"
				}
			],
			"name": "Response",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "upkeepId",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "proposalsProcessed",
					"type": "uint256"
				}
			],
			"name": "UpkeepPerformed",
			"type": "event"
		},
		{
			"inputs": [],
			"name": "NATIVE",
			"outputs": [
				{
					"internalType": "address",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "seconds_",
					"type": "uint256"
				}
			],
			"name": "advanceTime",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				}
			],
			"name": "autoFulfillRequest",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "automationEnabled",
			"outputs": [
				{
					"internalType": "bool",
					"name": "",
					"type": "bool"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "automationRegistry",
			"outputs": [
				{
					"internalType": "address",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address[]",
					"name": "daos",
					"type": "address[]"
				},
				{
					"internalType": "uint256[]",
					"name": "proposalIds",
					"type": "uint256[]"
				},
				{
					"internalType": "uint256[]",
					"name": "snapshots",
					"type": "uint256[]"
				},
				{
					"internalType": "address[]",
					"name": "voteTokens",
					"type": "address[]"
				}
			],
			"name": "batchQueueProposals",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes",
					"name": "",
					"type": "bytes"
				}
			],
			"name": "checkUpkeep",
			"outputs": [
				{
					"internalType": "bool",
					"name": "upkeepNeeded",
					"type": "bool"
				},
				{
					"internalType": "bytes",
					"name": "performData",
					"type": "bytes"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "cleanupQueue",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "clearProcessedProposals",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "clearQueue",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "symbol",
							"type": "string"
						}
					],
					"internalType": "struct IZKDAO.GovernorTokenParams",
					"name": "_tokenParams",
					"type": "tuple"
				},
				{
					"internalType": "uint256",
					"name": "_minDelay",
					"type": "uint256"
				},
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "description",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "logo",
							"type": "string"
						},
						{
							"internalType": "uint48",
							"name": "votingDelay",
							"type": "uint48"
						},
						{
							"internalType": "uint32",
							"name": "votingPeriod",
							"type": "uint32"
						},
						{
							"internalType": "uint256",
							"name": "proposalThreshold",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "quorumFraction",
							"type": "uint256"
						}
					],
					"internalType": "struct IZKDAO.GovernorParams",
					"name": "_governorParams",
					"type": "tuple"
				},
				{
					"internalType": "address[]",
					"name": "_to",
					"type": "address[]"
				},
				{
					"internalType": "uint256[]",
					"name": "_amounts",
					"type": "uint256[]"
				}
			],
			"name": "createDao",
			"outputs": [],
			"stateMutability": "payable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "daoCount",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "",
					"type": "address"
				}
			],
			"name": "daoIds",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "factory",
			"outputs": [
				{
					"internalType": "address",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "forceUpkeepNeeded",
			"outputs": [
				{
					"internalType": "bool",
					"name": "",
					"type": "bool"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getAutomationStats",
			"outputs": [
				{
					"internalType": "bool",
					"name": "enabled",
					"type": "bool"
				},
				{
					"internalType": "uint256",
					"name": "queueLength",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "pendingCount",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "processedCount",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "lastUpkeep",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "totalUpkeeps",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "id",
					"type": "uint256"
				}
			],
			"name": "getDao",
			"outputs": [
				{
					"components": [
						{
							"internalType": "contract IGovernorToken",
							"name": "token",
							"type": "address"
						},
						{
							"internalType": "contract ITimeLock",
							"name": "timelock",
							"type": "address"
						},
						{
							"internalType": "contract IGovernor",
							"name": "governor",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "deployer",
							"type": "address"
						}
					],
					"internalType": "struct IZKDAO.DAO",
					"name": "dao",
					"type": "tuple"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getImplementations",
			"outputs": [
				{
					"internalType": "address",
					"name": "_governorToken",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_timelock",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_governor",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_verifier",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "account",
					"type": "address"
				}
			],
			"name": "getNonce",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "dao",
					"type": "address"
				},
				{
					"internalType": "uint256",
					"name": "proposalId",
					"type": "uint256"
				}
			],
			"name": "getProposal",
			"outputs": [
				{
					"components": [
						{
							"internalType": "contract IGovernor",
							"name": "dao",
							"type": "address"
						},
						{
							"internalType": "uint256",
							"name": "daoId",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "proposalId",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "snapshot",
							"type": "uint256"
						},
						{
							"internalType": "address",
							"name": "voteToken",
							"type": "address"
						},
						{
							"internalType": "bool",
							"name": "queued",
							"type": "bool"
						},
						{
							"internalType": "bool",
							"name": "executed",
							"type": "bool"
						}
					],
					"internalType": "struct MockConsumer.Proposal",
					"name": "",
					"type": "tuple"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getQueueLength",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getRequestCounter",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "governor",
			"outputs": [
				{
					"internalType": "contract IGovernor",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "governorToken",
			"outputs": [
				{
					"internalType": "contract IGovernorToken",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "dao",
					"type": "address"
				},
				{
					"internalType": "uint256",
					"name": "proposalId",
					"type": "uint256"
				}
			],
			"name": "isProposalProcessed",
			"outputs": [
				{
					"internalType": "bool",
					"name": "",
					"type": "bool"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				}
			],
			"name": "isRequestPending",
			"outputs": [
				{
					"internalType": "bool",
					"name": "",
					"type": "bool"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "lastUpkeepTimestamp",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "linkToken",
			"outputs": [
				{
					"internalType": "contract IERC20",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "manualUpkeep",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "processedCount",
					"type": "uint256"
				}
			],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "mockBlockTimestamp",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes32",
					"name": "_requestId",
					"type": "bytes32"
				},
				{
					"internalType": "string",
					"name": "_cids",
					"type": "string"
				}
			],
			"name": "mockFulfillRequest",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				},
				{
					"internalType": "string",
					"name": "errorMessage",
					"type": "string"
				}
			],
			"name": "mockFulfillRequestWithError",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "owner",
			"outputs": [
				{
					"internalType": "address",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "symbol",
							"type": "string"
						}
					],
					"internalType": "struct IZKDAO.GovernorTokenParams",
					"name": "_tokenParams",
					"type": "tuple"
				},
				{
					"internalType": "uint256",
					"name": "_minDelay",
					"type": "uint256"
				},
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "description",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "logo",
							"type": "string"
						},
						{
							"internalType": "uint48",
							"name": "votingDelay",
							"type": "uint48"
						},
						{
							"internalType": "uint32",
							"name": "votingPeriod",
							"type": "uint32"
						},
						{
							"internalType": "uint256",
							"name": "proposalThreshold",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "quorumFraction",
							"type": "uint256"
						}
					],
					"internalType": "struct IZKDAO.GovernorParams",
					"name": "_governorParams",
					"type": "tuple"
				},
				{
					"internalType": "address[]",
					"name": "_to",
					"type": "address[]"
				},
				{
					"internalType": "uint256[]",
					"name": "_amounts",
					"type": "uint256[]"
				},
				{
					"internalType": "uint256",
					"name": "_value",
					"type": "uint256"
				}
			],
			"name": "payForDaoCreation",
			"outputs": [],
			"stateMutability": "payable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes",
					"name": "performData",
					"type": "bytes"
				}
			],
			"name": "performUpkeep",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "price",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "qetQueue",
			"outputs": [
				{
					"components": [
						{
							"internalType": "contract IGovernor",
							"name": "dao",
							"type": "address"
						},
						{
							"internalType": "uint256",
							"name": "daoId",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "proposalId",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "snapshot",
							"type": "uint256"
						},
						{
							"internalType": "address",
							"name": "voteToken",
							"type": "address"
						},
						{
							"internalType": "bool",
							"name": "queued",
							"type": "bool"
						},
						{
							"internalType": "bool",
							"name": "executed",
							"type": "bool"
						}
					],
					"internalType": "struct MockConsumer.Proposal[]",
					"name": "",
					"type": "tuple[]"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "daoId",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "proposalId",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "snapshot",
					"type": "uint256"
				},
				{
					"internalType": "address",
					"name": "voteToken",
					"type": "address"
				}
			],
			"name": "queueProposal",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "s_lastError",
			"outputs": [
				{
					"internalType": "bytes",
					"name": "",
					"type": "bytes"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "s_lastRequestId",
			"outputs": [
				{
					"internalType": "bytes32",
					"name": "",
					"type": "bytes32"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "s_lastResponse",
			"outputs": [
				{
					"internalType": "bytes",
					"name": "",
					"type": "bytes"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes",
					"name": "request",
					"type": "bytes"
				},
				{
					"internalType": "uint64",
					"name": "subscriptionId",
					"type": "uint64"
				},
				{
					"internalType": "uint32",
					"name": "gasLimit",
					"type": "uint32"
				},
				{
					"internalType": "bytes32",
					"name": "donID",
					"type": "bytes32"
				}
			],
			"name": "sendRequestCBOR",
			"outputs": [
				{
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				}
			],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "registry",
					"type": "address"
				}
			],
			"name": "setAutomationRegistry",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bool",
					"name": "force",
					"type": "bool"
				}
			],
			"name": "setForceUpkeepNeeded",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "timestamp",
					"type": "uint256"
				}
			],
			"name": "setMockBlockTimestamp",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				},
				{
					"internalType": "bytes",
					"name": "response",
					"type": "bytes"
				},
				{
					"internalType": "bytes",
					"name": "err",
					"type": "bytes"
				}
			],
			"name": "setPredefinedResponse",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "simulateAutomationCycle",
			"outputs": [
				{
					"internalType": "bool",
					"name": "executed",
					"type": "bool"
				},
				{
					"internalType": "uint256",
					"name": "processedCount",
					"type": "uint256"
				}
			],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "string",
					"name": "input",
					"type": "string"
				}
			],
			"name": "splitByPipe",
			"outputs": [
				{
					"internalType": "string[]",
					"name": "",
					"type": "string[]"
				}
			],
			"stateMutability": "pure",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "timelock",
			"outputs": [
				{
					"internalType": "contract ITimeLock",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bool",
					"name": "enabled",
					"type": "bool"
				}
			],
			"name": "toggleAutomation",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "newOwner",
					"type": "address"
				}
			],
			"name": "transferOwnership",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "upkeepCounter",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "verifier",
			"outputs": [
				{
					"internalType": "contract IVerifier",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"stateMutability": "payable",
			"type": "receive"
		}
	],
	"transactionHash": "0xcca7e0fe25fa918452be10388269eae7198a1d2c70bad8bf0f2967cf02663782",
	"receipt": {
		"to": null,
		"from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
		"contractAddress": "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707",
		"transactionIndex": 0,
		"gasUsed": "5355776",
		"logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		"blockHash": "0xd2b120ac75e00e9e06f030256b4a4576e5fffeb735e6d7f08aa5ad11d6558d93",
		"transactionHash": "0xcca7e0fe25fa918452be10388269eae7198a1d2c70bad8bf0f2967cf02663782",
		"logs": [],
		"blockNumber": 6,
		"cumulativeGasUsed": "5355776",
		"status": 1,
		"byzantium": true
	},
	"args": [
		"0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
		"0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
		"0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
		"0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9",
		"0x5FbDB2315678afecb367f032d93F642f64180aa3",
		"0x522D818751B7D596bDD4018065dA7408e2bB8251"
	],
	"numDeployments": 1,
	"solcInputHash": "30fa80f705db498cb1e88b64dc0d25fb",
	"metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governorToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timelock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_linkAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AMOUNT_MISMATCH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"}],\"name\":\"DAONotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"}],\"name\":\"DAO_NOT_FOUND\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedDeployment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_ALLOWANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_FUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_NULLIFIER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PROPOSAL_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_VOTE_TYPE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedCaller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedRequestID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZK_PROOF_FAILED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"AutomationToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"timelock\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"DaoCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct IZKDAO.GovernorTokenParams\",\"name\":\"tokenParams\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minDelay\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logo\",\"type\":\"string\"},{\"internalType\":\"uint48\",\"name\":\"votingDelay\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"votingPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumFraction\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IZKDAO.GovernorParams\",\"name\":\"governorParams\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PaidForDaoCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"}],\"name\":\"ProposalDequeued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voteToken\",\"type\":\"address\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"args\",\"type\":\"string[]\"}],\"name\":\"RequestSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"err\",\"type\":\"bytes\"}],\"name\":\"Response\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"upkeepId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalsProcessed\",\"type\":\"uint256\"}],\"name\":\"UpkeepPerformed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NATIVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seconds_\",\"type\":\"uint256\"}],\"name\":\"advanceTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"autoFulfillRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automationEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automationRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"daos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"proposalIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"snapshots\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"voteTokens\",\"type\":\"address[]\"}],\"name\":\"batchQueueProposals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cleanupQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearProcessedProposals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct IZKDAO.GovernorTokenParams\",\"name\":\"_tokenParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_minDelay\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logo\",\"type\":\"string\"},{\"internalType\":\"uint48\",\"name\":\"votingDelay\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"votingPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumFraction\",\"type\":\"uint256\"}],\"internalType\":\"struct IZKDAO.GovernorParams\",\"name\":\"_governorParams\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"createDao\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"daoIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceUpkeepNeeded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAutomationStats\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"queueLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processedCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpkeep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUpkeeps\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getDao\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IGovernorToken\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ITimeLock\",\"name\":\"timelock\",\"type\":\"address\"},{\"internalType\":\"contract IGovernor\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"internalType\":\"struct IZKDAO.DAO\",\"name\":\"dao\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_governorToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timelock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IGovernor\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voteToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"queued\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"internalType\":\"struct MockConsumer.Proposal\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequestCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"contract IGovernor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governorToken\",\"outputs\":[{\"internalType\":\"contract IGovernorToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isProposalProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"isRequestPending\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpkeepTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualUpkeep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"processedCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_cids\",\"type\":\"string\"}],\"name\":\"mockFulfillRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"errorMessage\",\"type\":\"string\"}],\"name\":\"mockFulfillRequestWithError\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct IZKDAO.GovernorTokenParams\",\"name\":\"_tokenParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_minDelay\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logo\",\"type\":\"string\"},{\"internalType\":\"uint48\",\"name\":\"votingDelay\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"votingPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumFraction\",\"type\":\"uint256\"}],\"internalType\":\"struct IZKDAO.GovernorParams\",\"name\":\"_governorParams\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"payForDaoCreation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"qetQueue\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IGovernor\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voteToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"queued\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"internalType\":\"struct MockConsumer.Proposal[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voteToken\",\"type\":\"address\"}],\"name\":\"queueProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_lastError\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_lastRequestId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_lastResponse\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"donID\",\"type\":\"bytes32\"}],\"name\":\"sendRequestCBOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"setAutomationRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"setForceUpkeepNeeded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setMockBlockTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"err\",\"type\":\"bytes\"}],\"name\":\"setPredefinedResponse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"simulateAutomationCycle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"processedCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"input\",\"type\":\"string\"}],\"name\":\"splitByPipe\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"contract ITimeLock\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"toggleAutomation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upkeepCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"errors\":{\"FailedDeployment()\":[{\"details\":\"The deployment failed.\"}],\"InsufficientBalance(uint256,uint256)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}]},\"kind\":\"dev\",\"methods\":{\"autoFulfillRequest(bytes32)\":{\"params\":{\"requestId\":\"Request ID to auto-fulfill\"}},\"createDao((string,string),uint256,(string,string,string,uint48,uint32,uint256,uint256),address[],uint256[])\":{\"details\":\"Arrays _to and _amounts must have the same lengthEmits DaoCreated event upon successful creation\",\"params\":{\"_amounts\":\"Array of token amounts corresponding to _to addresses\",\"_governorParams\":\"Parameters for the governor contract\",\"_minDelay\":\"Minimum delay for timelock operations (in seconds)\",\"_to\":\"Array of addresses to receive initial token allocation\",\"_tokenParams\":\"Parameters for the governance token\"}},\"getImplementations()\":{\"returns\":{\"_governor\":\"Governor implementation address\",\"_governorToken\":\"Governor token implementation address\",\"_timelock\":\"Timelock implementation address\",\"_verifier\":\"ZK verifier implementation address\"}},\"getNonce(address)\":{\"params\":{\"account\":\"User address\"},\"returns\":{\"_0\":\"Current nonce value\"}},\"mockFulfillRequest(bytes32,string)\":{\"params\":{\"_cids\":\"Merkle root for the proposal\",\"_requestId\":\"The request ID to fulfill\"}},\"mockFulfillRequestWithError(bytes32,string)\":{\"params\":{\"errorMessage\":\"Error message to return\",\"requestId\":\"The request ID to fulfill with error\"}},\"queueProposal(uint256,uint256,uint256,address)\":{\"details\":\"Only callable by registered Governor contracts\",\"params\":{\"daoId\":\"DAO identifier\",\"proposalId\":\"Proposal identifier within the DAO\",\"snapshot\":\"Block number snapshot for the proposal\"}},\"setPredefinedResponse(bytes32,bytes,bytes)\":{\"params\":{\"err\":\"Error data\",\"requestId\":\"Request ID\",\"response\":\"Response data\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"DAO_NOT_FOUND(uint256)\":[{\"notice\":\"====================== ======= ZK DAO ======= ======================\"}],\"INSUFFICIENT_ALLOWANCE()\":[{\"notice\":\"====================== ====== Generic ======= ======================\"}],\"INVALID_VOTE_TYPE()\":[{\"notice\":\"====================== ====== Governor ====== ======================\"}],\"UnexpectedRequestID(bytes32)\":[{\"notice\":\"====================== ======= Errors ======= ======================\"}]},\"events\":{\"DaoCreated(uint256,address,address,address,address)\":{\"notice\":\"====================== ======= Events ======= ======================\"},\"ProposalQueued(address,uint256,uint256,uint256,address)\":{\"notice\":\"====================== ======= Events ======= ======================\"},\"Response(bytes32,bytes,bytes)\":{\"notice\":\"====================== ======= Events ======= ======================\"}},\"kind\":\"user\",\"methods\":{\"advanceTime(uint256)\":{\"notice\":\"Advance mock time by specified seconds\"},\"autoFulfillRequest(bytes32)\":{\"notice\":\"Auto-fulfill request with predefined response\"},\"automationEnabled()\":{\"notice\":\"========================= === Storage Variables === =========================\"},\"batchQueueProposals(address[],uint256[],uint256[],address[])\":{\"notice\":\"Batch queue multiple proposals for testing\"},\"checkUpkeep(bytes)\":{\"notice\":\"========================== ===== View Functions ===== ==========================\"},\"cleanupQueue()\":{\"notice\":\"Remove processed proposals from queue\"},\"clearProcessedProposals()\":{\"notice\":\"Clear all processed proposals (for testing)\"},\"clearQueue()\":{\"notice\":\"Clear the entire queue (for testing)\"},\"constructor\":{\"notice\":\"========================= ====== Constructor ====== =========================\"},\"createDao((string,string),uint256,(string,string,string,uint48,uint32,uint256,uint256),address[],uint256[])\":{\"notice\":\"Create a new DAO with governance token, timelock, and governor\"},\"getAutomationStats()\":{\"notice\":\"Get automation stats for monitoring\"},\"getDao(uint256)\":{\"notice\":\"========================== ===== View Functions ===== ==========================\"},\"getImplementations()\":{\"notice\":\"Get all implementation contract addresses\"},\"getNonce(address)\":{\"notice\":\"Get user's current nonce for deterministic address generation\"},\"getRequestCounter()\":{\"notice\":\"Get request counter for testing\"},\"isRequestPending(bytes32)\":{\"notice\":\"Check if request is pending\"},\"manualUpkeep()\":{\"notice\":\"Manually trigger upkeep (simulates Chainlink calling performUpkeep)\"},\"mockFulfillRequest(bytes32,string)\":{\"notice\":\"Mock function to simulate successful response\"},\"mockFulfillRequestWithError(bytes32,string)\":{\"notice\":\"Mock function to simulate error response\"},\"payForDaoCreation((string,string),uint256,(string,string,string,uint48,uint32,uint256,uint256),address[],uint256[],uint256)\":{\"notice\":\"================================= == External / Public Functions == =================================\"},\"performUpkeep(bytes)\":{\"notice\":\"================================= == External / Public Functions == =================================\"},\"queueProposal(uint256,uint256,uint256,address)\":{\"notice\":\"Queue a proposal for processing (called by Governor contracts)\"},\"s_lastRequestId()\":{\"notice\":\"========================= === Storage Variables === =========================\"},\"sendRequestCBOR(bytes,uint64,uint32,bytes32)\":{\"notice\":\"Send a pre-encoded CBOR request (mocked)\"},\"setAutomationRegistry(address)\":{\"notice\":\"Set automation registry address\"},\"setForceUpkeepNeeded(bool)\":{\"notice\":\"Force upkeep to be needed for testing\"},\"setMockBlockTimestamp(uint256)\":{\"notice\":\"Set mock block timestamp for testing time-dependent logic\"},\"setPredefinedResponse(bytes32,bytes,bytes)\":{\"notice\":\"Set predefined response for a request (for advanced testing)\"},\"simulateAutomationCycle()\":{\"notice\":\"Simulate automated upkeep cycle\"},\"toggleAutomation(bool)\":{\"notice\":\"Toggle automation on/off for testing\"},\"transferOwnership(address)\":{\"notice\":\"Transfer ownership\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/mocks/MockZKDAO.sol\":\"MockZKDAO\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {ERC165Upgradeable} from \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\\n    struct AccessControlStorage {\\n        mapping(bytes32 role => RoleData) _roles;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.AccessControl\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\\n\\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\\n        assembly {\\n            $.slot := AccessControlStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    function __AccessControl_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        return $._roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        return $._roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        $._roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        if (!hasRole(role, account)) {\\n            $._roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        if (hasRole(role, account)) {\\n            $._roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0d4d7d19a052a2ef9d17b28450133631188b895e1755747fa8ad0280aadfb534\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (governance/TimelockController.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {AccessControlUpgradeable} from \\\"../access/AccessControlUpgradeable.sol\\\";\\nimport {ERC721HolderUpgradeable} from \\\"../token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\nimport {ERC1155HolderUpgradeable} from \\\"../token/ERC1155/utils/ERC1155HolderUpgradeable.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which acts as a timelocked controller. When set as the\\n * owner of an `Ownable` smart contract, it enforces a timelock on all\\n * `onlyOwner` maintenance operations. This gives time for users of the\\n * controlled contract to exit before a potentially dangerous maintenance\\n * operation is applied.\\n *\\n * By default, this contract is self administered, meaning administration tasks\\n * have to go through the timelock process. The proposer (resp executor) role\\n * is in charge of proposing (resp executing) operations. A common use case is\\n * to position this {TimelockController} as the owner of a smart contract, with\\n * a multisig or a DAO as the sole proposer.\\n */\\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\\n    bytes32 public constant PROPOSER_ROLE = keccak256(\\\"PROPOSER_ROLE\\\");\\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\\\"EXECUTOR_ROLE\\\");\\n    bytes32 public constant CANCELLER_ROLE = keccak256(\\\"CANCELLER_ROLE\\\");\\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.TimelockController\\n    struct TimelockControllerStorage {\\n        mapping(bytes32 id => uint256) _timestamps;\\n        uint256 _minDelay;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.TimelockController\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant TimelockControllerStorageLocation = 0x9a37c2aa9d186a0969ff8a8267bf4e07e864c2f2768f5040949e28a624fb3600;\\n\\n    function _getTimelockControllerStorage() private pure returns (TimelockControllerStorage storage $) {\\n        assembly {\\n            $.slot := TimelockControllerStorageLocation\\n        }\\n    }\\n\\n    enum OperationState {\\n        Unset,\\n        Waiting,\\n        Ready,\\n        Done\\n    }\\n\\n    /**\\n     * @dev Mismatch between the parameters length for an operation call.\\n     */\\n    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);\\n\\n    /**\\n     * @dev The schedule operation doesn't meet the minimum delay.\\n     */\\n    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);\\n\\n    /**\\n     * @dev The current state of an operation is not as required.\\n     * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position\\n     * counting from right to left.\\n     *\\n     * See {_encodeStateBitmap}.\\n     */\\n    error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);\\n\\n    /**\\n     * @dev The predecessor to an operation not yet done.\\n     */\\n    error TimelockUnexecutedPredecessor(bytes32 predecessorId);\\n\\n    /**\\n     * @dev The caller account is not authorized.\\n     */\\n    error TimelockUnauthorizedCaller(address caller);\\n\\n    /**\\n     * @dev Emitted when a call is scheduled as part of operation `id`.\\n     */\\n    event CallScheduled(\\n        bytes32 indexed id,\\n        uint256 indexed index,\\n        address target,\\n        uint256 value,\\n        bytes data,\\n        bytes32 predecessor,\\n        uint256 delay\\n    );\\n\\n    /**\\n     * @dev Emitted when a call is performed as part of operation `id`.\\n     */\\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\\n\\n    /**\\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\\n     */\\n    event CallSalt(bytes32 indexed id, bytes32 salt);\\n\\n    /**\\n     * @dev Emitted when operation `id` is cancelled.\\n     */\\n    event Cancelled(bytes32 indexed id);\\n\\n    /**\\n     * @dev Emitted when the minimum delay for future operations is modified.\\n     */\\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\\n\\n    function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) public virtual initializer {\\n        __TimelockController_init(minDelay, proposers, executors, admin);\\n    }\\n    /**\\n     * @dev Initializes the contract with the following parameters:\\n     *\\n     * - `minDelay`: initial minimum delay in seconds for operations\\n     * - `proposers`: accounts to be granted proposer and canceller roles\\n     * - `executors`: accounts to be granted executor role\\n     * - `admin`: optional account to be granted admin role; disable with zero address\\n     *\\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\\n     * without being subject to delay, but this role should be subsequently renounced in favor of\\n     * administration through timelocked proposals. Previous versions of this contract would assign\\n     * this admin to the deployer automatically and should be renounced as well.\\n     */\\n    function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\\n        __TimelockController_init_unchained(minDelay, proposers, executors, admin);\\n    }\\n\\n    function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        // self administration\\n        _grantRole(DEFAULT_ADMIN_ROLE, address(this));\\n\\n        // optional admin\\n        if (admin != address(0)) {\\n            _grantRole(DEFAULT_ADMIN_ROLE, admin);\\n        }\\n\\n        // register proposers and cancellers\\n        for (uint256 i = 0; i < proposers.length; ++i) {\\n            _grantRole(PROPOSER_ROLE, proposers[i]);\\n            _grantRole(CANCELLER_ROLE, proposers[i]);\\n        }\\n\\n        // register executors\\n        for (uint256 i = 0; i < executors.length; ++i) {\\n            _grantRole(EXECUTOR_ROLE, executors[i]);\\n        }\\n\\n        $._minDelay = minDelay;\\n        emit MinDelayChange(0, minDelay);\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only by a certain role. In\\n     * addition to checking the sender's role, `address(0)` 's role is also\\n     * considered. Granting a role to `address(0)` is equivalent to enabling\\n     * this role for everyone.\\n     */\\n    modifier onlyRoleOrOpenRole(bytes32 role) {\\n        if (!hasRole(role, address(0))) {\\n            _checkRole(role, _msgSender());\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\\n     */\\n    receive() external payable virtual {}\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(AccessControlUpgradeable, ERC1155HolderUpgradeable) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns whether an id corresponds to a registered operation. This\\n     * includes both Waiting, Ready, and Done operations.\\n     */\\n    function isOperation(bytes32 id) public view returns (bool) {\\n        return getOperationState(id) != OperationState.Unset;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is pending or not. Note that a \\\"pending\\\" operation may also be \\\"ready\\\".\\n     */\\n    function isOperationPending(bytes32 id) public view returns (bool) {\\n        OperationState state = getOperationState(id);\\n        return state == OperationState.Waiting || state == OperationState.Ready;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is ready for execution. Note that a \\\"ready\\\" operation is also \\\"pending\\\".\\n     */\\n    function isOperationReady(bytes32 id) public view returns (bool) {\\n        return getOperationState(id) == OperationState.Ready;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is done or not.\\n     */\\n    function isOperationDone(bytes32 id) public view returns (bool) {\\n        return getOperationState(id) == OperationState.Done;\\n    }\\n\\n    /**\\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\\n     * unset operations, 1 for done operations).\\n     */\\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        return $._timestamps[id];\\n    }\\n\\n    /**\\n     * @dev Returns operation state.\\n     */\\n    function getOperationState(bytes32 id) public view virtual returns (OperationState) {\\n        uint256 timestamp = getTimestamp(id);\\n        if (timestamp == 0) {\\n            return OperationState.Unset;\\n        } else if (timestamp == _DONE_TIMESTAMP) {\\n            return OperationState.Done;\\n        } else if (timestamp > block.timestamp) {\\n            return OperationState.Waiting;\\n        } else {\\n            return OperationState.Ready;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the minimum delay in seconds for an operation to become valid.\\n     *\\n     * This value can be changed by executing an operation that calls `updateDelay`.\\n     */\\n    function getMinDelay() public view virtual returns (uint256) {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        return $._minDelay;\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a single\\n     * transaction.\\n     */\\n    function hashOperation(\\n        address target,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public pure virtual returns (bytes32) {\\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a batch of\\n     * transactions.\\n     */\\n    function hashOperationBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public pure virtual returns (bytes32) {\\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a single transaction.\\n     *\\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function schedule(\\n        address target,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes32 predecessor,\\n        bytes32 salt,\\n        uint256 delay\\n    ) public virtual onlyRole(PROPOSER_ROLE) {\\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\\n        _schedule(id, delay);\\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\\n        if (salt != bytes32(0)) {\\n            emit CallSalt(id, salt);\\n        }\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a batch of transactions.\\n     *\\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function scheduleBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads,\\n        bytes32 predecessor,\\n        bytes32 salt,\\n        uint256 delay\\n    ) public virtual onlyRole(PROPOSER_ROLE) {\\n        if (targets.length != values.length || targets.length != payloads.length) {\\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\\n        }\\n\\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\\n        _schedule(id, delay);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\\n        }\\n        if (salt != bytes32(0)) {\\n            emit CallSalt(id, salt);\\n        }\\n    }\\n\\n    /**\\n     * @dev Schedule an operation that is to become valid after a given delay.\\n     */\\n    function _schedule(bytes32 id, uint256 delay) private {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        if (isOperation(id)) {\\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));\\n        }\\n        uint256 minDelay = getMinDelay();\\n        if (delay < minDelay) {\\n            revert TimelockInsufficientDelay(delay, minDelay);\\n        }\\n        $._timestamps[id] = block.timestamp + delay;\\n    }\\n\\n    /**\\n     * @dev Cancel an operation.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'canceller' role.\\n     */\\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        if (!isOperationPending(id)) {\\n            revert TimelockUnexpectedOperationState(\\n                id,\\n                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)\\n            );\\n        }\\n        delete $._timestamps[id];\\n\\n        emit Cancelled(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a single transaction.\\n     *\\n     * Emits a {CallExecuted} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\\n    // thus any modifications to the operation during reentrancy should be caught.\\n    // slither-disable-next-line reentrancy-eth\\n    function execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata payload,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\\n\\n        _beforeCall(id, predecessor);\\n        _execute(target, value, payload);\\n        emit CallExecuted(id, 0, target, value, payload);\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a batch of transactions.\\n     *\\n     * Emits one {CallExecuted} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\\n    // thus any modifications to the operation during reentrancy should be caught.\\n    // slither-disable-next-line reentrancy-eth\\n    function executeBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\\n        if (targets.length != values.length || targets.length != payloads.length) {\\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\\n        }\\n\\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\\n\\n        _beforeCall(id, predecessor);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            address target = targets[i];\\n            uint256 value = values[i];\\n            bytes calldata payload = payloads[i];\\n            _execute(target, value, payload);\\n            emit CallExecuted(id, i, target, value, payload);\\n        }\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Execute an operation's call.\\n     */\\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        Address.verifyCallResult(success, returndata);\\n    }\\n\\n    /**\\n     * @dev Checks before execution of an operation's calls.\\n     */\\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\\n        if (!isOperationReady(id)) {\\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\\n        }\\n        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {\\n            revert TimelockUnexecutedPredecessor(predecessor);\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks after execution of an operation's calls.\\n     */\\n    function _afterCall(bytes32 id) private {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        if (!isOperationReady(id)) {\\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\\n        }\\n        $._timestamps[id] = _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Changes the minimum timelock duration for future operations.\\n     *\\n     * Emits a {MinDelayChange} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\\n     */\\n    function updateDelay(uint256 newDelay) external virtual {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        address sender = _msgSender();\\n        if (sender != address(this)) {\\n            revert TimelockUnauthorizedCaller(sender);\\n        }\\n        emit MinDelayChange($._minDelay, newDelay);\\n        $._minDelay = newDelay;\\n    }\\n\\n    /**\\n     * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to\\n     * the underlying position in the `OperationState` enum. For example:\\n     *\\n     * 0x000...1000\\n     *   ^^^^^^----- ...\\n     *         ^---- Done\\n     *          ^--- Ready\\n     *           ^-- Waiting\\n     *            ^- Unset\\n     */\\n    function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {\\n        return bytes32(1 << uint8(operationState));\\n    }\\n}\\n\",\"keccak256\":\"0x4efd1ce484a3d68bc54401d4e87271e8dbf2e073e174fa0d2c51645123042819\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\\n     *\\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\\n     */\\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\\n        return INITIALIZABLE_STORAGE;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        bytes32 slot = _initializableStorageSlot();\\n        assembly {\\n            $.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {ERC165Upgradeable} from \\\"../../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport {IERC1155Receiver} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport {Initializable} from \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n */\\nabstract contract ERC1155HolderUpgradeable is Initializable, ERC165Upgradeable, IERC1155Receiver {\\n    function __ERC1155Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x64c8658be9360779b99ef60db78d3172be7056e1d078fc1cabf6b693862c831c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {Initializable} from \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\\n * {IERC721-setApprovalForAll}.\\n */\\nabstract contract ERC721HolderUpgradeable is Initializable, IERC721Receiver {\\n    function __ERC721Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x9a4de3d90a92d682de7ec325eb3d032587fbe9782a4bbbf1b1fa72a82b2c06e3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xdbef5f0c787055227243a7318ef74c8a5a1108ca3a07f2b3a00ef67769e1e397\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xc8ed8d2056934b7675b695dec032f2920c2f5c6cf33a17ca85650940675323ab\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted to signal this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\",\"keccak256\":\"0x4d9a2b261b56a1e4a37bb038151dec98b952fed16de2bdfdda27e38e2b12b530\",\"license\":\"MIT\"},\"@openzeppelin/contracts/governance/utils/IVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/IVotes.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\\n */\\ninterface IVotes {\\n\\t/**\\n\\t * @dev The signature used has expired.\\n\\t */\\n\\terror VotesExpiredSignature(uint256 expiry);\\n\\n\\t/**\\n\\t * @dev Emitted when an account changes their delegate.\\n\\t */\\n\\tevent DelegateChanged(\\n\\t\\taddress indexed delegator,\\n\\t\\taddress indexed fromDelegate,\\n\\t\\taddress indexed toDelegate\\n\\t);\\n\\n\\t/**\\n\\t * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.\\n\\t */\\n\\tevent DelegateVotesChanged(\\n\\t\\taddress indexed delegate,\\n\\t\\tuint256 previousVotes,\\n\\t\\tuint256 newVotes\\n\\t);\\n\\n\\t/**\\n\\t * @dev Returns the current amount of votes that `account` has.\\n\\t */\\n\\tfunction getVotes(address account) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\\n\\t * configured to use block numbers, this will return the value at the end of the corresponding block.\\n\\t */\\n\\tfunction getPastVotes(\\n\\t\\taddress account,\\n\\t\\tuint256 timepoint\\n\\t) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n\\t * configured to use block numbers, this will return the value at the end of the corresponding block.\\n\\t *\\n\\t * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n\\t * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n\\t * vote.\\n\\t */\\n\\tfunction getPastTotalSupply(\\n\\t\\tuint256 timepoint\\n\\t) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the delegate that `account` has chosen.\\n\\t */\\n\\tfunction delegates(address account) external view returns (address);\\n\\n\\t/**\\n\\t * @dev Delegates votes from the sender to `delegatee`.\\n\\t */\\n\\tfunction delegate(address delegatee) external;\\n\\n\\t/**\\n\\t * @dev Delegates votes from signer to `delegatee`.\\n\\t */\\n\\tfunction delegateBySig(\\n\\t\\taddress delegatee,\\n\\t\\tuint256 nonce,\\n\\t\\tuint256 expiry,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external;\\n}\\n\",\"keccak256\":\"0xf349eb5f4d903322930be6bcecf5d5d613fadfc46f90cc48c0229bdd63da7b79\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Create2} from \\\"../utils/Create2.sol\\\";\\nimport {Errors} from \\\"../utils/Errors.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    error CloneArgumentsTooLong();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        return clone(implementation, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\\n     * to the new contract.\\n     *\\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\\n     */\\n    function clone(address implementation, uint256 value) internal returns (address instance) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(value, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        return cloneDeterministic(implementation, salt, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\\n     * a `value` parameter to send native currency to the new contract.\\n     *\\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\\n     */\\n    function cloneDeterministic(\\n        address implementation,\\n        bytes32 salt,\\n        uint256 value\\n    ) internal returns (address instance) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(value, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\\n     * access the arguments within the implementation, use {fetchCloneArgs}.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\\n        return cloneWithImmutableArgs(implementation, args, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\\n     * parameter to send native currency to the new contract.\\n     *\\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\\n     */\\n    function cloneWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        uint256 value\\n    ) internal returns (address instance) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\\n        assembly (\\\"memory-safe\\\") {\\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\\n        }\\n        if (instance == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\\n     * access the arguments within the implementation, use {fetchCloneArgs}.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\\n     * at the same address.\\n     */\\n    function cloneDeterministicWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        bytes32 salt\\n    ) internal returns (address instance) {\\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\\n     * but with a `value` parameter to send native currency to the new contract.\\n     *\\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\\n     */\\n    function cloneDeterministicWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        bytes32 salt,\\n        uint256 value\\n    ) internal returns (address instance) {\\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\\n        return Create2.deploy(value, salt, bytecode);\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\\n     */\\n    function predictDeterministicAddressWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\\n     */\\n    function predictDeterministicAddressWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\\n    }\\n\\n    /**\\n     * @dev Get the immutable args attached to a clone.\\n     *\\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\\n     *   function will return an empty array.\\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\\n     *   creation.\\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\\n     *   function should only be used to check addresses that are known to be clones.\\n     */\\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\\n        assembly (\\\"memory-safe\\\") {\\n            extcodecopy(instance, add(result, 32), 45, mload(result))\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\\n     *\\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\\n     * abi.encodePacked is more expensive but also more portable and easier to review.\\n     *\\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\\n     */\\n    function _cloneCodeWithImmutableArgs(\\n        address implementation,\\n        bytes memory args\\n    ) private pure returns (bytes memory) {\\n        if (args.length > 24531) revert CloneArgumentsTooLong();\\n        return\\n            abi.encodePacked(\\n                hex\\\"61\\\",\\n                uint16(args.length + 45),\\n                hex\\\"3d81600a3d39f3363d3d373d3d3d363d73\\\",\\n                implementation,\\n                hex\\\"5af43d82803e903d91602b57fd5bf3\\\",\\n                args\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x7162fa3c6971aa6f0a70160fed018edbb8b1db3af9b034ef3f7c224c3bdb7431\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x61a23d601c2ab69dd726ac55058604cbda98e1d728ba31a51c379a3f9eeea715\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC-721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC-721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xb5afb8e8eebc4d1c6404df2f5e1e6d2c3d24fd01e5dfc855314951ecfaae462d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            _revert(returndata);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {Errors.FailedCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\\n     * of an unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {Errors.FailedCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaa1d17c1129b127a4a401db2fbd72960e2671474be3d08cae71ccdc42f7624c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev There's no code to deploy.\\n     */\\n    error Create2EmptyBytecode();\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n        if (bytecode.length == 0) {\\n            revert Create2EmptyBytecode();\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n            // if no address was created, and returndata is not empty, bubble revert\\n            if and(iszero(addr), not(iszero(returndatasize()))) {\\n                let p := mload(0x40)\\n                returndatacopy(p, 0, returndatasize())\\n                revert(p, returndatasize())\\n            }\\n        }\\n        if (addr == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbb7e8401583d26268ea9103013bcdcd90866a7718bd91105ebd21c9bf11f4f06\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\",\"keccak256\":\"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"contracts/core/Verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.21;\\n\\nuint256 constant N = 32768;\\nuint256 constant LOG_N = 15;\\nuint256 constant NUMBER_OF_PUBLIC_INPUTS = 5;\\nlibrary HonkVerificationKey {\\n    function loadVerificationKey() internal pure returns (Honk.VerificationKey memory) {\\n        Honk.VerificationKey memory vk = Honk.VerificationKey({\\n            circuitSize: uint256(32768),\\n            logCircuitSize: uint256(15),\\n            publicInputsSize: uint256(5),\\n            ql: Honk.G1Point({ \\n               x: uint256(0x1b1092bfed678627bca6b5a99b59c9ed5fd36f7b2b94638535d516425520d2f2),\\n               y: uint256(0x0875649701394e7ff747aebfe9995b6277c41239102307d3ed5ae3efa635ff60)\\n            }),\\n            qr: Honk.G1Point({ \\n               x: uint256(0x2db4c0f63283b12104d836618e596e9955e985145dfb65afb3c9a5a2d0f941c0),\\n               y: uint256(0x0ccea7773e23b76dfa4bdbf1913d63afd180d7a681ef0b92a6a11fd1114f53d0)\\n            }),\\n            qo: Honk.G1Point({ \\n               x: uint256(0x212475f0e5df3e081336acb4662ae12a94ceb3745fdb74bf71c07bd5befff9ca),\\n               y: uint256(0x28d3429ca78c158bc155a25c17e77f97240034300045c1d9ad44394a33360aae)\\n            }),\\n            q4: Honk.G1Point({ \\n               x: uint256(0x16af7cb31da36b7dff154123eae8dca035f87e9ea6714210f951ff5b521bd283),\\n               y: uint256(0x0dafd73d3b7814e213bd91c8e4818ebeb7c666ba096f55d85583abcb48c9ab87)\\n            }),\\n            qm: Honk.G1Point({ \\n               x: uint256(0x21c550b1438dc8ebf5f9438329c27618816b2c7e9be26f61d1e7d2694746885d),\\n               y: uint256(0x1ec48a96d3af92361a0fe36ae346a66cec238ce38c1cef88a4d78603c4260c76)\\n            }),\\n            qc: Honk.G1Point({ \\n               x: uint256(0x036338794bc2e83abbda87c36617321e22505c6bc0676f05f1c031e568a85cbb),\\n               y: uint256(0x231b7ee64eaaececcf97e8870455356283644d0103e0df2e9d245cefbf9dc352)\\n            }),\\n            qArith: Honk.G1Point({ \\n               x: uint256(0x116de5b81a5aede5009ac50504cc96c09294bb6fbe5def4b3ad188d54f79d180),\\n               y: uint256(0x1a34e2a2a6a760b403436c589aeaf52763391e112cd5e904345f31e8a43c1ee8)\\n            }),\\n            qDeltaRange: Honk.G1Point({ \\n               x: uint256(0x05e2b2f1955f1adcb4cb10cb5d3456e6ae27cca4a63b80c9ada0b7438c78731a),\\n               y: uint256(0x189bbff856b447150480dcdb46433ef04cdc876932c6b279bd3c834e69474d1f)\\n            }),\\n            qElliptic: Honk.G1Point({ \\n               x: uint256(0x0e1fe04bfd9ad6c98620a71c94a21e9ae34e3186408269d382320ecdcc05f71d),\\n               y: uint256(0x19a1658d0bec3d05105e47174451a1446b9c9518272290f7e4df1df36788bb6c)\\n            }),\\n            qAux: Honk.G1Point({ \\n               x: uint256(0x17538e283d556aeef5673a93baef0b804bcffa6c0058a388f95316999a5a12b2),\\n               y: uint256(0x231373bf0a19b80ad59b3da467140a8a5c478ca52b349be55fccd8923be14db8)\\n            }),\\n            qLookup: Honk.G1Point({ \\n               x: uint256(0x027dc243c05f23b486f9eddc248b1502cd25d3fe70199576d12356fc34eb831e),\\n               y: uint256(0x2669855d180b3d2c7677536f6d50a01fb3a6f44b5d443582e317db8f9d8dd380)\\n            }),\\n            qPoseidon2External: Honk.G1Point({ \\n               x: uint256(0x0b56d6bc6e5f978b95dd7e5ed06c70bb9ef89ee0b9b1f6d6a6e6fe7bc7fb1cee),\\n               y: uint256(0x03fba156c032a430dbc1cacd26a4072bd08a66e1026bb789122cfc4c103cdc60)\\n            }),\\n            qPoseidon2Internal: Honk.G1Point({ \\n               x: uint256(0x0801455a876c4270411c837cbeb379fc9fd12c9e01d5aba455995debbf0470a0),\\n               y: uint256(0x191ab369271555acecba302d5d55823db826986dc9469c0c6939b1bce23f5920)\\n            }),\\n            s1: Honk.G1Point({ \\n               x: uint256(0x119759bfe9b61d27e14ab8c4ebf525f944041414f0ca1fb16e7871966f0f25ab),\\n               y: uint256(0x0fa2a98d7de50338ecf094557777e66950c71db125af27f498755c741241bc50)\\n            }),\\n            s2: Honk.G1Point({ \\n               x: uint256(0x08632a9f81ce23086c2300fcaba6ebd6383514e0d6dfbbeb41f750a5bad8f3cc),\\n               y: uint256(0x012ad0b2e84e362d7b3006337ea54b6e913f8005765e94bfce71a9121a99ed27)\\n            }),\\n            s3: Honk.G1Point({ \\n               x: uint256(0x10300b6250541ff656ce3d17fce4414e068d8ea8453eb463fc00166877e66335),\\n               y: uint256(0x1fc730854625e8897b70e5b3cda42db6077caedb73e32d2fe5e183ce361cebd6)\\n            }),\\n            s4: Honk.G1Point({ \\n               x: uint256(0x228bdcd463340ca888acad29309d10c0cbf2d0eb1693b4343094c8f3e271845c),\\n               y: uint256(0x06fa9848b3528e73aaa70bf5d00ada429a03d9b35165f1ecfa614484a195eb7f)\\n            }),\\n            t1: Honk.G1Point({ \\n               x: uint256(0x05ad93e0fe6cf03567818848f653efbeee650b46b0d5f2202f0db8ee947d7072),\\n               y: uint256(0x03bd3ca762932d873c5d25b87f90863f6b947d117ff5838a8d05b65855851ad0)\\n            }),\\n            t2: Honk.G1Point({ \\n               x: uint256(0x0881565dfaaf132c953c6e460cc8fbdf0bb7cf36fcfbf05ebccaf19c8e2a909c),\\n               y: uint256(0x204841f77b1d2ad6ca17f1541fcf6dacb1fb3669eb96642d1216232f2af35fa0)\\n            }),\\n            t3: Honk.G1Point({ \\n               x: uint256(0x2d755645e77ad802d8f528b276d99daee804bd57ed6c868264cafa1edef61e2e),\\n               y: uint256(0x0049b63f4c8b8560b3b780e5789f446b2e41de12e4518051f3cf2ad67470f38f)\\n            }),\\n            t4: Honk.G1Point({ \\n               x: uint256(0x22fc466c501266a499f94edac355eb757e4e218feb442c864acef0c0134f36d5),\\n               y: uint256(0x21535849fd42cd6f1f52800e55249888ca81684e332c640686309bad09b1a94c)\\n            }),\\n            id1: Honk.G1Point({ \\n               x: uint256(0x025fbda737380b401a4da92433644e80ce2177a5f9369689c3e1e8517c1922fe),\\n               y: uint256(0x0b668d47c870c3c350859737408695f8f10ca6c60f45469f98441fac8142d1f7)\\n            }),\\n            id2: Honk.G1Point({ \\n               x: uint256(0x2ea775f9bb3204487df29d1719c5eca067ac7329010121259571f7000cdf5ab4),\\n               y: uint256(0x19df1692fe7b1626f0316327113c853905730e9151364e24cd258f6133402911)\\n            }),\\n            id3: Honk.G1Point({ \\n               x: uint256(0x2a98104cba05d493b08483a1cf0d03a7d02350fde55f58f38a6e1f37980819cc),\\n               y: uint256(0x2afe213e7be609b7e0b4dc7415828998a316fb8e6c9ecbc91544d3ec76717cb4)\\n            }),\\n            id4: Honk.G1Point({ \\n               x: uint256(0x25bfc35e0017fd04d8144ee8eff19a7014892a108c37fa0c50c77a2932344b24),\\n               y: uint256(0x2959f14438e433acb2c23cd56cf3f5410eda8fb36f8064310dc71a44c08ee072)\\n            }),\\n            lagrangeFirst: Honk.G1Point({ \\n               x: uint256(0x0000000000000000000000000000000000000000000000000000000000000001),\\n               y: uint256(0x0000000000000000000000000000000000000000000000000000000000000002)\\n            }),\\n            lagrangeLast: Honk.G1Point({ \\n               x: uint256(0x13baf8ffa7bed9be034c147165999d94297328cbc1f54b8d8e6d0d60983d2cdc),\\n               y: uint256(0x0f35e40238b49695cbdb41c437de2bc05dbda0ff9bb1f35481e9738bcf912ca7)\\n            })\\n        });\\n        return vk;\\n    }\\n}\\n\\npragma solidity ^0.8.27;\\n\\ntype Fr is uint256;\\n\\nusing { add as + } for Fr global;\\nusing { sub as - } for Fr global;\\nusing { mul as * } for Fr global;\\nusing { exp as ^ } for Fr global;\\nusing { notEqual as != } for Fr global;\\nusing { equal as == } for Fr global;\\n\\nuint256 constant MODULUS =\\n    21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order\\n\\nFr constant MINUS_ONE = Fr.wrap(MODULUS - 1);\\n\\n// Instantiation\\nlibrary FrLib\\n{\\n    function from(uint256 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(value % MODULUS);\\n    }\\n\\n    function fromBytes32(bytes32 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(uint256(value) % MODULUS);\\n    }\\n\\n    function toBytes32(Fr value) internal pure returns(bytes32)\\n    {\\n        return bytes32(Fr.unwrap(value));\\n    }\\n\\n    function invert(Fr value) internal view returns(Fr)\\n    {\\n        uint256 v = Fr.unwrap(value);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), v)\\n            mstore(add(free, 0x80), sub(MODULUS, 2))\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function pow(Fr base, uint256 v) internal view returns(Fr)\\n    {\\n        uint256 b = Fr.unwrap(base);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), b)\\n            mstore(add(free, 0x80), v)\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function div(Fr numerator, Fr denominator) internal view returns(Fr)\\n    {\\n        return numerator * invert(denominator);\\n    }\\n\\n    function sqr(Fr value) internal pure returns (Fr) {\\n        return value * value;\\n    }\\n\\n    function unwrap(Fr value) internal pure returns (uint256) {\\n        return Fr.unwrap(value);\\n    }\\n\\n    function neg(Fr value) internal pure returns (Fr) {\\n        return Fr.wrap(MODULUS - Fr.unwrap(value));\\n    }\\n}\\n\\n// Free functions\\nfunction add(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction mul(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(mulmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction sub(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), MODULUS - Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction exp(Fr base, Fr exponent) pure returns(Fr)\\n{\\n    if (Fr.unwrap(exponent) == 0) return Fr.wrap(1);\\n\\n    for (uint256 i = 1; i < Fr.unwrap(exponent); i += i) {\\n        base = base * base;\\n    }\\n    return base;\\n}\\n\\nfunction notEqual(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) != Fr.unwrap(b);\\n}\\n\\nfunction equal(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) == Fr.unwrap(b);\\n}\\n\\nuint256 constant CONST_PROOF_SIZE_LOG_N = 28;\\n\\nuint256 constant NUMBER_OF_SUBRELATIONS = 26;\\nuint256 constant BATCHED_RELATION_PARTIAL_LENGTH = 8;\\nuint256 constant NUMBER_OF_ENTITIES = 40;\\nuint256 constant NUMBER_UNSHIFTED = 35;\\nuint256 constant NUMBER_TO_BE_SHIFTED = 5;\\n\\n// Alphas are used as relation separators so there should be NUMBER_OF_SUBRELATIONS - 1\\nuint256 constant NUMBER_OF_ALPHAS = 25;\\n\\n// Prime field order\\nuint256 constant Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583; // EC group order. F_q\\nuint256 constant P = 21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order, F_r\\n\\n// ENUM FOR WIRES\\nenum WIRE {\\n    Q_M,\\n    Q_C,\\n    Q_L,\\n    Q_R,\\n    Q_O,\\n    Q_4,\\n    Q_LOOKUP,\\n    Q_ARITH,\\n    Q_RANGE,\\n    Q_ELLIPTIC,\\n    Q_AUX,\\n    Q_POSEIDON2_EXTERNAL,\\n    Q_POSEIDON2_INTERNAL,\\n    SIGMA_1,\\n    SIGMA_2,\\n    SIGMA_3,\\n    SIGMA_4,\\n    ID_1,\\n    ID_2,\\n    ID_3,\\n    ID_4,\\n    TABLE_1,\\n    TABLE_2,\\n    TABLE_3,\\n    TABLE_4,\\n    LAGRANGE_FIRST,\\n    LAGRANGE_LAST,\\n    W_L,\\n    W_R,\\n    W_O,\\n    W_4,\\n    Z_PERM,\\n    LOOKUP_INVERSES,\\n    LOOKUP_READ_COUNTS,\\n    LOOKUP_READ_TAGS,\\n    W_L_SHIFT,\\n    W_R_SHIFT,\\n    W_O_SHIFT,\\n    W_4_SHIFT,\\n    Z_PERM_SHIFT\\n}\\n\\nlibrary Honk {\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    struct G1ProofPoint {\\n        uint256 x_0;\\n        uint256 x_1;\\n        uint256 y_0;\\n        uint256 y_1;\\n    }\\n\\n    struct VerificationKey {\\n        // Misc Params\\n        uint256 circuitSize;\\n        uint256 logCircuitSize;\\n        uint256 publicInputsSize;\\n        // Selectors\\n        G1Point qm;\\n        G1Point qc;\\n        G1Point ql;\\n        G1Point qr;\\n        G1Point qo;\\n        G1Point q4;\\n        G1Point qLookup; // Lookup\\n        G1Point qArith; // Arithmetic widget\\n        G1Point qDeltaRange; // Delta Range sort\\n        G1Point qAux; // Auxillary\\n        G1Point qElliptic; // Auxillary\\n        G1Point qPoseidon2External;\\n        G1Point qPoseidon2Internal;\\n        // Copy cnstraints\\n        G1Point s1;\\n        G1Point s2;\\n        G1Point s3;\\n        G1Point s4;\\n        // Copy identity\\n        G1Point id1;\\n        G1Point id2;\\n        G1Point id3;\\n        G1Point id4;\\n        // Precomputed lookup table\\n        G1Point t1;\\n        G1Point t2;\\n        G1Point t3;\\n        G1Point t4;\\n        // Fixed first and last\\n        G1Point lagrangeFirst;\\n        G1Point lagrangeLast;\\n    }\\n\\n    struct RelationParameters {\\n        // challenges\\n        Fr eta;\\n        Fr etaTwo;\\n        Fr etaThree;\\n        Fr beta;\\n        Fr gamma;\\n        // derived\\n        Fr publicInputsDelta;\\n    }\\n\\n\\n    struct Proof {\\n        // Free wires\\n        Honk.G1ProofPoint w1;\\n        Honk.G1ProofPoint w2;\\n        Honk.G1ProofPoint w3;\\n        Honk.G1ProofPoint w4;\\n        // Lookup helpers - Permutations\\n        Honk.G1ProofPoint zPerm;\\n        // Lookup helpers - logup\\n        Honk.G1ProofPoint lookupReadCounts;\\n        Honk.G1ProofPoint lookupReadTags;\\n        Honk.G1ProofPoint lookupInverses;\\n        // Sumcheck\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\\n        // Shplemini\\n        Honk.G1ProofPoint[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\\n        Honk.G1ProofPoint shplonkQ;\\n        Honk.G1ProofPoint kzgQuotient;\\n    }\\n}\\n\\n// Transcript library to generate fiat shamir challenges\\nstruct Transcript {\\n    // Oink\\n    Honk.RelationParameters relationParameters;\\n    Fr[NUMBER_OF_ALPHAS] alphas;\\n    Fr[CONST_PROOF_SIZE_LOG_N] gateChallenges;\\n    // Sumcheck\\n    Fr[CONST_PROOF_SIZE_LOG_N] sumCheckUChallenges;\\n    // Gemini\\n    Fr rho;\\n    Fr geminiR;\\n    // Shplonk\\n    Fr shplonkNu;\\n    Fr shplonkZ;\\n}\\n\\nlibrary TranscriptLib {\\n    function generateTranscript(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Transcript memory t)\\n    {\\n        Fr previousChallenge;\\n        (t.relationParameters, previousChallenge) =\\n            generateRelationParametersChallenges(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset, previousChallenge);\\n\\n        (t.alphas, previousChallenge) = generateAlphaChallenges(previousChallenge, proof);\\n\\n        (t.gateChallenges, previousChallenge) = generateGateChallenges(previousChallenge);\\n\\n        (t.sumCheckUChallenges, previousChallenge) = generateSumcheckChallenges(proof, previousChallenge);\\n\\n        (t.rho, previousChallenge) = generateRhoChallenge(proof, previousChallenge);\\n\\n        (t.geminiR, previousChallenge) = generateGeminiRChallenge(proof, previousChallenge);\\n\\n        (t.shplonkNu, previousChallenge) = generateShplonkNuChallenge(proof, previousChallenge);\\n\\n        (t.shplonkZ, previousChallenge) = generateShplonkZChallenge(proof, previousChallenge);\\n\\n        return t;\\n    }\\n\\n    function splitChallenge(Fr challenge) internal pure returns (Fr first, Fr second) {\\n        uint256 challengeU256 = uint256(Fr.unwrap(challenge));\\n        uint256 lo = challengeU256 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        uint256 hi = challengeU256 >> 128;\\n        first = FrLib.fromBytes32(bytes32(lo));\\n        second = FrLib.fromBytes32(bytes32(hi));\\n    }\\n\\n    function generateRelationParametersChallenges(\\n        Honk.Proof memory proof,\\n        bytes32[] calldata publicInputs,\\n        uint256 circuitSize,\\n        uint256 publicInputsSize,\\n        uint256 pubInputsOffset,\\n        Fr previousChallenge\\n    ) internal pure returns (Honk.RelationParameters memory rp, Fr nextPreviousChallenge) {\\n        (rp.eta, rp.etaTwo, rp.etaThree, previousChallenge) =\\n            generateEtaChallenge(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset);\\n\\n        (rp.beta, rp.gamma, nextPreviousChallenge) = generateBetaAndGammaChallenges(previousChallenge, proof);\\n\\n    }\\n\\n    function generateEtaChallenge(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Fr eta, Fr etaTwo, Fr etaThree, Fr previousChallenge)\\n    {\\n        bytes32[] memory round0 = new bytes32[](3 + publicInputsSize + 12);\\n        round0[0] = bytes32(circuitSize);\\n        round0[1] = bytes32(publicInputsSize);\\n        round0[2] = bytes32(pubInputsOffset);\\n        for (uint256 i = 0; i < publicInputsSize; i++) {\\n            round0[3 + i] = bytes32(publicInputs[i]);\\n        }\\n\\n        // Create the first challenge\\n        // Note: w4 is added to the challenge later on\\n        round0[3 + publicInputsSize] = bytes32(proof.w1.x_0);\\n        round0[3 + publicInputsSize + 1] = bytes32(proof.w1.x_1);\\n        round0[3 + publicInputsSize + 2] = bytes32(proof.w1.y_0);\\n        round0[3 + publicInputsSize + 3] = bytes32(proof.w1.y_1);\\n        round0[3 + publicInputsSize + 4] = bytes32(proof.w2.x_0);\\n        round0[3 + publicInputsSize + 5] = bytes32(proof.w2.x_1);\\n        round0[3 + publicInputsSize + 6] = bytes32(proof.w2.y_0);\\n        round0[3 + publicInputsSize + 7] = bytes32(proof.w2.y_1);\\n        round0[3 + publicInputsSize + 8] = bytes32(proof.w3.x_0);\\n        round0[3 + publicInputsSize + 9] = bytes32(proof.w3.x_1);\\n        round0[3 + publicInputsSize + 10] = bytes32(proof.w3.y_0);\\n        round0[3 + publicInputsSize + 11] = bytes32(proof.w3.y_1);\\n\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round0)));\\n        (eta, etaTwo) = splitChallenge(previousChallenge);\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n        Fr unused;\\n        (etaThree, unused) = splitChallenge(previousChallenge);\\n    }\\n\\n    function generateBetaAndGammaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr beta, Fr gamma, Fr nextPreviousChallenge)\\n    {\\n        bytes32[13] memory round1;\\n        round1[0] = FrLib.toBytes32(previousChallenge);\\n        round1[1] = bytes32(proof.lookupReadCounts.x_0);\\n        round1[2] = bytes32(proof.lookupReadCounts.x_1);\\n        round1[3] = bytes32(proof.lookupReadCounts.y_0);\\n        round1[4] = bytes32(proof.lookupReadCounts.y_1);\\n        round1[5] = bytes32(proof.lookupReadTags.x_0);\\n        round1[6] = bytes32(proof.lookupReadTags.x_1);\\n        round1[7] = bytes32(proof.lookupReadTags.y_0);\\n        round1[8] = bytes32(proof.lookupReadTags.y_1);\\n        round1[9] = bytes32(proof.w4.x_0);\\n        round1[10] = bytes32(proof.w4.x_1);\\n        round1[11] = bytes32(proof.w4.y_0);\\n        round1[12] = bytes32(proof.w4.y_1);\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round1)));\\n        (beta, gamma) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    // Alpha challenges non-linearise the gate contributions\\n    function generateAlphaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr[NUMBER_OF_ALPHAS] memory alphas, Fr nextPreviousChallenge)\\n    {\\n        // Generate the original sumcheck alpha 0 by hashing zPerm and zLookup\\n        uint256[9] memory alpha0;\\n        alpha0[0] = Fr.unwrap(previousChallenge);\\n        alpha0[1] = proof.lookupInverses.x_0;\\n        alpha0[2] = proof.lookupInverses.x_1;\\n        alpha0[3] = proof.lookupInverses.y_0;\\n        alpha0[4] = proof.lookupInverses.y_1;\\n        alpha0[5] = proof.zPerm.x_0;\\n        alpha0[6] = proof.zPerm.x_1;\\n        alpha0[7] = proof.zPerm.y_0;\\n        alpha0[8] = proof.zPerm.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(alpha0)));\\n        (alphas[0], alphas[1]) = splitChallenge(nextPreviousChallenge);\\n\\n        for (uint256 i = 1; i < NUMBER_OF_ALPHAS / 2; i++) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            (alphas[2 * i], alphas[2 * i + 1]) = splitChallenge(nextPreviousChallenge);\\n        }\\n        if (((NUMBER_OF_ALPHAS & 1) == 1) && (NUMBER_OF_ALPHAS > 2)) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            Fr unused;\\n            (alphas[NUMBER_OF_ALPHAS - 1], unused) = splitChallenge(nextPreviousChallenge);\\n        }\\n    }\\n\\n    function generateGateChallenges(Fr previousChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory gateChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n            Fr unused;\\n            (gateChallenges[i], unused) = splitChallenge(previousChallenge);\\n        }\\n        nextPreviousChallenge = previousChallenge;\\n    }\\n\\n    function generateSumcheckChallenges(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH + 1] memory univariateChal;\\n            univariateChal[0] = prevChallenge;\\n\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                univariateChal[j + 1] = proof.sumcheckUnivariates[i][j];\\n            }\\n            prevChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(univariateChal)));\\n            Fr unused;\\n            (sumcheckChallenges[i], unused) = splitChallenge(prevChallenge);\\n        }\\n        nextPreviousChallenge = prevChallenge;\\n    }\\n\\n    function generateRhoChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr rho, Fr nextPreviousChallenge)\\n    {\\n        Fr[NUMBER_OF_ENTITIES + 1] memory rhoChallengeElements;\\n        rhoChallengeElements[0] = prevChallenge;\\n\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            rhoChallengeElements[i + 1] = proof.sumcheckEvaluations[i];\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(rhoChallengeElements)));\\n        Fr unused;\\n        (rho, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateGeminiRChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr geminiR, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N - 1) * 4 + 1] memory gR;\\n        gR[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            gR[1 + i * 4] = proof.geminiFoldComms[i].x_0;\\n            gR[2 + i * 4] = proof.geminiFoldComms[i].x_1;\\n            gR[3 + i * 4] = proof.geminiFoldComms[i].y_0;\\n            gR[4 + i * 4] = proof.geminiFoldComms[i].y_1;\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(gR)));\\n        Fr unused;\\n        (geminiR, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkNuChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkNu, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N) + 1] memory shplonkNuChallengeElements;\\n        shplonkNuChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            shplonkNuChallengeElements[i + 1] = Fr.unwrap(proof.geminiAEvaluations[i]);\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkNuChallengeElements)));\\n        Fr unused;\\n        (shplonkNu, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkZChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkZ, Fr nextPreviousChallenge)\\n    {\\n        uint256[5] memory shplonkZChallengeElements;\\n        shplonkZChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        shplonkZChallengeElements[1] = proof.shplonkQ.x_0;\\n        shplonkZChallengeElements[2] = proof.shplonkQ.x_1;\\n        shplonkZChallengeElements[3] = proof.shplonkQ.y_0;\\n        shplonkZChallengeElements[4] = proof.shplonkQ.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkZChallengeElements)));\\n        Fr unused;\\n        (shplonkZ, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function loadProof(bytes calldata proof) internal pure returns (Honk.Proof memory p) {\\n        // Commitments\\n        p.w1 = bytesToG1ProofPoint(proof[0x0:0x80]);\\n\\n        p.w2 = bytesToG1ProofPoint(proof[0x80:0x100]);\\n        p.w3 = bytesToG1ProofPoint(proof[0x100:0x180]);\\n\\n        // Lookup / Permutation Helper Commitments\\n        p.lookupReadCounts = bytesToG1ProofPoint(proof[0x180:0x200]);\\n        p.lookupReadTags = bytesToG1ProofPoint(proof[0x200:0x280]);\\n        p.w4 = bytesToG1ProofPoint(proof[0x280:0x300]);\\n        p.lookupInverses = bytesToG1ProofPoint(proof[0x300:0x380]);\\n        p.zPerm = bytesToG1ProofPoint(proof[0x380:0x400]);\\n        uint256 boundary = 0x400;\\n\\n        // Sumcheck univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                p.sumcheckUnivariates[i][j] = bytesToFr(proof[boundary:boundary + 0x20]);\\n                boundary += 0x20;\\n            }\\n        }\\n        // Sumcheck evaluations\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            p.sumcheckEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Gemini\\n        // Read gemini fold univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            p.geminiFoldComms[i] = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n            boundary += 0x80;\\n        }\\n\\n        // Read gemini a evaluations\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            p.geminiAEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Shplonk\\n        p.shplonkQ = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n        boundary = boundary + 0x80;\\n        // KZG\\n        p.kzgQuotient = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n    }\\n}\\n\\n\\n// Fr utility\\n\\nfunction bytesToFr(bytes calldata proofSection) pure returns (Fr scalar) {\\n    require(proofSection.length == 0x20, \\\"invalid bytes scalar\\\");\\n    scalar = FrLib.fromBytes32(bytes32(proofSection));\\n}\\n\\n// EC Point utilities\\nfunction convertProofPoint(Honk.G1ProofPoint memory input) pure returns (Honk.G1Point memory) {\\n    return Honk.G1Point({x: input.x_0 | (input.x_1 << 136), y: input.y_0 | (input.y_1 << 136)});\\n}\\n\\nfunction bytesToG1ProofPoint(bytes calldata proofSection) pure returns (Honk.G1ProofPoint memory point) {\\n    require(proofSection.length == 0x80, \\\"invalid bytes point\\\");\\n    point = Honk.G1ProofPoint({\\n        x_0: uint256(bytes32(proofSection[0x00:0x20])),\\n        x_1: uint256(bytes32(proofSection[0x20:0x40])),\\n        y_0: uint256(bytes32(proofSection[0x40:0x60])),\\n        y_1: uint256(bytes32(proofSection[0x60:0x80]))\\n    });\\n}\\n\\nfunction negateInplace(Honk.G1Point memory point) pure returns (Honk.G1Point memory) {\\n    point.y = (Q - point.y) % Q;\\n    return point;\\n}\\n\\n function pairing(Honk.G1Point memory rhs, Honk.G1Point memory lhs) view returns (bool) {\\n        bytes memory input = abi.encodePacked(\\n            rhs.x,\\n            rhs.y,\\n            // Fixed G1 point\\n            uint256(0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2),\\n            uint256(0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed),\\n            uint256(0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b),\\n            uint256(0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa),\\n            lhs.x,\\n            lhs.y,\\n            // G1 point from VK\\n            uint256(0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1),\\n            uint256(0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0),\\n            uint256(0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4),\\n            uint256(0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\\n        );\\n\\n        (bool success, bytes memory result) = address(0x08).staticcall(input);\\n        bool decodedResult = abi.decode(result, (bool));\\n        return success && decodedResult;\\n    }\\n\\n\\nlibrary RelationsLib {\\n    Fr internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = Fr.wrap(17); // -(-17)\\n\\n    function accumulateRelationEvaluations(\\n         Fr[NUMBER_OF_ENTITIES] memory purportedEvaluations,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_ALPHAS] memory alphas,\\n        Fr powPartialEval\\n    ) internal pure returns (Fr accumulator) {\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations;\\n\\n        // Accumulate all relations in Ultra Honk - each with varying number of subrelations\\n        accumulateArithmeticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePermutationRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateLogDerivativeLookupRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateDeltaRangeRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateEllipticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateAuxillaryRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulatePoseidonExternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePoseidonInternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        // batch the subrelations with the alpha challenges to obtain the full honk relation\\n        accumulator = scaleAndBatchSubrelations(evaluations, alphas);\\n    }\\n\\n    /**\\n     * Aesthetic helper function that is used to index by enum into proof.sumcheckEvaluations, it avoids\\n     * the relation checking code being cluttered with uint256 type casting, which is often a different colour in code\\n     * editors, and thus is noisy.\\n     */\\n    function wire(Fr[NUMBER_OF_ENTITIES] memory p, WIRE _wire) internal pure returns (Fr) {\\n        return p[uint256(_wire)];\\n    }\\n\\n    uint256 internal constant NEG_HALF_MODULO_P = 0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    /**\\n     * Ultra Arithmetic Relation\\n     *\\n     */\\n    function accumulateArithmeticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        // Relation 0\\n        Fr q_arith = wire(p, WIRE.Q_ARITH);\\n        {\\n            Fr neg_half = Fr.wrap(NEG_HALF_MODULO_P);\\n\\n            Fr accum = (q_arith - Fr.wrap(3)) * (wire(p, WIRE.Q_M) * wire(p, WIRE.W_R) * wire(p, WIRE.W_L)) * neg_half;\\n            accum = accum + (wire(p, WIRE.Q_L) * wire(p, WIRE.W_L)) + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_R))\\n                + (wire(p, WIRE.Q_O) * wire(p, WIRE.W_O)) + (wire(p, WIRE.Q_4) * wire(p, WIRE.W_4)) + wire(p, WIRE.Q_C);\\n            accum = accum + (q_arith - Fr.wrap(1)) * wire(p, WIRE.W_4_SHIFT);\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[0] = accum;\\n        }\\n\\n        // Relation 1\\n        {\\n            Fr accum = wire(p, WIRE.W_L) + wire(p, WIRE.W_4) - wire(p, WIRE.W_L_SHIFT) + wire(p, WIRE.Q_M);\\n            accum = accum * (q_arith - Fr.wrap(2));\\n            accum = accum * (q_arith - Fr.wrap(1));\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[1] = accum;\\n        }\\n    }\\n\\n    function accumulatePermutationRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr grand_product_numerator;\\n        Fr grand_product_denominator;\\n\\n        {\\n            Fr num = wire(p, WIRE.W_L) + wire(p, WIRE.ID_1) * rp.beta + rp.gamma;\\n            num = num * (wire(p, WIRE.W_R) + wire(p, WIRE.ID_2) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_O) + wire(p, WIRE.ID_3) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_4) + wire(p, WIRE.ID_4) * rp.beta + rp.gamma);\\n\\n            grand_product_numerator = num;\\n        }\\n        {\\n            Fr den = wire(p, WIRE.W_L) + wire(p, WIRE.SIGMA_1) * rp.beta + rp.gamma;\\n            den = den * (wire(p, WIRE.W_R) + wire(p, WIRE.SIGMA_2) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_O) + wire(p, WIRE.SIGMA_3) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_4) + wire(p, WIRE.SIGMA_4) * rp.beta + rp.gamma);\\n\\n            grand_product_denominator = den;\\n        }\\n\\n        // Contribution 2\\n        {\\n            Fr acc = (wire(p, WIRE.Z_PERM) + wire(p, WIRE.LAGRANGE_FIRST)) * grand_product_numerator;\\n\\n            acc = acc\\n                - (\\n                    (wire(p, WIRE.Z_PERM_SHIFT) + (wire(p, WIRE.LAGRANGE_LAST) * rp.publicInputsDelta))\\n                        * grand_product_denominator\\n                );\\n            acc = acc * domainSep;\\n            evals[2] = acc;\\n        }\\n\\n        // Contribution 3\\n        {\\n            Fr acc = (wire(p, WIRE.LAGRANGE_LAST) * wire(p, WIRE.Z_PERM_SHIFT)) * domainSep;\\n            evals[3] = acc;\\n        }\\n    }\\n\\n    function accumulateLogDerivativeLookupRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr write_term;\\n        Fr read_term;\\n\\n        // Calculate the write term (the table accumulation)\\n        {\\n            write_term = wire(p, WIRE.TABLE_1) + rp.gamma + (wire(p, WIRE.TABLE_2) * rp.eta)\\n                + (wire(p, WIRE.TABLE_3) * rp.etaTwo) + (wire(p, WIRE.TABLE_4) * rp.etaThree);\\n        }\\n\\n        // Calculate the write term\\n        {\\n            Fr derived_entry_1 = wire(p, WIRE.W_L) + rp.gamma + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_L_SHIFT));\\n            Fr derived_entry_2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_M) * wire(p, WIRE.W_R_SHIFT);\\n            Fr derived_entry_3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_C) * wire(p, WIRE.W_O_SHIFT);\\n\\n            read_term = derived_entry_1 + (derived_entry_2 * rp.eta) + (derived_entry_3 * rp.etaTwo)\\n                + (wire(p, WIRE.Q_O) * rp.etaThree);\\n        }\\n\\n        Fr read_inverse = wire(p, WIRE.LOOKUP_INVERSES) * write_term;\\n        Fr write_inverse = wire(p, WIRE.LOOKUP_INVERSES) * read_term;\\n\\n        Fr inverse_exists_xor = wire(p, WIRE.LOOKUP_READ_TAGS) + wire(p, WIRE.Q_LOOKUP)\\n            - (wire(p, WIRE.LOOKUP_READ_TAGS) * wire(p, WIRE.Q_LOOKUP));\\n\\n        // Inverse calculated correctly relation\\n        Fr accumulatorNone = read_term * write_term * wire(p, WIRE.LOOKUP_INVERSES) - inverse_exists_xor;\\n        accumulatorNone = accumulatorNone * domainSep;\\n\\n        // Inverse\\n        Fr accumulatorOne = wire(p, WIRE.Q_LOOKUP) * read_inverse - wire(p, WIRE.LOOKUP_READ_COUNTS) * write_inverse;\\n\\n        evals[4] = accumulatorNone;\\n        evals[5] = accumulatorOne;\\n    }\\n\\n    function accumulateDeltaRangeRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr minus_one = Fr.wrap(0) - Fr.wrap(1);\\n        Fr minus_two = Fr.wrap(0) - Fr.wrap(2);\\n        Fr minus_three = Fr.wrap(0) - Fr.wrap(3);\\n\\n        // Compute wire differences\\n        Fr delta_1 = wire(p, WIRE.W_R) - wire(p, WIRE.W_L);\\n        Fr delta_2 = wire(p, WIRE.W_O) - wire(p, WIRE.W_R);\\n        Fr delta_3 = wire(p, WIRE.W_4) - wire(p, WIRE.W_O);\\n        Fr delta_4 = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_4);\\n\\n        // Contribution 6\\n        {\\n            Fr acc = delta_1;\\n            acc = acc * (delta_1 + minus_one);\\n            acc = acc * (delta_1 + minus_two);\\n            acc = acc * (delta_1 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[6] = acc;\\n        }\\n\\n        // Contribution 7\\n        {\\n            Fr acc = delta_2;\\n            acc = acc * (delta_2 + minus_one);\\n            acc = acc * (delta_2 + minus_two);\\n            acc = acc * (delta_2 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[7] = acc;\\n        }\\n\\n        // Contribution 8\\n        {\\n            Fr acc = delta_3;\\n            acc = acc * (delta_3 + minus_one);\\n            acc = acc * (delta_3 + minus_two);\\n            acc = acc * (delta_3 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[8] = acc;\\n        }\\n\\n        // Contribution 9\\n        {\\n            Fr acc = delta_4;\\n            acc = acc * (delta_4 + minus_one);\\n            acc = acc * (delta_4 + minus_two);\\n            acc = acc * (delta_4 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[9] = acc;\\n        }\\n    }\\n\\n    struct EllipticParams {\\n        // Points\\n        Fr x_1;\\n        Fr y_1;\\n        Fr x_2;\\n        Fr y_2;\\n        Fr y_3;\\n        Fr x_3;\\n        // push accumulators into memory\\n        Fr x_double_identity;\\n    }\\n\\n    function accumulateEllipticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        EllipticParams memory ep;\\n        ep.x_1 = wire(p, WIRE.W_R);\\n        ep.y_1 = wire(p, WIRE.W_O);\\n\\n        ep.x_2 = wire(p, WIRE.W_L_SHIFT);\\n        ep.y_2 = wire(p, WIRE.W_4_SHIFT);\\n        ep.y_3 = wire(p, WIRE.W_O_SHIFT);\\n        ep.x_3 = wire(p, WIRE.W_R_SHIFT);\\n\\n        Fr q_sign = wire(p, WIRE.Q_L);\\n        Fr q_is_double = wire(p, WIRE.Q_M);\\n\\n        // Contribution 10 point addition, x-coordinate check\\n        // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n        Fr x_diff = (ep.x_2 - ep.x_1);\\n        Fr y1_sqr = (ep.y_1 * ep.y_1);\\n        {\\n            // Move to top\\n            Fr partialEval = domainSep;\\n\\n            Fr y2_sqr = (ep.y_2 * ep.y_2);\\n            Fr y1y2 = ep.y_1 * ep.y_2 * q_sign;\\n            Fr x_add_identity = (ep.x_3 + ep.x_2 + ep.x_1);\\n            x_add_identity = x_add_identity * x_diff * x_diff;\\n            x_add_identity = x_add_identity - y2_sqr - y1_sqr + y1y2 + y1y2;\\n\\n            evals[10] = x_add_identity * partialEval * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 11 point addition, x-coordinate check\\n        // q_elliptic * (q_sign * y1 + y3)(x2 - x1) + (x3 - x1)(y2 - q_sign * y1) = 0\\n        {\\n            Fr y1_plus_y3 = ep.y_1 + ep.y_3;\\n            Fr y_diff = ep.y_2 * q_sign - ep.y_1;\\n            Fr y_add_identity = y1_plus_y3 * x_diff + (ep.x_3 - ep.x_1) * y_diff;\\n            evals[11] = y_add_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 10 point doubling, x-coordinate check\\n        // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n        // N.B. we're using the equivalence x1*x1*x1 === y1*y1 - curve_b to reduce degree by 1\\n        {\\n            Fr x_pow_4 = (y1_sqr + GRUMPKIN_CURVE_B_PARAMETER_NEGATED) * ep.x_1;\\n            Fr y1_sqr_mul_4 = y1_sqr + y1_sqr;\\n            y1_sqr_mul_4 = y1_sqr_mul_4 + y1_sqr_mul_4;\\n            Fr x1_pow_4_mul_9 = x_pow_4 * Fr.wrap(9);\\n\\n            // NOTE: pushed into memory (stack >:'( )\\n            ep.x_double_identity = (ep.x_3 + ep.x_1 + ep.x_1) * y1_sqr_mul_4 - x1_pow_4_mul_9;\\n\\n            Fr acc = ep.x_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n            evals[10] = evals[10] + acc;\\n        }\\n\\n        // Contribution 11 point doubling, y-coordinate check\\n        // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n        {\\n            Fr x1_sqr_mul_3 = (ep.x_1 + ep.x_1 + ep.x_1) * ep.x_1;\\n            Fr y_double_identity = x1_sqr_mul_3 * (ep.x_1 - ep.x_3) - (ep.y_1 + ep.y_1) * (ep.y_1 + ep.y_3);\\n            evals[11] = evals[11] + y_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n        }\\n    }\\n\\n    // Constants for the auxiliary relation\\n    Fr constant LIMB_SIZE = Fr.wrap(uint256(1) << 68);\\n    Fr constant SUBLIMB_SHIFT = Fr.wrap(uint256(1) << 14);\\n\\n    // Parameters used within the Auxiliary Relation\\n    // A struct is used to work around stack too deep. This relation has alot of variables\\n    struct AuxParams {\\n        Fr limb_subproduct;\\n        Fr non_native_field_gate_1;\\n        Fr non_native_field_gate_2;\\n        Fr non_native_field_gate_3;\\n        Fr limb_accumulator_1;\\n        Fr limb_accumulator_2;\\n        Fr memory_record_check;\\n        Fr partial_record_check;\\n        Fr next_gate_access_type;\\n        Fr record_delta;\\n        Fr index_delta;\\n        Fr adjacent_values_match_if_adjacent_indices_match;\\n        Fr adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n        Fr access_check;\\n        Fr next_gate_access_type_is_boolean;\\n        Fr ROM_consistency_check_identity;\\n        Fr RAM_consistency_check_identity;\\n        Fr timestamp_delta;\\n        Fr RAM_timestamp_check_identity;\\n        Fr memory_identity;\\n        Fr index_is_monotonically_increasing;\\n        Fr auxiliary_identity;\\n    }\\n\\n    function accumulateAuxillaryRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        AuxParams memory ap;\\n\\n        /**\\n         * Contribution 12\\n         * Non native field arithmetic gate 2\\n         * deg 4\\n         *\\n         *             _                                                                               _\\n         *            /   _                   _                               _       14                \\\\\\n         * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n         *            \\\\_                                                                               _/\\n         *\\n         *\\n         */\\n        ap.limb_subproduct = wire(p, WIRE.W_L) * wire(p, WIRE.W_R_SHIFT) + wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R);\\n        ap.non_native_field_gate_2 =\\n            (wire(p, WIRE.W_L) * wire(p, WIRE.W_4) + wire(p, WIRE.W_R) * wire(p, WIRE.W_O) - wire(p, WIRE.W_O_SHIFT));\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * LIMB_SIZE;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 + ap.limb_subproduct;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * wire(p, WIRE.Q_4);\\n\\n        ap.limb_subproduct = ap.limb_subproduct * LIMB_SIZE;\\n        ap.limb_subproduct = ap.limb_subproduct + (wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R_SHIFT));\\n        ap.non_native_field_gate_1 = ap.limb_subproduct;\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 - (wire(p, WIRE.W_O) + wire(p, WIRE.W_4));\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 * wire(p, WIRE.Q_O);\\n\\n        ap.non_native_field_gate_3 = ap.limb_subproduct;\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 + wire(p, WIRE.W_4);\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 - (wire(p, WIRE.W_O_SHIFT) + wire(p, WIRE.W_4_SHIFT));\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 * wire(p, WIRE.Q_M);\\n\\n        Fr non_native_field_identity =\\n            ap.non_native_field_gate_1 + ap.non_native_field_gate_2 + ap.non_native_field_gate_3;\\n        non_native_field_identity = non_native_field_identity * wire(p, WIRE.Q_R);\\n\\n        // ((((w2' * 2^14 + w1') * 2^14 + w3) * 2^14 + w2) * 2^14 + w1 - w4) * qm\\n        // deg 2\\n        ap.limb_accumulator_1 = wire(p, WIRE.W_R_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_R);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 - wire(p, WIRE.W_4);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * wire(p, WIRE.Q_4);\\n\\n        // ((((w3' * 2^14 + w2') * 2^14 + w1') * 2^14 + w4) * 2^14 + w3 - w4') * qm\\n        // deg 2\\n        ap.limb_accumulator_2 = wire(p, WIRE.W_O_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_R_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_4);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * wire(p, WIRE.Q_M);\\n\\n        Fr limb_accumulator_identity = ap.limb_accumulator_1 + ap.limb_accumulator_2;\\n        limb_accumulator_identity = limb_accumulator_identity * wire(p, WIRE.Q_O); //  deg 3\\n\\n        /**\\n         * MEMORY\\n         *\\n         * A RAM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * t: `timestamp` of memory cell being accessed (used for RAM, set to 0 for ROM)\\n         *  * v: `value` of memory cell being accessed\\n         *  * a: `access` type of record. read: 0 = read, 1 = write\\n         *  * r: `record` of memory cell. record = access + index * eta + timestamp * eta_two + value * eta_three\\n         *\\n         * A ROM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * v: `value1` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * v2:`value2` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * r: `record` of memory cell. record = index * eta + value2 * eta_two + value1 * eta_three\\n         *\\n         *  When performing a read/write access, the values of i, t, v, v2, a, r are stored in the following wires +\\n         * selectors, depending on whether the gate is a RAM read/write or a ROM read\\n         *\\n         *  | gate type | i  | v2/t  |  v | a  | r  |\\n         *  | --------- | -- | ----- | -- | -- | -- |\\n         *  | ROM       | w1 | w2    | w3 | -- | w4 |\\n         *  | RAM       | w1 | w2    | w3 | qc | w4 |\\n         *\\n         * (for accesses where `index` is a circuit constant, it is assumed the circuit will apply a copy constraint on\\n         * `w2` to fix its value)\\n         *\\n         *\\n         */\\n\\n        /**\\n         * Memory Record Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * A ROM/ROM access gate can be evaluated with the identity:\\n         *\\n         * qc + w1 \\\\eta + w2 \\\\eta_two + w3 \\\\eta_three - w4 = 0\\n         *\\n         * For ROM gates, qc = 0\\n         */\\n        ap.memory_record_check = wire(p, WIRE.W_O) * rp.etaThree;\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_R) * rp.etaTwo);\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_L) * rp.eta);\\n        ap.memory_record_check = ap.memory_record_check + wire(p, WIRE.Q_C);\\n        ap.partial_record_check = ap.memory_record_check; // used in RAM consistency check; deg 1 or 4\\n        ap.memory_record_check = ap.memory_record_check - wire(p, WIRE.W_4);\\n\\n        /**\\n         * Contribution 13 & 14\\n         * ROM Consistency Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * For every ROM read, a set equivalence check is applied between the record witnesses, and a second set of\\n         * records that are sorted.\\n         *\\n         * We apply the following checks for the sorted records:\\n         *\\n         * 1. w1, w2, w3 correctly map to 'index', 'v1, 'v2' for a given record value at w4\\n         * 2. index values for adjacent records are monotonically increasing\\n         * 3. if, at gate i, index_i == index_{i + 1}, then value1_i == value1_{i + 1} and value2_i == value2_{i + 1}\\n         *\\n         */\\n        ap.index_delta = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_L);\\n        ap.record_delta = wire(p, WIRE.W_4_SHIFT) - wire(p, WIRE.W_4);\\n\\n        ap.index_is_monotonically_increasing = ap.index_delta * ap.index_delta - ap.index_delta; // deg 2\\n\\n        ap.adjacent_values_match_if_adjacent_indices_match = (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.record_delta; // deg 2\\n\\n        evals[13] = ap.adjacent_values_match_if_adjacent_indices_match * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n        evals[14] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n\\n        ap.ROM_consistency_check_identity = ap.memory_record_check * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R)); // deg 3 or 7\\n\\n        /**\\n         * Contributions 15,16,17\\n         * RAM Consistency Check\\n         *\\n         * The 'access' type of the record is extracted with the expression `w_4 - ap.partial_record_check`\\n         * (i.e. for an honest Prover `w1 * eta + w2 * eta^2 + w3 * eta^3 - w4 = access`.\\n         * This is validated by requiring `access` to be boolean\\n         *\\n         * For two adjacent entries in the sorted list if _both_\\n         *  A) index values match\\n         *  B) adjacent access value is 0 (i.e. next gate is a READ)\\n         * then\\n         *  C) both values must match.\\n         * The gate boolean check is\\n         * (A && B) => C  === !(A && B) || C ===  !A || !B || C\\n         *\\n         * N.B. it is the responsibility of the circuit writer to ensure that every RAM cell is initialized\\n         * with a WRITE operation.\\n         */\\n        Fr access_type = (wire(p, WIRE.W_4) - ap.partial_record_check); // will be 0 or 1 for honest Prover; deg 1 or 4\\n        ap.access_check = access_type * access_type - access_type; // check value is 0 or 1; deg 2 or 8\\n\\n        ap.next_gate_access_type = wire(p, WIRE.W_O_SHIFT) * rp.etaThree;\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_R_SHIFT) * rp.etaTwo);\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_L_SHIFT) * rp.eta);\\n        ap.next_gate_access_type = wire(p, WIRE.W_4_SHIFT) - ap.next_gate_access_type;\\n\\n        Fr value_delta = wire(p, WIRE.W_O_SHIFT) - wire(p, WIRE.W_O);\\n        ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (\\n            ap.index_delta * MINUS_ONE + Fr.wrap(1)\\n        ) * value_delta * (ap.next_gate_access_type * MINUS_ONE + Fr.wrap(1)); // deg 3 or 6\\n\\n        // We can't apply the RAM consistency check identity on the final entry in the sorted list (the wires in the\\n        // next gate would make the identity fail).  We need to validate that its 'access type' bool is correct. Can't\\n        // do  with an arithmetic gate because of the  `eta` factors. We need to check that the *next* gate's access\\n        // type is  correct, to cover this edge case\\n        // deg 2 or 4\\n        ap.next_gate_access_type_is_boolean =\\n            ap.next_gate_access_type * ap.next_gate_access_type - ap.next_gate_access_type;\\n\\n        // Putting it all together...\\n        evals[15] = ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation\\n            * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5 or 8\\n        evals[16] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4\\n        evals[17] = ap.next_gate_access_type_is_boolean * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 6\\n\\n        ap.RAM_consistency_check_identity = ap.access_check * (wire(p, WIRE.Q_ARITH)); // deg 3 or 9\\n\\n        /**\\n         * RAM Timestamp Consistency Check\\n         *\\n         * | w1 | w2 | w3 | w4 |\\n         * | index | timestamp | timestamp_check | -- |\\n         *\\n         * Let delta_index = index_{i + 1} - index_{i}\\n         *\\n         * Iff delta_index == 0, timestamp_check = timestamp_{i + 1} - timestamp_i\\n         * Else timestamp_check = 0\\n         */\\n        ap.timestamp_delta = wire(p, WIRE.W_R_SHIFT) - wire(p, WIRE.W_R);\\n        ap.RAM_timestamp_check_identity =\\n            (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.timestamp_delta - wire(p, WIRE.W_O); // deg 3\\n\\n        /**\\n         * Complete Contribution 12\\n         * The complete RAM/ROM memory identity\\n         * Partial degree:\\n         */\\n        ap.memory_identity = ap.ROM_consistency_check_identity; // deg 3 or 6\\n        ap.memory_identity =\\n            ap.memory_identity + ap.RAM_timestamp_check_identity * (wire(p, WIRE.Q_4) * wire(p, WIRE.Q_L)); // deg 4\\n        ap.memory_identity = ap.memory_identity + ap.memory_record_check * (wire(p, WIRE.Q_M) * wire(p, WIRE.Q_L)); // deg 3 or 6\\n        ap.memory_identity = ap.memory_identity + ap.RAM_consistency_check_identity; // deg 3 or 9\\n\\n        // (deg 3 or 9) + (deg 4) + (deg 3)\\n        ap.auxiliary_identity = ap.memory_identity + non_native_field_identity + limb_accumulator_identity;\\n        ap.auxiliary_identity = ap.auxiliary_identity * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 10\\n        evals[12] = ap.auxiliary_identity;\\n    }\\n\\n    struct PoseidonExternalParams {\\n        Fr s1;\\n        Fr s2;\\n        Fr s3;\\n        Fr s4;\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr t0;\\n        Fr t1;\\n        Fr t2;\\n        Fr t3;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonExternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonExternalParams memory ep;\\n\\n        ep.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n        ep.s2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_R);\\n        ep.s3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_O);\\n        ep.s4 = wire(p, WIRE.W_4) + wire(p, WIRE.Q_4);\\n\\n        ep.u1 = ep.s1 * ep.s1 * ep.s1 * ep.s1 * ep.s1;\\n        ep.u2 = ep.s2 * ep.s2 * ep.s2 * ep.s2 * ep.s2;\\n        ep.u3 = ep.s3 * ep.s3 * ep.s3 * ep.s3 * ep.s3;\\n        ep.u4 = ep.s4 * ep.s4 * ep.s4 * ep.s4 * ep.s4;\\n        // matrix mul v = M_E * u with 14 additions\\n        ep.t0 = ep.u1 + ep.u2; // u_1 + u_2\\n        ep.t1 = ep.u3 + ep.u4; // u_3 + u_4\\n        ep.t2 = ep.u2 + ep.u2 + ep.t1; // 2u_2\\n        // ep.t2 += ep.t1; // 2u_2 + u_3 + u_4\\n        ep.t3 = ep.u4 + ep.u4 + ep.t0; // 2u_4\\n        // ep.t3 += ep.t0; // u_1 + u_2 + 2u_4\\n        ep.v4 = ep.t1 + ep.t1;\\n        ep.v4 = ep.v4 + ep.v4 + ep.t3;\\n        // ep.v4 += ep.t3; // u_1 + u_2 + 4u_3 + 6u_4\\n        ep.v2 = ep.t0 + ep.t0;\\n        ep.v2 = ep.v2 + ep.v2 + ep.t2;\\n        // ep.v2 += ep.t2; // 4u_1 + 6u_2 + u_3 + u_4\\n        ep.v1 = ep.t3 + ep.v2; // 5u_1 + 7u_2 + u_3 + 3u_4\\n        ep.v3 = ep.t2 + ep.v4; // u_1 + 3u_2 + 5u_3 + 7u_4\\n\\n        ep.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_EXTERNAL) * domainSep;\\n        evals[18] = evals[18] + ep.q_pos_by_scaling * (ep.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        evals[19] = evals[19] + ep.q_pos_by_scaling * (ep.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        evals[20] = evals[20] + ep.q_pos_by_scaling * (ep.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        evals[21] = evals[21] + ep.q_pos_by_scaling * (ep.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    struct PoseidonInternalParams {\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr u_sum;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr s1;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonInternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonInternalParams memory ip;\\n\\n        Fr[4] memory INTERNAL_MATRIX_DIAGONAL = [\\n            FrLib.from(0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7),\\n            FrLib.from(0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b),\\n            FrLib.from(0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15),\\n            FrLib.from(0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b)\\n        ];\\n\\n        // add round constants\\n        ip.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n\\n        // apply s-box round\\n        ip.u1 = ip.s1 * ip.s1 * ip.s1 * ip.s1 * ip.s1;\\n        ip.u2 = wire(p, WIRE.W_R);\\n        ip.u3 = wire(p, WIRE.W_O);\\n        ip.u4 = wire(p, WIRE.W_4);\\n\\n        // matrix mul with v = M_I * u 4 muls and 7 additions\\n        ip.u_sum = ip.u1 + ip.u2 + ip.u3 + ip.u4;\\n\\n        ip.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_INTERNAL) * domainSep;\\n\\n        ip.v1 = ip.u1 * INTERNAL_MATRIX_DIAGONAL[0] + ip.u_sum;\\n        evals[22] = evals[22] + ip.q_pos_by_scaling * (ip.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        ip.v2 = ip.u2 * INTERNAL_MATRIX_DIAGONAL[1] + ip.u_sum;\\n        evals[23] = evals[23] + ip.q_pos_by_scaling * (ip.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        ip.v3 = ip.u3 * INTERNAL_MATRIX_DIAGONAL[2] + ip.u_sum;\\n        evals[24] = evals[24] + ip.q_pos_by_scaling * (ip.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        ip.v4 = ip.u4 * INTERNAL_MATRIX_DIAGONAL[3] + ip.u_sum;\\n        evals[25] = evals[25] + ip.q_pos_by_scaling * (ip.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    function scaleAndBatchSubrelations(\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations,\\n        Fr[NUMBER_OF_ALPHAS] memory subrelationChallenges\\n    ) internal pure returns (Fr accumulator) {\\n        accumulator = accumulator + evaluations[0];\\n\\n        for (uint256 i = 1; i < NUMBER_OF_SUBRELATIONS; ++i) {\\n            accumulator = accumulator + evaluations[i] * subrelationChallenges[i - 1];\\n        }\\n    }\\n}\\n\\nstruct ShpleminiIntermediates {\\n    Fr unshiftedScalar;\\n    Fr shiftedScalar;\\n    // Scalar to be multiplied by [1]\\u2081\\n    Fr constantTermAccumulator;\\n    // Accumulator for powers of rho\\n    Fr batchingChallenge;\\n    // Linear combination of multilinear (sumcheck) evaluations and powers of rho\\n    Fr batchedEvaluation;\\n    // 1/(z - r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr posInvertedDenominator;\\n    // 1/(z + r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr negInvertedDenominator;\\n    // v^{2i} * 1/(z - r^{2^i})\\n    Fr scalingFactorPos;\\n    // v^{2i+1} * 1/(z + r^{2^i})\\n    Fr scalingFactorNeg;\\n    // // Fold_i(r^{2^i}) reconstructed by Verifier\\n    // Fr[CONST_PROOF_SIZE_LOG_N] foldPosEvaluations;\\n}\\n\\nlibrary CommitmentSchemeLib {\\n    using FrLib for Fr;\\n\\n    function computeSquares(Fr r) internal pure returns (Fr[CONST_PROOF_SIZE_LOG_N] memory squares) {\\n        squares[0] = r;\\n        for (uint256 i = 1; i < CONST_PROOF_SIZE_LOG_N; ++i) {\\n            squares[i] = squares[i - 1].sqr();\\n        }\\n    }\\n\\n    // Compute the evaluations  A_l(r^{2^l}) for l = 0, ..., m-1\\n    function computeFoldPosEvaluations(\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckUChallenges,\\n        Fr batchedEvalAccumulator,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvaluations,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvalChallengePowers,\\n        uint256 logSize\\n    ) internal view returns (Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations) {\\n        for (uint256 i = CONST_PROOF_SIZE_LOG_N; i > 0; --i) {\\n            Fr challengePower = geminiEvalChallengePowers[i - 1];\\n            Fr u = sumcheckUChallenges[i - 1];\\n\\n            Fr batchedEvalRoundAcc = (\\n                (challengePower * batchedEvalAccumulator * Fr.wrap(2))\\n                    - geminiEvaluations[i - 1] * (challengePower * (Fr.wrap(1) - u) - u)\\n            );\\n            // Divide by the denominator\\n            batchedEvalRoundAcc = batchedEvalRoundAcc * (challengePower * (Fr.wrap(1) - u) + u).invert();\\n\\n            if (i <= logSize) {\\n                batchedEvalAccumulator = batchedEvalRoundAcc;\\n                foldPosEvaluations[i - 1] = batchedEvalRoundAcc;\\n            }\\n        }\\n\\n    }\\n}\\n\\ninterface IVerifier {\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool);\\n}\\n\\n\\nabstract contract BaseHonkVerifier is IVerifier {\\n    using FrLib for Fr;\\n\\n    uint256 immutable n;\\n    uint256 immutable logN;\\n    uint256 immutable numPublicInputs;\\n\\n    constructor(uint256 _n, uint256 _logN, uint256 _numPublicInputs) {\\n        n = _n;\\n        logN = _logN;\\n        numPublicInputs = _numPublicInputs;\\n    }\\n\\n    error ProofLengthWrong();\\n    error PublicInputsLengthWrong();\\n    error SumcheckFailed();\\n    error ShpleminiFailed();\\n\\n    // Number of field elements in a ultra honk zero knowledge proof\\n    uint256 constant PROOF_SIZE = 456;\\n\\n    function loadVerificationKey() internal pure virtual returns (Honk.VerificationKey memory);\\n\\n    function verify(bytes calldata proof, bytes32[] calldata publicInputs) public view override returns (bool) {\\n         // Check the received proof is the expected size where each field element is 32 bytes\\n        if (proof.length != PROOF_SIZE * 32) {\\n            revert ProofLengthWrong();\\n        }\\n\\n        Honk.VerificationKey memory vk = loadVerificationKey();\\n        Honk.Proof memory p = TranscriptLib.loadProof(proof);\\n\\n        if (publicInputs.length != vk.publicInputsSize) {\\n            revert PublicInputsLengthWrong();\\n        }\\n\\n        // Generate the fiat shamir challenges for the whole protocol\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        Transcript memory t = TranscriptLib.generateTranscript(p, publicInputs, vk.circuitSize, vk.publicInputsSize, /*pubInputsOffset=*/1);\\n\\n        // Derive public input delta\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        t.relationParameters.publicInputsDelta = computePublicInputDelta(\\n            publicInputs, t.relationParameters.beta, t.relationParameters.gamma, /*pubInputsOffset=*/1\\n        );\\n\\n        // Sumcheck\\n        bool sumcheckVerified = verifySumcheck(p, t);\\n\\n        return !sumcheckVerified; // Boolean condition not required - nice for vanity :)\\n    }\\n\\n    function computePublicInputDelta(bytes32[] memory publicInputs, Fr beta, Fr gamma, uint256 offset)\\n        internal\\n        view\\n        returns (Fr publicInputDelta)\\n    {\\n        Fr numerator = Fr.wrap(1);\\n        Fr denominator = Fr.wrap(1);\\n\\n        Fr numeratorAcc = gamma + (beta * FrLib.from(n + offset));\\n        Fr denominatorAcc = gamma - (beta * FrLib.from(offset + 1));\\n\\n        {\\n            for (uint256 i = 0; i < numPublicInputs; i++) {\\n                Fr pubInput = FrLib.fromBytes32(publicInputs[i]);\\n\\n                numerator = numerator * (numeratorAcc + pubInput);\\n                denominator = denominator * (denominatorAcc + pubInput);\\n\\n                numeratorAcc = numeratorAcc + beta;\\n                denominatorAcc = denominatorAcc - beta;\\n            }\\n        }\\n\\n        // Fr delta = numerator / denominator; // TOOO: batch invert later?\\n        publicInputDelta = FrLib.div(numerator, denominator);\\n    }\\n\\n    function verifySumcheck(Honk.Proof memory proof, Transcript memory tp) internal view returns (bool verified) {\\n        Fr roundTarget;\\n        Fr powPartialEvaluation = Fr.wrap(1);\\n\\n        // We perform sumcheck reductions over log n rounds ( the multivariate degree )\\n        for (uint256 round; round < logN; ++round) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate = proof.sumcheckUnivariates[round];\\n            Fr roundChallenge = tp.sumCheckUChallenges[round];\\n\\n            // Update the round target for the next rounf\\n            roundTarget = computeNextTargetSum(roundUnivariate, roundChallenge);\\n            powPartialEvaluation = partiallyEvaluatePOW(tp.gateChallenges[round], powPartialEvaluation, roundChallenge);\\n        }\\n\\n        // Last round\\n        Fr grandHonkRelationSum =\\n            RelationsLib.accumulateRelationEvaluations(proof.sumcheckEvaluations, tp.relationParameters, tp.alphas, powPartialEvaluation);\\n        verified = (grandHonkRelationSum == roundTarget);\\n    }\\n\\n    function checkSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate, Fr roundTarget)\\n        internal\\n        pure\\n        returns (bool checked)\\n    {\\n        Fr totalSum = roundUnivariate[0] + roundUnivariate[1];\\n        checked = totalSum == roundTarget;\\n    }\\n\\n    // Return the new target sum for the next sumcheck round\\n    function computeNextTargetSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariates, Fr roundChallenge)\\n        internal\\n        view\\n        returns (Fr targetSum)\\n    {\\n        // TODO: inline\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory BARYCENTRIC_LAGRANGE_DENOMINATORS = [\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000002d0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff11),\\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000000090),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff71),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000000f0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000013b0)\\n        ];\\n\\n        // To compute the next target sum, we evaluate the given univariate at a point u (challenge).\\n\\n        // Performing Barycentric evaluations\\n        // Compute B(x)\\n        Fr numeratorValue = Fr.wrap(1);\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            numeratorValue = numeratorValue * (roundChallenge - Fr.wrap(i));\\n        }\\n\\n        // Calculate domain size N of inverses\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory denominatorInverses;\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr inv = BARYCENTRIC_LAGRANGE_DENOMINATORS[i];\\n            inv = inv * (roundChallenge - Fr.wrap(i));\\n            inv = FrLib.invert(inv);\\n            denominatorInverses[i] = inv;\\n        }\\n\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr term = roundUnivariates[i];\\n            term = term * denominatorInverses[i];\\n            targetSum = targetSum + term;\\n        }\\n\\n        // Scale the sum by the value of B(x)\\n        targetSum = targetSum * numeratorValue;\\n    }\\n\\n    // Univariate evaluation of the monomial ((1-X_l) + X_l.B_l) at the challenge point X_l=u_l\\n    function partiallyEvaluatePOW(Fr gateChallenge, Fr currentEvaluation, Fr roundChallenge)\\n        internal\\n        pure\\n        returns (Fr newEvaluation)\\n    {\\n        Fr univariateEval = Fr.wrap(1) + (roundChallenge * (gateChallenge - Fr.wrap(1)));\\n        newEvaluation = currentEvaluation * univariateEval;\\n    }\\n\\n    function verifyShplemini(Honk.Proof memory proof, Honk.VerificationKey memory vk, Transcript memory tp)\\n        internal\\n        view\\n        returns (bool verified)\\n    {\\n        ShpleminiIntermediates memory mem; // stack\\n\\n        // - Compute vector (r, r\\u00b2, ... , r\\u00b2\\u207d\\u207f\\u207b\\u00b9\\u207e), where n = log_circuit_size\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory powers_of_evaluation_challenge = CommitmentSchemeLib.computeSquares(tp.geminiR);\\n\\n        // Arrays hold values that will be linearly combined for the gemini and shplonk batch openings\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars;\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory commitments;\\n\\n        mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[0]).invert();\\n        mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[0]).invert();\\n\\n        mem.unshiftedScalar = mem.posInvertedDenominator + (tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.shiftedScalar =\\n            tp.geminiR.invert() * (mem.posInvertedDenominator - (tp.shplonkNu * mem.negInvertedDenominator));\\n\\n        scalars[0] = Fr.wrap(1);\\n        commitments[0] = convertProofPoint(proof.shplonkQ);\\n\\n        mem.batchingChallenge = Fr.wrap(1);\\n        mem.batchedEvaluation = Fr.wrap(0);\\n\\n        for (uint256 i = 1; i <= NUMBER_UNSHIFTED; ++i) {\\n            scalars[i] = mem.unshiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n        // g commitments are accumulated at r\\n        for (uint256 i = NUMBER_UNSHIFTED + 1; i <= NUMBER_OF_ENTITIES; ++i) {\\n            scalars[i] = mem.shiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n\\n        commitments[1] = vk.qm;\\n        commitments[2] = vk.qc;\\n        commitments[3] = vk.ql;\\n        commitments[4] = vk.qr;\\n        commitments[5] = vk.qo;\\n        commitments[6] = vk.q4;\\n        commitments[7] = vk.qLookup;\\n        commitments[8] = vk.qArith;\\n        commitments[9] = vk.qDeltaRange;\\n        commitments[10] = vk.qElliptic;\\n        commitments[11] = vk.qAux;\\n        commitments[12] = vk.qPoseidon2External;\\n        commitments[13] = vk.qPoseidon2Internal;\\n        commitments[14] = vk.s1;\\n        commitments[15] = vk.s2;\\n        commitments[16] = vk.s3;\\n        commitments[17] = vk.s4;\\n        commitments[18] = vk.id1;\\n        commitments[19] = vk.id2;\\n        commitments[20] = vk.id3;\\n        commitments[21] = vk.id4;\\n        commitments[22] = vk.t1;\\n        commitments[23] = vk.t2;\\n        commitments[24] = vk.t3;\\n        commitments[25] = vk.t4;\\n        commitments[26] = vk.lagrangeFirst;\\n        commitments[27] = vk.lagrangeLast;\\n\\n        // Accumulate proof points\\n        commitments[28] = convertProofPoint(proof.w1);\\n        commitments[29] = convertProofPoint(proof.w2);\\n        commitments[30] = convertProofPoint(proof.w3);\\n        commitments[31] = convertProofPoint(proof.w4);\\n        commitments[32] = convertProofPoint(proof.zPerm);\\n        commitments[33] = convertProofPoint(proof.lookupInverses);\\n        commitments[34] = convertProofPoint(proof.lookupReadCounts);\\n        commitments[35] = convertProofPoint(proof.lookupReadTags);\\n\\n        // to be Shifted\\n        commitments[36] = convertProofPoint(proof.w1);\\n        commitments[37] = convertProofPoint(proof.w2);\\n        commitments[38] = convertProofPoint(proof.w3);\\n        commitments[39] = convertProofPoint(proof.w4);\\n        commitments[40] = convertProofPoint(proof.zPerm);\\n\\n        // Add contributions from A\\u2080(r) and A\\u2080(-r) to constant_term_accumulator:\\n        // Compute the evaluations A_l(r^{2^l}) for l = 0, ..., logN - 1\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations = CommitmentSchemeLib.computeFoldPosEvaluations(\\n            tp.sumCheckUChallenges,\\n            mem.batchedEvaluation,\\n            proof.geminiAEvaluations,\\n            powers_of_evaluation_challenge,\\n            logN\\n        );\\n\\n        // Compute the Shplonk constant term contributions from A\\u2080(\\u00b1r)\\n        mem.constantTermAccumulator = foldPosEvaluations[0] * mem.posInvertedDenominator;\\n        mem.constantTermAccumulator =\\n            mem.constantTermAccumulator + (proof.geminiAEvaluations[0] * tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.batchingChallenge = tp.shplonkNu.sqr();\\n\\n        // Compute Shplonk constant term contributions from A\\u2097(\\u00b1r^{2\\u02e1}) for l = 1, ..., m-1;\\n        // Compute scalar multipliers for each fold commitment\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {\\n            bool dummy_round = i >= (logN - 1);\\n\\n            if (!dummy_round) {\\n                // Update inverted denominators\\n                mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[i + 1]).invert();\\n                mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[i + 1]).invert();\\n\\n                // Compute the scalar multipliers for A\\u2097(\\u00b1 r^{2\\u02e1}) and [A\\u2097]\\n                mem.scalingFactorPos = mem.batchingChallenge * mem.posInvertedDenominator;\\n                mem.scalingFactorNeg = mem.batchingChallenge * tp.shplonkNu * mem.negInvertedDenominator;\\n                // [A\\u2097] is multiplied by -v^{2l}/(z-r^{2^l}) - v^{2l+1} /(z+ r^{2^l})\\n                scalars[NUMBER_OF_ENTITIES + 1 + i] = mem.scalingFactorNeg.neg() + mem.scalingFactorPos.neg();\\n\\n                // Accumulate the const term contribution given by\\n                // v^{2l} * A\\u2097(r^{2\\u02e1}) /(z-r^{2^l}) + v^{2l+1} * A\\u2097(-r^{2\\u02e1}) /(z+ r^{2^l})\\n                Fr accumContribution = mem.scalingFactorNeg * proof.geminiAEvaluations[i + 1];\\n                accumContribution = accumContribution + mem.scalingFactorPos * foldPosEvaluations[i + 1];\\n                mem.constantTermAccumulator = mem.constantTermAccumulator + accumContribution;\\n                // Update the running power of v\\n                mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\\n            }\\n\\n            commitments[NUMBER_OF_ENTITIES + 1 + i] = convertProofPoint(proof.geminiFoldComms[i]);\\n        }\\n\\n        // Finalise the batch opening claim\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = Honk.G1Point({x: 1, y: 2});\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = mem.constantTermAccumulator;\\n\\n        Honk.G1Point memory quotient_commitment = convertProofPoint(proof.kzgQuotient);\\n\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = quotient_commitment;\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = tp.shplonkZ; // evaluation challenge\\n\\n        Honk.G1Point memory P_0 = batchMul(commitments, scalars);\\n        Honk.G1Point memory P_1 = negateInplace(quotient_commitment);\\n\\n        return pairing(P_0, P_1);\\n    }\\n\\n    // This implementation is the same as above with different constants\\n    function batchMul(\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory base,\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars\\n    ) internal view returns (Honk.G1Point memory result) {\\n        uint256 limit = NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2;\\n        assembly {\\n            let success := 0x01\\n            let free := mload(0x40)\\n\\n            // Write the original into the accumulator\\n            // Load into memory for ecMUL, leave offset for eccAdd result\\n            // base is an array of pointers, so we have to dereference them\\n            mstore(add(free, 0x40), mload(mload(base)))\\n            mstore(add(free, 0x60), mload(add(0x20, mload(base))))\\n            // Add scalar\\n            mstore(add(free, 0x80), mload(scalars))\\n            success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, free, 0x40))\\n\\n            let count := 0x01\\n            for {} lt(count, limit) { count := add(count, 1) } {\\n                // Get loop offsets\\n                let base_base := add(base, mul(count, 0x20))\\n                let scalar_base := add(scalars, mul(count, 0x20))\\n\\n                mstore(add(free, 0x40), mload(mload(base_base)))\\n                mstore(add(free, 0x60), mload(add(0x20, mload(base_base))))\\n                // Add scalar\\n                mstore(add(free, 0x80), mload(scalar_base))\\n\\n                success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, add(free, 0x40), 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, free, 0x80, free, 0x40))\\n            }\\n\\n            // Return the result - i hate this\\n            mstore(result, mload(free))\\n            mstore(add(result, 0x20), mload(add(free, 0x20)))\\n        }\\n    }\\n}\\n\\ncontract HonkVerifier is BaseHonkVerifier(N, LOG_N, NUMBER_OF_PUBLIC_INPUTS) {\\n     function loadVerificationKey() internal pure override returns (Honk.VerificationKey memory) {\\n       return HonkVerificationKey.loadVerificationKey();\\n    }\\n}\\n\",\"keccak256\":\"0xd86738bec5c515500af68ef54e49a2062b060ede28f53f54f7c326fcc5faadda\",\"license\":\"Apache-2.0\"},\"contracts/core/interfaces/IGovernor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IVotes} from '@openzeppelin/contracts/governance/utils/IVotes.sol';\\nimport {TimelockControllerUpgradeable} from '@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol';\\nimport {IVerifier} from '../Verifier.sol';\\n\\ninterface IGovernor {\\n\\t/// ======================\\n\\t/// ======= Structs ======\\n\\t/// ======================\\n\\n\\tstruct GovernorInitParams {\\n\\t\\tstring name;\\n\\t\\tIVotes token;\\n\\t\\tTimelockControllerUpgradeable timelock;\\n\\t\\tuint48 votingDelay;\\n\\t\\tuint32 votingPeriod;\\n\\t\\tuint256 proposalThreshold;\\n\\t\\tuint256 votesQuorumFraction;\\n\\t\\tuint256 id;\\n\\t\\tstring description;\\n\\t\\tstring logo;\\n\\t}\\n\\n\\tstruct PublicInputs {\\n\\t\\tuint256 proposalId;\\n\\t\\tuint256 weight;\\n\\t\\tuint8 choice;\\n\\t\\tbytes32 root;\\n\\t\\tuint256 nullifier;\\n\\t}\\n\\n\\tstruct ZKProposalVote {\\n\\t\\tuint256 againstVotes;\\n\\t\\tuint256 forVotes;\\n\\t\\tuint256 abstainVotes;\\n\\t\\t// NOTE: the mapping is not necessary for the current implementation\\n\\t\\t// mapping(uint256 => bool) hasNullified;\\n\\t}\\n\\n\\t/// ======================\\n\\t/// ======= Events =======\\n\\t/// ======================\\n\\n\\tevent ZKVoteCast(\\n\\t\\tuint256 indexed proposalId,\\n\\t\\tuint8 choice,\\n\\t\\tuint256 weight,\\n\\t\\tbytes32 nullifier\\n\\t);\\n\\n\\t/// =========================\\n\\t/// ====== Initializer ======\\n\\t/// =========================\\n\\n\\t/**\\n\\t * @notice Initializes the Governor contract\\n\\t * @param params Struct containing all initialization parameters\\n\\t * @param _verifier ZK-proof verifier contract\\n\\t */\\n\\tfunction initialize(\\n\\t\\tGovernorInitParams calldata params,\\n\\t\\tIVerifier _verifier\\n\\t) external;\\n\\n\\t/// ==========================\\n\\t/// ===== View Functions =====\\n\\t/// ==========================\\n\\n\\t/**\\n\\t * @notice Check if a nullifier has been used for a proposal\\n\\t * @param proposalId The proposal ID\\n\\t * @param nullifier The nullifier to check\\n\\t * @return True if nullifier has been used\\n\\t */\\n\\tfunction getNullifierUsed(\\n\\t\\tuint256 proposalId,\\n\\t\\tuint256 nullifier\\n\\t) external view returns (bool);\\n\\n\\t/**\\n\\t * @notice Get the merkle root for a proposal\\n\\t * @param proposalId The proposal ID\\n\\t * @return The merkle root\\n\\t */\\n\\tfunction getRoot(uint256 proposalId) external view returns (string memory);\\n\\n\\t/**\\n\\t * @notice Get ZK voting results for a proposal\\n\\t * @param proposalId The proposal ID\\n\\t * @return againstVotes Number of votes against\\n\\t * @return forVotes Number of votes for\\n\\t * @return abstainVotes Number of abstain votes\\n\\t */\\n\\tfunction getZKVote(\\n\\t\\tuint256 proposalId\\n\\t)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes);\\n\\n\\t/**\\n\\t * @notice Check if a proposal is waiting for merkle root\\n\\t * @param proposalId The proposal ID\\n\\t * @return True if waiting for merkle root\\n\\t */\\n\\tfunction isWaitingMerkle(uint256 proposalId) external view returns (bool);\\n\\n\\t/**\\n\\t * @notice Get the verifier contract address\\n\\t * @return The verifier contract\\n\\t */\\n\\tfunction verifier() external view returns (IVerifier);\\n\\n\\t/**\\n\\t * @notice Get the DAO ID\\n\\t * @return The DAO identifier\\n\\t */\\n\\tfunction id() external view returns (uint256);\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\t/**\\n\\t * @notice Cast a ZK vote on a proposal\\n\\t * @param _proposalId The proposal ID\\n\\t * @param _proof The ZK proof\\n\\t * @param _inputs The public inputs for verification\\n\\t */\\n\\tfunction castZKVote(\\n\\t\\tuint256 _proposalId,\\n\\t\\tbytes calldata _proof,\\n\\t\\tbytes32[] calldata _inputs\\n\\t) external;\\n\\n\\t/**\\n\\t * @notice Set the merkle root for a proposal (only callable by ZKDAO)\\n\\t * @param _proposalId The proposal ID\\n\\t * @param _cid The merkle root\\n\\t */\\n\\tfunction setRoot(uint256 _proposalId, string memory _cid) external;\\n\\n\\t/**\\n\\t * @notice Create a new proposal\\n\\t * @param targets Array of target addresses for proposal calls\\n\\t * @param values Array of values (in wei) for proposal calls\\n\\t * @param calldatas Array of call data for proposal calls\\n\\t * @param description String description of the proposal\\n\\t * @return proposalId The ID of the created proposal\\n\\t */\\n\\tfunction propose(\\n\\t\\taddress[] memory targets,\\n\\t\\tuint256[] memory values,\\n\\t\\tbytes[] memory calldatas,\\n\\t\\tstring memory description\\n\\t) external returns (uint256 proposalId);\\n}\\n\",\"keccak256\":\"0x97d2eb3baf6e064a06a5c11f41ce5ec171c280b6785ab2025590b788bc335d9c\",\"license\":\"MIT\"},\"contracts/core/interfaces/IGovernorToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ninterface IGovernorToken {\\n\\t/// =========================\\n\\t/// ====== Initializer ======\\n\\t/// =========================\\n\\n\\tfunction initialize(\\n\\t\\tstring memory _name,\\n\\t\\tstring memory _symbol,\\n\\t\\taddress _owner\\n\\t) external;\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\tfunction mint(address to, uint256 amount) external;\\n\\n\\tfunction mintBatch(address[] memory to, uint256[] memory amounts) external;\\n\\n\\tfunction transferOwnership(address newOwner) external;\\n}\\n\",\"keccak256\":\"0xa1063b863df330cc0e63222d20e9f75216071add1c0a29571d32067e312dc3b4\",\"license\":\"MIT\"},\"contracts/core/interfaces/ITimeLock.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ninterface ITimeLock {\\n\\t/// =========================\\n\\t/// ====== Role Constants ===\\n\\t/// =========================\\n\\n\\tfunction PROPOSER_ROLE() external view returns (bytes32);\\n\\n\\tfunction EXECUTOR_ROLE() external view returns (bytes32);\\n\\n\\tfunction DEFAULT_ADMIN_ROLE() external view returns (bytes32);\\n\\n\\t/// =========================\\n\\t/// ====== Initializer ======\\n\\t/// =========================\\n\\n\\t/// @notice Initializes the TimelockController\\n\\t/// @param _minDelay How long we have to wait to execute a proposal after it is queued\\n\\t/// @param _proposers Addresses allowed to propose\\n\\t/// @param _executors Addresses allowed to execute\\n\\t/// @param _admin Address allowed to manage roles\\n\\tfunction initialize(\\n\\t\\tuint256 _minDelay,\\n\\t\\taddress[] memory _proposers,\\n\\t\\taddress[] memory _executors,\\n\\t\\taddress _admin\\n\\t) external;\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\tfunction grantRole(bytes32 role, address account) external;\\n\\n\\tfunction renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0xdb213263d11896dbabd52d74439e6a966aa02998983190ea3f94c7542ab9ca3b\",\"license\":\"MIT\"},\"contracts/core/interfaces/IZKDAO.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IGovernor} from './IGovernor.sol';\\nimport {IGovernorToken} from './IGovernorToken.sol';\\nimport {ITimeLock} from './ITimeLock.sol';\\nimport {IVerifier} from '../Verifier.sol';\\n\\ninterface IZKDAO {\\n\\t/// ======================\\n\\t/// ======= Structs ======\\n\\t/// ======================\\n\\n\\tstruct GovernorTokenParams {\\n\\t\\tstring name;\\n\\t\\tstring symbol;\\n\\t}\\n\\n\\tstruct GovernorParams {\\n\\t\\tstring name;\\n\\t\\tstring description;\\n\\t\\tstring logo;\\n\\t\\tuint48 votingDelay;\\n\\t\\tuint32 votingPeriod;\\n\\t\\tuint256 proposalThreshold;\\n\\t\\tuint256 quorumFraction;\\n\\t}\\n\\n\\tstruct DAO {\\n\\t\\tIGovernorToken token;\\n\\t\\tITimeLock timelock;\\n\\t\\tIGovernor governor;\\n\\t\\taddress deployer;\\n\\t}\\n\\n\\t/// ======================\\n\\t/// ======= Events =======\\n\\t/// ======================\\n\\n\\tevent DaoCreated(\\n\\t\\tuint256 indexed id,\\n\\t\\taddress indexed deployer,\\n\\t\\taddress token,\\n\\t\\taddress timelock,\\n\\t\\taddress governor\\n\\t);\\n\\n\\tevent PaidForDaoCreation(\\n\\t\\tGovernorTokenParams tokenParams,\\n\\t\\tuint256 minDelay,\\n\\t\\tGovernorParams governorParams,\\n\\t\\taddress[] to,\\n\\t\\tuint256[] amounts,\\n\\t\\tuint256 value\\n\\t);\\n\\n\\t/// ==========================\\n\\t/// ===== View Functions =====\\n\\t/// ==========================\\n\\n\\t/**\\n\\t * @notice Get DAO information by ID\\n\\t * @param id DAO identifier\\n\\t * @return dao DAO struct containing token, timelock, governor, and deployer\\n\\t */\\n\\tfunction getDao(uint256 id) external view returns (DAO memory dao);\\n\\n\\t/**\\n\\t * @notice Get all implementation contract addresses\\n\\t * @return governorToken Governor token implementation address\\n\\t * @return timelock Timelock implementation address\\n\\t * @return governor Governor implementation address\\n\\t * @return verifier ZK verifier implementation address\\n\\t */\\n\\tfunction getImplementations()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\taddress governorToken,\\n\\t\\t\\taddress timelock,\\n\\t\\t\\taddress governor,\\n\\t\\t\\taddress verifier\\n\\t\\t);\\n\\n\\t/**\\n\\t * @notice Get user's current nonce for deterministic address generation\\n\\t * @param account User address\\n\\t * @return Current nonce value\\n\\t */\\n\\tfunction getNonce(address account) external view returns (uint256);\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\t/**\\n\\t * @notice Create a new DAO with governance token, timelock, and governor\\n\\t * @param _tokenParams Parameters for the governance token\\n\\t * @param _minDelay Minimum delay for timelock operations (in seconds)\\n\\t * @param _governorParams Parameters for the governor contract\\n\\t * @param _to Array of addresses to receive initial token allocation\\n\\t * @param _amounts Array of token amounts corresponding to _to addresses\\n\\t * @dev Arrays _to and _amounts must have the same length\\n\\t * @dev Emits DaoCreated event upon successful creation\\n\\t */\\n\\tfunction createDao(\\n\\t\\tGovernorTokenParams calldata _tokenParams,\\n\\t\\tuint256 _minDelay,\\n\\t\\tGovernorParams calldata _governorParams,\\n\\t\\taddress[] calldata _to,\\n\\t\\tuint256[] calldata _amounts\\n\\t) external payable;\\n\\n\\tfunction payForDaoCreation(\\n\\t\\tGovernorTokenParams calldata _tokenParams,\\n\\t\\tuint256 _minDelay,\\n\\t\\tGovernorParams calldata _governorParams,\\n\\t\\taddress[] calldata _to,\\n\\t\\tuint256[] calldata _amounts,\\n\\t\\tuint256 _value\\n\\t) external payable;\\n\\n\\t/**\\n\\t * @notice Queue a proposal for processing (called by Governor contracts)\\n\\t * @param daoId DAO identifier\\n\\t * @param proposalId Proposal identifier within the DAO\\n\\t * @param snapshot Block number snapshot for the proposal\\n\\t * @dev Only callable by registered Governor contracts\\n\\t */\\n\\tfunction queueProposal(\\n\\t\\tuint256 daoId,\\n\\t\\tuint256 proposalId,\\n\\t\\tuint256 snapshot,\\n\\t\\taddress voteToken\\n\\t) external;\\n}\\n\",\"keccak256\":\"0x513a07befc7f2ca05b118ef4fbbdbd81c6c4d71b95188f6947dc76f8ce9668f6\",\"license\":\"MIT\"},\"contracts/core/libraries/Clone.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport '@openzeppelin/contracts/proxy/Clones.sol';\\n\\nlibrary Clone {\\n\\tfunction createClone(\\n\\t\\taddress _contract,\\n\\t\\taddress _deployer,\\n\\t\\tuint256 _nonce\\n\\t) internal returns (address) {\\n\\t\\tbytes32 salt = keccak256(abi.encodePacked(_deployer, _nonce));\\n\\n\\t\\treturn Clones.cloneDeterministic(_contract, salt);\\n\\t}\\n}\\n\",\"keccak256\":\"0x8b0884713c27666b2be4bea1d4ef96c6ab5ce2734eaf4501fcd0d28b4eb7f798\",\"license\":\"MIT\"},\"contracts/core/libraries/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ncontract Errors {\\n\\t/// ======================\\n\\t/// ====== Generic =======\\n\\t/// ======================\\n\\n\\terror INSUFFICIENT_ALLOWANCE();\\n\\terror INSUFFICIENT_FUNDS();\\n\\terror MISMATCH();\\n\\terror UNAUTHORIZED();\\n\\n\\t/// ======================\\n\\t/// ======= ZK DAO =======\\n\\t/// ======================\\n\\n\\terror DAO_NOT_FOUND(uint256 daoId);\\n\\n\\t/// ======================\\n\\t/// ====== Governor ======\\n\\t/// ======================\\n\\n\\terror INVALID_VOTE_TYPE();\\n\\terror INVALID_PROPOSAL_ID();\\n\\terror INVALID_NULLIFIER();\\n\\terror ZK_PROOF_FAILED();\\n\\n\\terror InvalidArrayLength();\\n\\terror UnauthorizedCaller();\\n\\terror DAONotFound(uint256 daoId);\\n\\terror InvalidParameters();\\n}\\n\",\"keccak256\":\"0x107bb430519935ad06aaa51aa1b194227393e5a6ec7ab32434155ca61df999e1\",\"license\":\"MIT\"},\"contracts/core/libraries/Native.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ncontract Native {\\n\\taddress public constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n}\\n\",\"keccak256\":\"0x3d2756eaaa5cac994af1a34bf40645a0f860ebeaae28bfd2c14b66bc9f15dd5b\",\"license\":\"MIT\"},\"contracts/core/libraries/Transfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport 'solady/src/utils/SafeTransferLib.sol';\\nimport {Native} from './Native.sol';\\n\\ncontract Transfer is Native {\\n\\terror AMOUNT_MISMATCH();\\n\\n\\tstruct TransferData {\\n\\t\\taddress from;\\n\\t\\taddress to;\\n\\t\\tuint256 amount;\\n\\t}\\n\\n\\tfunction _transferAmountsFrom(\\n\\t\\taddress _token,\\n\\t\\tTransferData[] memory _transferData\\n\\t) internal virtual returns (bool) {\\n\\t\\tuint256 msgValue = msg.value;\\n\\n\\t\\tfor (uint256 i; i < _transferData.length; ) {\\n\\t\\t\\tTransferData memory transferData = _transferData[i];\\n\\n\\t\\t\\tif (_token == NATIVE) {\\n\\t\\t\\t\\tmsgValue -= transferData.amount;\\n\\t\\t\\t\\tSafeTransferLib.safeTransferETH(transferData.to, transferData.amount);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tSafeTransferLib.safeTransferFrom(\\n\\t\\t\\t\\t\\t_token,\\n\\t\\t\\t\\t\\ttransferData.from,\\n\\t\\t\\t\\t\\ttransferData.to,\\n\\t\\t\\t\\t\\ttransferData.amount\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (msgValue != 0) revert AMOUNT_MISMATCH();\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _transferAmountFrom(\\n\\t\\taddress _token,\\n\\t\\tTransferData memory _transferData\\n\\t) internal virtual returns (bool) {\\n\\t\\tuint256 amount = _transferData.amount;\\n\\t\\tif (_token == NATIVE) {\\n\\t\\t\\tif (msg.value < amount) revert AMOUNT_MISMATCH();\\n\\n\\t\\t\\tSafeTransferLib.safeTransferETH(_transferData.to, amount);\\n\\t\\t} else {\\n\\t\\t\\tSafeTransferLib.safeTransferFrom(\\n\\t\\t\\t\\t_token,\\n\\t\\t\\t\\t_transferData.from,\\n\\t\\t\\t\\t_transferData.to,\\n\\t\\t\\t\\tamount\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _transferAmount(\\n\\t\\taddress _token,\\n\\t\\taddress _to,\\n\\t\\tuint256 _amount\\n\\t) internal virtual {\\n\\t\\tif (_token == NATIVE) {\\n\\t\\t\\tSafeTransferLib.safeTransferETH(_to, _amount);\\n\\t\\t} else {\\n\\t\\t\\tSafeTransferLib.safeTransfer(_token, _to, _amount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _getBalance(\\n\\t\\taddress _token,\\n\\t\\taddress _account\\n\\t) internal view returns (uint256) {\\n\\t\\tif (_token == NATIVE) {\\n\\t\\t\\treturn payable(_account).balance;\\n\\t\\t} else {\\n\\t\\t\\treturn SafeTransferLib.balanceOf(_token, _account);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x2dd02367fe4dc157a15b72534d364463d64596ccfba3610a9bda38862550bf55\",\"license\":\"MIT\"},\"contracts/core/mocks/MockConsumer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IGovernor} from '../interfaces/IGovernor.sol';\\n\\n/**\\n * @title MockConsumer\\n * @notice Mock implementation of Consumer contract for local testing\\n * @dev Simulates Chainlink Functions behavior without external dependencies\\n */\\ncontract MockConsumer {\\n\\tstruct Proposal {\\n\\t\\tIGovernor dao;\\n\\t\\tuint256 daoId;\\n\\t\\tuint256 proposalId;\\n\\t\\tuint256 snapshot;\\n\\t\\taddress voteToken;\\n\\t\\tbool queued;\\n\\t\\tbool executed;\\n\\t}\\n\\n\\tstruct SendRequestParams {\\n\\t\\tstring source; // JavaScript source code to execute\\n\\t\\tbytes encryptedSecretsUrls; // Encrypted URLs where to fetch user secrets\\n\\t\\tuint8 donHostedSecretsSlotID; // Don hosted secrets slot ID\\n\\t\\tuint64 donHostedSecretsVersion; // Don hosted secrets version\\n\\t\\tstring[] args; // List of arguments accessible from within the source code\\n\\t\\tbytes[] bytesArgs; // Array of bytes arguments, represented as hex strings\\n\\t\\tuint64 subscriptionId; // Billing ID\\n\\t}\\n\\n\\t/// ======================\\n\\t/// ======= Errors =======\\n\\t/// ======================\\n\\n\\terror UnexpectedRequestID(bytes32 requestId);\\n\\n\\t/// =========================\\n\\t/// === Storage Variables ===\\n\\t/// =========================\\n\\n\\tbytes32 public s_lastRequestId;\\n\\tbytes public s_lastResponse;\\n\\tbytes public s_lastError;\\n\\n\\tProposal[] internal queue;\\n\\n\\taddress public owner;\\n\\tuint256 private requestCounter;\\n\\n\\t// daoId => proposalId => Proposal\\n\\tmapping(IGovernor => mapping(uint256 => Proposal)) internal proposals;\\n\\tmapping(bytes32 => Proposal[]) private pendingProposals;\\n\\n\\t// Mock storage for simulating responses\\n\\tmapping(bytes32 => bytes) private mockResponses;\\n\\tmapping(bytes32 => bytes) private mockErrors;\\n\\tmapping(bytes32 => bool) private pendingRequests;\\n\\n\\t/// ======================\\n\\t/// ======= Events =======\\n\\t/// ======================\\n\\n\\tevent Response(bytes32 indexed requestId, bytes response, bytes err);\\n\\tevent RequestSent(bytes32 indexed requestId, string source, string[] args);\\n\\n\\t/// ========================\\n\\t/// ======= Modifiers ======\\n\\t/// ========================\\n\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(msg.sender == owner, 'Not the owner');\\n\\t\\t_;\\n\\t}\\n\\n\\t/// =========================\\n\\t/// ====== Constructor ======\\n\\t/// =========================\\n\\n\\tconstructor() {\\n\\t\\towner = msg.sender;\\n\\t}\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\tfunction sendRequest(\\n\\t\\tSendRequestParams memory params,\\n\\t\\tProposal[] memory _proposals\\n\\t) internal onlyOwner returns (bytes32 requestId) {\\n\\t\\t// Generate mock request ID\\n\\t\\trequestId = keccak256(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\tblock.timestamp,\\n\\t\\t\\t\\tblock.prevrandao,\\n\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\trequestCounter++\\n\\t\\t\\t)\\n\\t\\t);\\n\\n\\t\\tfor (uint256 i = 0; i < _proposals.length; i++) {\\n\\t\\t\\tpendingProposals[requestId].push(_proposals[i]);\\n\\n\\t\\t\\tfor (uint256 j = 0; j < queue.length; j++) {\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\tqueue[j].dao == _proposals[i].dao &&\\n\\t\\t\\t\\t\\tqueue[j].proposalId == _proposals[i].proposalId\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tqueue[j] = queue[queue.length - 1];\\n\\t\\t\\t\\t\\tqueue.pop();\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ts_lastRequestId = requestId;\\n\\t\\tpendingRequests[requestId] = true;\\n\\n\\t\\temit RequestSent(requestId, params.source, params.args);\\n\\n\\t\\treturn requestId;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Send a pre-encoded CBOR request (mocked)\\n\\t */\\n\\tfunction sendRequestCBOR(\\n\\t\\tbytes memory request,\\n\\t\\tuint64 subscriptionId,\\n\\t\\tuint32 gasLimit,\\n\\t\\tbytes32 donID\\n\\t) external onlyOwner returns (bytes32 requestId) {\\n\\t\\t// Generate mock request ID\\n\\t\\trequestId = keccak256(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\tblock.timestamp,\\n\\t\\t\\t\\tblock.prevrandao,\\n\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\trequestCounter++\\n\\t\\t\\t)\\n\\t\\t);\\n\\n\\t\\ts_lastRequestId = requestId;\\n\\t\\tpendingRequests[requestId] = true;\\n\\n\\t\\treturn requestId;\\n\\t}\\n\\n\\t/// ================================\\n\\t/// ===== Mock Helper Functions ===\\n\\t/// ================================\\n\\n\\t/**\\n\\t * @notice Mock function to simulate successful response\\n\\t * @param _requestId The request ID to fulfill\\n\\t * @param _cids Merkle root for the proposal\\n\\t */\\n\\tfunction mockFulfillRequest(\\n\\t\\tbytes32 _requestId,\\n\\t\\tstring memory _cids\\n\\t) external {\\n\\t\\trequire(pendingRequests[_requestId], 'Request not pending');\\n\\n\\t\\tbytes memory response = abi.encode(_cids);\\n\\t\\tbytes memory err = '';\\n\\n\\t\\tfulfillRequest(_requestId, response, err);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Mock function to simulate error response\\n\\t * @param requestId The request ID to fulfill with error\\n\\t * @param errorMessage Error message to return\\n\\t */\\n\\tfunction mockFulfillRequestWithError(\\n\\t\\tbytes32 requestId,\\n\\t\\tstring memory errorMessage\\n\\t) external {\\n\\t\\trequire(pendingRequests[requestId], 'Request not pending');\\n\\n\\t\\tbytes memory response = '';\\n\\t\\tbytes memory err = bytes(errorMessage);\\n\\n\\t\\tfulfillRequest(requestId, response, err);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set predefined response for a request (for advanced testing)\\n\\t * @param requestId Request ID\\n\\t * @param response Response data\\n\\t * @param err Error data\\n\\t */\\n\\tfunction setPredefinedResponse(\\n\\t\\tbytes32 requestId,\\n\\t\\tbytes memory response,\\n\\t\\tbytes memory err\\n\\t) external onlyOwner {\\n\\t\\tmockResponses[requestId] = response;\\n\\t\\tmockErrors[requestId] = err;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Auto-fulfill request with predefined response\\n\\t * @param requestId Request ID to auto-fulfill\\n\\t */\\n\\tfunction autoFulfillRequest(bytes32 requestId) external {\\n\\t\\trequire(pendingRequests[requestId], 'Request not pending');\\n\\n\\t\\tbytes memory response = mockResponses[requestId];\\n\\t\\tbytes memory err = mockErrors[requestId];\\n\\n\\t\\tfulfillRequest(requestId, response, err);\\n\\t}\\n\\n\\t/// =========================\\n\\t/// == Internal Functions ===\\n\\t/// =========================\\n\\n\\t/**\\n\\t * @notice Store latest result/error (same as original)\\n\\t * @param requestId The request ID, returned by sendRequest()\\n\\t * @param response Aggregated response from the user code\\n\\t * @param err Aggregated error from the user code or from the execution pipeline\\n\\t */\\n\\tfunction fulfillRequest(\\n\\t\\tbytes32 requestId,\\n\\t\\tbytes memory response,\\n\\t\\tbytes memory err\\n\\t) internal {\\n\\t\\tif (!pendingRequests[requestId]) {\\n\\t\\t\\trevert UnexpectedRequestID(requestId);\\n\\t\\t}\\n\\n\\t\\t// Mark request as completed\\n\\t\\tpendingRequests[requestId] = false;\\n\\n\\t\\ts_lastResponse = response;\\n\\t\\ts_lastError = err;\\n\\n\\t\\tif (response.length > 0) {\\n\\t\\t\\tstring memory concatCIDs = abi.decode(response, (string));\\n\\n\\t\\t\\tstring[] memory cids = splitByPipe(concatCIDs);\\n\\n\\t\\t\\tProposal[] memory lastProposals = pendingProposals[s_lastRequestId];\\n\\n\\t\\t\\tfor (uint256 i = 0; i < lastProposals.length; i++) {\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t!proposals[lastProposals[i].dao][lastProposals[i].proposalId].executed\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tIGovernor(lastProposals[i].dao).setRoot(\\n\\t\\t\\t\\t\\t\\tlastProposals[i].proposalId,\\n\\t\\t\\t\\t\\t\\tcids[i]\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tproposals[lastProposals[i].dao][lastProposals[i].proposalId]\\n\\t\\t\\t\\t\\t\\t.executed = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\temit Response(requestId, s_lastResponse, s_lastError);\\n\\t}\\n\\n\\t/// ==========================\\n\\t/// ===== View Functions =====\\n\\t/// ==========================\\n\\n\\t/**\\n\\t * @notice Check if request is pending\\n\\t */\\n\\tfunction isRequestPending(bytes32 requestId) external view returns (bool) {\\n\\t\\treturn pendingRequests[requestId];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Get request counter for testing\\n\\t */\\n\\tfunction getRequestCounter() external view returns (uint256) {\\n\\t\\treturn requestCounter;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Transfer ownership\\n\\t */\\n\\tfunction transferOwnership(address newOwner) external onlyOwner {\\n\\t\\towner = newOwner;\\n\\t}\\n\\n\\tfunction _handleProposalRoot(\\n\\t\\tProposal memory _proposal,\\n\\t\\tbytes32 root\\n\\t) internal {\\n\\t\\t// IGovernor(_proposal.dao).setRoot(p.proposalId, root);\\n\\t}\\n\\n\\tfunction splitByPipe(\\n\\t\\tstring memory input\\n\\t) public pure returns (string[] memory) {\\n\\t\\tbytes memory strBytes = bytes(input);\\n\\t\\tuint256 count = 1;\\n\\n\\t\\tfor (uint256 i = 0; i < strBytes.length; i++) {\\n\\t\\t\\tif (strBytes[i] == '|') count++;\\n\\t\\t}\\n\\n\\t\\tstring[] memory parts = new string[](count);\\n\\t\\tuint256 lastIndex = 0;\\n\\t\\tuint256 partIndex = 0;\\n\\n\\t\\tfor (uint256 i = 0; i < strBytes.length; i++) {\\n\\t\\t\\tif (strBytes[i] == '|') {\\n\\t\\t\\t\\tbytes memory part = new bytes(i - lastIndex);\\n\\t\\t\\t\\tfor (uint256 j = lastIndex; j < i; j++) {\\n\\t\\t\\t\\t\\tpart[j - lastIndex] = strBytes[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparts[partIndex++] = string(part);\\n\\t\\t\\t\\tlastIndex = i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (lastIndex < strBytes.length) {\\n\\t\\t\\tbytes memory part = new bytes(strBytes.length - lastIndex);\\n\\t\\t\\tfor (uint256 j = lastIndex; j < strBytes.length; j++) {\\n\\t\\t\\t\\tpart[j - lastIndex] = strBytes[j];\\n\\t\\t\\t}\\n\\t\\t\\tparts[partIndex] = string(part);\\n\\t\\t}\\n\\n\\t\\treturn parts;\\n\\t}\\n\\n\\tfunction splitRoots(\\n\\t\\tstring memory input\\n\\t) internal pure returns (string[] memory) {\\n\\t\\tbytes memory inputBytes = bytes(input);\\n\\t\\tuint256 count = 1;\\n\\n\\t\\tfor (uint256 i = 0; i < inputBytes.length; i++) {\\n\\t\\t\\tif (inputBytes[i] == 'e') {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring[] memory parts = new string[](count);\\n\\t\\tuint256 lastIndex = 0;\\n\\t\\tuint256 partIndex = 0;\\n\\n\\t\\tfor (uint256 i = 0; i < inputBytes.length; i++) {\\n\\t\\t\\tif (inputBytes[i] == 'e') {\\n\\t\\t\\t\\tbytes memory part = new bytes(i - lastIndex);\\n\\t\\t\\t\\tfor (uint256 j = lastIndex; j < i; j++) {\\n\\t\\t\\t\\t\\tpart[j - lastIndex] = inputBytes[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparts[partIndex++] = string(part);\\n\\t\\t\\t\\tlastIndex = i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (lastIndex < inputBytes.length) {\\n\\t\\t\\tbytes memory part = new bytes(inputBytes.length - lastIndex);\\n\\t\\t\\tfor (uint256 j = lastIndex; j < inputBytes.length; j++) {\\n\\t\\t\\t\\tpart[j - lastIndex] = inputBytes[j];\\n\\t\\t\\t}\\n\\t\\t\\tparts[partIndex] = string(part);\\n\\t\\t}\\n\\n\\t\\treturn parts;\\n\\t}\\n\\n\\tfunction convertStringsToBytes32(\\n\\t\\tstring[] memory input\\n\\t) internal pure returns (bytes32[] memory) {\\n\\t\\tbytes32[] memory result = new bytes32[](input.length);\\n\\n\\t\\tfor (uint256 i = 0; i < input.length; i++) {\\n\\t\\t\\tresult[i] = toBytes32(input[i]);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tfunction toBytes32(\\n\\t\\tstring memory source\\n\\t) internal pure returns (bytes32 result) {\\n\\t\\tbytes memory temp = bytes(source);\\n\\t\\trequire(temp.length == 66 || temp.length == 64, 'Invalid length'); // with or without \\\"0x\\\"\\n\\n\\t\\tuint256 start = (temp[0] == '0' && temp[1] == 'x') ? 2 : 0;\\n\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(add(temp, add(32, start)))\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0xbc77553283de38cf72b56d8206e1e64a32f02704fb74ae29019e44b580332108\",\"license\":\"MIT\"},\"contracts/core/mocks/MockQueueProposalState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IGovernor} from '../interfaces/IGovernor.sol';\\nimport {MockConsumer} from './MockConsumer.sol';\\n\\nimport 'hardhat/console.sol';\\n\\n/**\\n * @title MockQueueProposalState\\n * @notice Mock implementation of QueueProposalState for local testing\\n * @dev Simulates Chainlink Automation behavior without external dependencies\\n */\\ncontract MockQueueProposalState is MockConsumer {\\n\\t/// =========================\\n\\t/// === Storage Variables ===\\n\\t/// =========================\\n\\n\\t// Mock automation variables\\n\\tbool public automationEnabled;\\n\\taddress public automationRegistry;\\n\\tuint256 public lastUpkeepTimestamp;\\n\\tuint256 public upkeepCounter;\\n\\n\\t// Mock control variables\\n\\tbool public forceUpkeepNeeded;\\n\\tuint256 public mockBlockTimestamp;\\n\\n\\t/// ======================\\n\\t/// ======= Events =======\\n\\t/// ======================\\n\\n\\tevent ProposalQueued(\\n\\t\\taddress indexed dao,\\n\\t\\tuint256 indexed daoId,\\n\\t\\tuint256 indexed proposalId,\\n\\t\\tuint256 snapshot,\\n\\t\\taddress voteToken\\n\\t);\\n\\n\\tevent ProposalDequeued(uint256 indexed id, uint256 snapshot);\\n\\tevent UpkeepPerformed(uint256 indexed upkeepId, uint256 proposalsProcessed);\\n\\tevent AutomationToggled(bool enabled);\\n\\n\\t/// =========================\\n\\t/// ====== Constructor ======\\n\\t/// =========================\\n\\n\\tconstructor() {\\n\\t\\tautomationEnabled = true;\\n\\t\\tautomationRegistry = msg.sender;\\n\\t\\tmockBlockTimestamp = block.timestamp;\\n\\t}\\n\\n\\t/// ========================\\n\\t/// ======= Modifiers ======\\n\\t/// ========================\\n\\n\\tmodifier onlyAutomation() {\\n\\t\\trequire(\\n\\t\\t\\tmsg.sender == automationRegistry || msg.sender == address(this),\\n\\t\\t\\t'Only automation registry can call this'\\n\\t\\t);\\n\\t\\t_;\\n\\t}\\n\\n\\t/// ==========================\\n\\t/// ===== View Functions =====\\n\\t/// ==========================\\n\\n\\tfunction checkUpkeep(\\n\\t\\tbytes calldata /* checkData */\\n\\t) external view returns (bool upkeepNeeded, bytes memory performData) {\\n\\t\\tif (forceUpkeepNeeded) {\\n\\t\\t\\treturn (true, abi.encode(queue));\\n\\t\\t}\\n\\n\\t\\tif (!automationEnabled) {\\n\\t\\t\\treturn (false, bytes(''));\\n\\t\\t}\\n\\n\\t\\tuint256 count = 0;\\n\\t\\tuint256 currentTime = mockBlockTimestamp > 0\\n\\t\\t\\t? mockBlockTimestamp\\n\\t\\t\\t: block.timestamp;\\n\\n\\t\\tfor (uint256 i = 0; i < queue.length; i++) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\tqueue[i].snapshot <= currentTime &&\\n\\t\\t\\t\\t!proposals[queue[i].dao][queue[i].proposalId].queued\\n\\t\\t\\t) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (count == 0) {\\n\\t\\t\\treturn (false, bytes(''));\\n\\t\\t}\\n\\n\\t\\tProposal[] memory proposalsToPerform = new Proposal[](count);\\n\\n\\t\\tuint256 index = 0;\\n\\n\\t\\tfor (uint256 i = 0; i < queue.length; i++) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\tqueue[i].snapshot <= currentTime &&\\n\\t\\t\\t\\t!proposals[queue[i].dao][queue[i].proposalId].queued\\n\\t\\t\\t) {\\n\\t\\t\\t\\tproposalsToPerform[index] = queue[i];\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tperformData = abi.encode(proposalsToPerform);\\n\\t\\tupkeepNeeded = count > 0;\\n\\t}\\n\\n\\tfunction getQueueLength() external view returns (uint256) {\\n\\t\\treturn queue.length;\\n\\t}\\n\\n\\tfunction getProposal(\\n\\t\\taddress dao,\\n\\t\\tuint256 proposalId\\n\\t) external view returns (Proposal memory) {\\n\\t\\treturn proposals[IGovernor(dao)][proposalId];\\n\\t}\\n\\n\\tfunction qetQueue() external view returns (Proposal[] memory) {\\n\\t\\treturn queue;\\n\\t}\\n\\n\\tfunction isProposalProcessed(\\n\\t\\taddress dao,\\n\\t\\tuint256 proposalId\\n\\t) external view returns (bool) {\\n\\t\\treturn proposals[IGovernor(dao)][proposalId].queued;\\n\\t}\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\tfunction performUpkeep(bytes calldata performData) external onlyAutomation {\\n\\t\\trequire(automationEnabled, 'Automation is disabled');\\n\\n\\t\\tProposal[] memory proposalsToProcess = abi.decode(\\n\\t\\t\\tperformData,\\n\\t\\t\\t(Proposal[])\\n\\t\\t);\\n\\n\\t\\tstring[] memory args = new string[](proposalsToProcess.length);\\n\\n\\t\\tfor (uint256 i = 0; i < proposalsToProcess.length; i++) {\\n\\t\\t\\tProposal memory p = proposalsToProcess[i];\\n\\t\\t\\tstring memory serialized;\\n\\n\\t\\t\\tif (!proposals[p.dao][p.proposalId].queued) {\\n\\t\\t\\t\\tproposals[p.dao][p.proposalId].queued = true;\\n\\n\\t\\t\\t\\tserialized = string(\\n\\t\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\t'dao=',\\n\\t\\t\\t\\t\\t\\ttoAsciiString(address(p.dao)),\\n\\t\\t\\t\\t\\t\\t';daoId=',\\n\\t\\t\\t\\t\\t\\tuintToString(p.daoId),\\n\\t\\t\\t\\t\\t\\t';proposalId=',\\n\\t\\t\\t\\t\\t\\tuintToString(p.proposalId),\\n\\t\\t\\t\\t\\t\\t';snapshot=',\\n\\t\\t\\t\\t\\t\\tuintToString(p.snapshot),\\n\\t\\t\\t\\t\\t\\t';voteToken=',\\n\\t\\t\\t\\t\\t\\ttoAsciiString(p.voteToken)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\targs[i] = serialized;\\n\\t\\t\\t\\tconsole.log('Serialized proposal:', serialized);\\n\\n\\t\\t\\t\\temit ProposalDequeued(p.proposalId, p.snapshot);\\n\\t\\t\\t}\\n\\n\\t\\t\\tsendRequest(\\n\\t\\t\\t\\tSendRequestParams({\\n\\t\\t\\t\\t\\tsource: 'queueProposal',\\n\\t\\t\\t\\t\\tencryptedSecretsUrls: bytes(''), // No secrets in this mock\\n\\t\\t\\t\\t\\tdonHostedSecretsSlotID: 0, // No DON secrets in this mock\\n\\t\\t\\t\\t\\tdonHostedSecretsVersion: 0, // No DON secrets in this mock\\n\\t\\t\\t\\t\\targs: args,\\n\\t\\t\\t\\t\\tbytesArgs: new bytes[](0), // No bytes args in this mock\\n\\t\\t\\t\\t\\tsubscriptionId: 0 // No subscription in this mock\\n\\t\\t\\t\\t}),\\n\\t\\t\\t\\tproposalsToProcess\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tlastUpkeepTimestamp = block.timestamp;\\n\\t\\tupkeepCounter++;\\n\\n\\t\\temit UpkeepPerformed(upkeepCounter, proposalsToProcess.length);\\n\\t}\\n\\n\\tfunction _queueProposal(\\n\\t\\tuint256 _daoId,\\n\\t\\tuint256 _proposalId,\\n\\t\\tuint256 _snapshot,\\n\\t\\taddress voteToken\\n\\t) internal virtual {\\n\\t\\tqueue.push(\\n\\t\\t\\tProposal({\\n\\t\\t\\t\\tdao: IGovernor(msg.sender),\\n\\t\\t\\t\\tdaoId: _daoId,\\n\\t\\t\\t\\tproposalId: _proposalId,\\n\\t\\t\\t\\tsnapshot: _snapshot,\\n\\t\\t\\t\\tvoteToken: voteToken,\\n\\t\\t\\t\\tqueued: false,\\n\\t\\t\\t\\texecuted: false\\n\\t\\t\\t})\\n\\t\\t);\\n\\n\\t\\temit ProposalQueued(msg.sender, _daoId, _proposalId, _snapshot, voteToken);\\n\\t}\\n\\n\\t/// ================================\\n\\t/// ===== Mock Helper Functions ===\\n\\t/// ================================\\n\\n\\t/**\\n\\t * @notice Toggle automation on/off for testing\\n\\t */\\n\\tfunction toggleAutomation(bool enabled) external {\\n\\t\\tautomationEnabled = enabled;\\n\\t\\temit AutomationToggled(enabled);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set mock block timestamp for testing time-dependent logic\\n\\t */\\n\\tfunction setMockBlockTimestamp(uint256 timestamp) external {\\n\\t\\tmockBlockTimestamp = timestamp;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Advance mock time by specified seconds\\n\\t */\\n\\tfunction advanceTime(uint256 seconds_) external {\\n\\t\\tif (mockBlockTimestamp == 0) {\\n\\t\\t\\tmockBlockTimestamp = block.timestamp;\\n\\t\\t}\\n\\t\\tmockBlockTimestamp += seconds_;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Force upkeep to be needed for testing\\n\\t */\\n\\tfunction setForceUpkeepNeeded(bool force) external {\\n\\t\\tforceUpkeepNeeded = force;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Manually trigger upkeep (simulates Chainlink calling performUpkeep)\\n\\t */\\n\\tfunction manualUpkeep() external returns (uint256 processedCount) {\\n\\t\\t(bool upkeepNeeded, bytes memory performData) = this.checkUpkeep('');\\n\\n\\t\\tif (upkeepNeeded) {\\n\\t\\t\\tthis.performUpkeep(performData);\\n\\t\\t\\tProposal[] memory proposals = abi.decode(performData, (Proposal[]));\\n\\t\\t\\treturn proposals.length;\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Simulate automated upkeep cycle\\n\\t */\\n\\tfunction simulateAutomationCycle()\\n\\t\\texternal\\n\\t\\treturns (bool executed, uint256 processedCount)\\n\\t{\\n\\t\\tif (!automationEnabled) {\\n\\t\\t\\treturn (false, 0);\\n\\t\\t}\\n\\n\\t\\t(bool upkeepNeeded, bytes memory performData) = this.checkUpkeep('');\\n\\n\\t\\tif (upkeepNeeded) {\\n\\t\\t\\tthis.performUpkeep(performData);\\n\\t\\t\\tProposal[] memory proposals = abi.decode(performData, (Proposal[]));\\n\\t\\t\\treturn (true, proposals.length);\\n\\t\\t}\\n\\n\\t\\treturn (false, 0);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Clear all processed proposals (for testing)\\n\\t */\\n\\tfunction clearProcessedProposals() external {\\n\\t\\tfor (uint256 i = 0; i < queue.length; i++) {\\n\\t\\t\\tproposals[queue[i].dao][queue[i].proposalId].queued = false;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Clear the entire queue (for testing)\\n\\t */\\n\\tfunction clearQueue() external {\\n\\t\\tdelete queue;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Remove processed proposals from queue\\n\\t */\\n\\tfunction cleanupQueue() external {\\n\\t\\tuint256 activeCount = 0;\\n\\n\\t\\t// Count active proposals\\n\\t\\tfor (uint256 i = 0; i < queue.length; i++) {\\n\\t\\t\\tif (!proposals[queue[i].dao][queue[i].proposalId].queued) {\\n\\t\\t\\t\\tactiveCount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Create new array with only active proposals\\n\\t\\tProposal[] memory activeProposals = new Proposal[](activeCount);\\n\\t\\tuint256 index = 0;\\n\\n\\t\\tfor (uint256 i = 0; i < queue.length; i++) {\\n\\t\\t\\tif (!proposals[queue[i].dao][queue[i].proposalId].queued) {\\n\\t\\t\\t\\tactiveProposals[index] = queue[i];\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Replace queue\\n\\t\\tdelete queue;\\n\\t\\tfor (uint256 i = 0; i < activeProposals.length; i++) {\\n\\t\\t\\tqueue.push(activeProposals[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set automation registry address\\n\\t */\\n\\tfunction setAutomationRegistry(address registry) external {\\n\\t\\tautomationRegistry = registry;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Batch queue multiple proposals for testing\\n\\t */\\n\\tfunction batchQueueProposals(\\n\\t\\taddress[] calldata daos,\\n\\t\\tuint256[] calldata proposalIds,\\n\\t\\tuint256[] calldata snapshots,\\n\\t\\taddress[] calldata voteTokens\\n\\t) external {\\n\\t\\trequire(\\n\\t\\t\\tdaos.length == proposalIds.length &&\\n\\t\\t\\t\\tproposalIds.length == snapshots.length,\\n\\t\\t\\t'Arrays length mismatch'\\n\\t\\t);\\n\\n\\t\\tfor (uint256 i = 0; i < daos.length; i++) {\\n\\t\\t\\tqueue.push(\\n\\t\\t\\t\\tProposal({\\n\\t\\t\\t\\t\\tdao: IGovernor(daos[i]),\\n\\t\\t\\t\\t\\tdaoId: 0, // DAO ID can be set later if needed\\n\\t\\t\\t\\t\\tproposalId: proposalIds[i],\\n\\t\\t\\t\\t\\tsnapshot: snapshots[i],\\n\\t\\t\\t\\t\\tvoteToken: voteTokens[i],\\n\\t\\t\\t\\t\\tqueued: false,\\n\\t\\t\\t\\t\\texecuted: false\\n\\t\\t\\t\\t})\\n\\t\\t\\t);\\n\\t\\t\\temit ProposalQueued(\\n\\t\\t\\t\\tdaos[i],\\n\\t\\t\\t\\t0, // DAO ID can be set later if needed\\n\\t\\t\\t\\tproposalIds[i],\\n\\t\\t\\t\\tsnapshots[i],\\n\\t\\t\\t\\tvoteTokens[i]\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Get automation stats for monitoring\\n\\t */\\n\\tfunction getAutomationStats()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tbool enabled,\\n\\t\\t\\tuint256 queueLength,\\n\\t\\t\\tuint256 pendingCount,\\n\\t\\t\\tuint256 processedCount,\\n\\t\\t\\tuint256 lastUpkeep,\\n\\t\\t\\tuint256 totalUpkeeps\\n\\t\\t)\\n\\t{\\n\\t\\tuint256 pending = 0;\\n\\t\\tuint256 processed = 0;\\n\\t\\tuint256 currentTime = mockBlockTimestamp > 0\\n\\t\\t\\t? mockBlockTimestamp\\n\\t\\t\\t: block.timestamp;\\n\\n\\t\\tfor (uint256 i = 0; i < queue.length; i++) {\\n\\t\\t\\tif (queue[i].snapshot <= currentTime) {\\n\\t\\t\\t\\tif (proposals[queue[i].dao][queue[i].proposalId].queued) {\\n\\t\\t\\t\\t\\tprocessed++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpending++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (\\n\\t\\t\\tautomationEnabled,\\n\\t\\t\\tqueue.length,\\n\\t\\t\\tpending,\\n\\t\\t\\tprocessed,\\n\\t\\t\\tlastUpkeepTimestamp,\\n\\t\\t\\tupkeepCounter\\n\\t\\t);\\n\\t}\\n\\n\\tfunction uintToString(uint256 v) internal pure returns (string memory) {\\n\\t\\tif (v == 0) return '0';\\n\\t\\tuint256 digits;\\n\\t\\tuint256 temp = v;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\t\\twhile (v != 0) {\\n\\t\\t\\tdigits -= 1;\\n\\t\\t\\tbuffer[digits] = bytes1(uint8(48 + uint256(v % 10)));\\n\\t\\t\\tv /= 10;\\n\\t\\t}\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\tfunction toAsciiString(address x) internal pure returns (string memory) {\\n\\t\\tbytes memory s = new bytes(42);\\n\\t\\ts[0] = '0';\\n\\t\\ts[1] = 'x';\\n\\t\\tfor (uint256 i = 0; i < 20; i++) {\\n\\t\\t\\tbytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n\\t\\t\\tbytes1 hi = bytes1(uint8(b) / 16);\\n\\t\\t\\tbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n\\t\\t\\ts[2 * i + 2] = char(hi);\\n\\t\\t\\ts[2 * i + 3] = char(lo);\\n\\t\\t}\\n\\t\\treturn string(s);\\n\\t}\\n\\n\\tfunction char(bytes1 b) internal pure returns (bytes1 c) {\\n\\t\\tif (uint8(b) < 10) return bytes1(uint8(b) + 48);\\n\\t\\telse return bytes1(uint8(b) + 87);\\n\\t}\\n}\\n\",\"keccak256\":\"0xd94891a2ea999e6335f0e2b854a422768c9c5a49a9b62ebc8fa0c6b546cc15d0\",\"license\":\"MIT\"},\"contracts/core/mocks/MockZKDAO.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {ERC20} from 'solady/src/tokens/ERC20.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IVotes} from '@openzeppelin/contracts/governance/utils/IVotes.sol';\\nimport {TimelockControllerUpgradeable} from '@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol';\\n\\nimport {IZKDAO} from '../interfaces/IZKDAO.sol';\\nimport {IGovernorToken} from '../interfaces/IGovernorToken.sol';\\nimport {ITimeLock} from '../interfaces/ITimeLock.sol';\\nimport {IVerifier} from '../Verifier.sol';\\nimport {IGovernor} from '../interfaces/IGovernor.sol';\\nimport {MockQueueProposalState} from './MockQueueProposalState.sol';\\nimport {Transfer} from '../libraries/Transfer.sol';\\nimport {Errors} from '../libraries/Errors.sol';\\nimport {Clone} from '../libraries/Clone.sol';\\n\\nimport 'hardhat/console.sol';\\n\\ncontract MockZKDAO is IZKDAO, MockQueueProposalState, Transfer, Errors {\\n\\t/// =========================\\n\\t/// === Storage Variables ===\\n\\t/// =========================\\n\\n\\tmapping(address => uint256) private nonces;\\n\\tmapping(uint256 => DAO) private daos;\\n\\tmapping(address => uint256) public daoIds;\\n\\n\\tuint256 public price = 5 ether; // Price in LINK tokens for creating a DAO\\n\\tuint256 public daoCount;\\n\\n\\taddress public factory;\\n\\tIGovernorToken public governorToken;\\n\\tITimeLock public timelock;\\n\\tIVerifier public verifier;\\n\\tIGovernor public governor;\\n\\tIERC20 public linkToken;\\n\\n\\treceive() external payable {}\\n\\n\\t/// =========================\\n\\t/// ====== Constructor ======\\n\\t/// =========================\\n\\n\\tconstructor(\\n\\t\\taddress _governorToken,\\n\\t\\taddress _timelock,\\n\\t\\taddress _governor,\\n\\t\\taddress _verifier,\\n\\t\\taddress _linkAddress,\\n\\t\\taddress _factory\\n\\t) {\\n\\t\\tgovernorToken = IGovernorToken(_governorToken);\\n\\t\\ttimelock = ITimeLock(_timelock);\\n\\t\\tgovernor = IGovernor(_governor);\\n\\t\\tverifier = IVerifier(_verifier);\\n\\t\\tlinkToken = IERC20(_linkAddress);\\n\\t\\tfactory = _factory;\\n\\t}\\n\\n\\t/// =========================\\n\\t/// ======= Modifiers =======\\n\\t/// =========================\\n\\n\\tmodifier onlyFactory() {\\n\\t\\tif (msg.sender != factory) revert UNAUTHORIZED();\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyZkDaos() {\\n\\t\\tuint256 daoId = daoIds[msg.sender];\\n\\t\\tif (daoId == 0) {\\n\\t\\t\\trevert DAO_NOT_FOUND(daoId);\\n\\t\\t}\\n\\n\\t\\tif (daos[daoId].governor != IGovernor(msg.sender)) {\\n\\t\\t\\trevert UNAUTHORIZED();\\n\\t\\t}\\n\\t\\t_;\\n\\t}\\n\\n\\t/// ==========================\\n\\t/// ===== View Functions =====\\n\\t/// ==========================\\n\\n\\tfunction getDao(uint256 id) external view override returns (DAO memory dao) {\\n\\t\\treturn daos[id];\\n\\t}\\n\\n\\tfunction getImplementations()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\toverride\\n\\t\\treturns (\\n\\t\\t\\taddress _governorToken,\\n\\t\\t\\taddress _timelock,\\n\\t\\t\\taddress _governor,\\n\\t\\t\\taddress _verifier\\n\\t\\t)\\n\\t{\\n\\t\\treturn (\\n\\t\\t\\taddress(governorToken),\\n\\t\\t\\taddress(timelock),\\n\\t\\t\\taddress(governor),\\n\\t\\t\\taddress(verifier)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction getNonce(address account) external view override returns (uint256) {\\n\\t\\treturn nonces[account];\\n\\t}\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\tfunction payForDaoCreation(\\n\\t\\tGovernorTokenParams calldata _tokenParams,\\n\\t\\tuint256 _minDelay,\\n\\t\\tGovernorParams calldata _governorParams,\\n\\t\\taddress[] calldata _to,\\n\\t\\tuint256[] calldata _amounts,\\n\\t\\tuint256 _value\\n\\t) external payable {\\n\\t\\tif (linkToken.balanceOf(msg.sender) < price) revert INSUFFICIENT_FUNDS();\\n\\n\\t\\tif (linkToken.allowance(msg.sender, address(this)) < price)\\n\\t\\t\\trevert INSUFFICIENT_ALLOWANCE();\\n\\n\\t\\t_transferAmountFrom(\\n\\t\\t\\taddress(linkToken),\\n\\t\\t\\tTransferData({from: msg.sender, to: address(this), amount: price})\\n\\t\\t);\\n\\n\\t\\temit PaidForDaoCreation(\\n\\t\\t\\t_tokenParams,\\n\\t\\t\\t_minDelay,\\n\\t\\t\\t_governorParams,\\n\\t\\t\\t_to,\\n\\t\\t\\t_amounts,\\n\\t\\t\\t_value\\n\\t\\t);\\n\\t}\\n\\n\\tfunction createDao(\\n\\t\\tGovernorTokenParams calldata _tokenParams,\\n\\t\\tuint256 _minDelay,\\n\\t\\tGovernorParams calldata _governorParams,\\n\\t\\taddress[] calldata _to,\\n\\t\\tuint256[] calldata _amounts\\n\\t) external payable onlyFactory {\\n\\t\\tif (_to.length != _amounts.length) revert MISMATCH();\\n\\n\\t\\tuint256 baseNonce = ++nonces[msg.sender];\\n\\t\\tuint256 id = ++daoCount;\\n\\n\\t\\taddress tokenClone = Clone.createClone(\\n\\t\\t\\taddress(governorToken),\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tbaseNonce\\n\\t\\t);\\n\\n\\t\\taddress timelockClone = Clone.createClone(\\n\\t\\t\\taddress(timelock),\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tbaseNonce + 1\\n\\t\\t);\\n\\n\\t\\taddress governorClone = Clone.createClone(\\n\\t\\t\\taddress(governor),\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tbaseNonce + 2\\n\\t\\t);\\n\\n\\t\\tnonces[msg.sender] = baseNonce + 2;\\n\\n\\t\\t_initializeToken(tokenClone, _tokenParams);\\n\\t\\t_initializeTimelock(timelockClone, _minDelay);\\n\\t\\t_initializeGovernor(\\n\\t\\t\\tgovernorClone,\\n\\t\\t\\tIVotes(tokenClone),\\n\\t\\t\\tTimelockControllerUpgradeable(payable(timelockClone)),\\n\\t\\t\\tverifier,\\n\\t\\t\\t_governorParams,\\n\\t\\t\\tid\\n\\t\\t);\\n\\n\\t\\t// Setup DAO roles\\n\\t\\tITimeLock(timelockClone).grantRole(\\n\\t\\t\\tITimeLock(timelockClone).PROPOSER_ROLE(),\\n\\t\\t\\tgovernorClone\\n\\t\\t);\\n\\t\\tITimeLock(timelockClone).grantRole(\\n\\t\\t\\tITimeLock(timelockClone).EXECUTOR_ROLE(),\\n\\t\\t\\taddress(0)\\n\\t\\t);\\n\\t\\tITimeLock(timelockClone).renounceRole(\\n\\t\\t\\tITimeLock(timelockClone).DEFAULT_ADMIN_ROLE(),\\n\\t\\t\\taddress(this)\\n\\t\\t);\\n\\n\\t\\t// Mint tokens and transfer ownership\\n\\t\\tIGovernorToken(tokenClone).mintBatch(_to, _amounts);\\n\\t\\tIGovernorToken(tokenClone).transferOwnership(timelockClone);\\n\\n\\t\\t// Save DAO data\\n\\t\\tdaoIds[governorClone] = id;\\n\\t\\tdaos[id] = DAO({\\n\\t\\t\\ttoken: IGovernorToken(tokenClone),\\n\\t\\t\\ttimelock: ITimeLock(timelockClone),\\n\\t\\t\\tgovernor: IGovernor(governorClone),\\n\\t\\t\\tdeployer: msg.sender\\n\\t\\t});\\n\\n\\t\\temit DaoCreated(id, msg.sender, tokenClone, timelockClone, governorClone);\\n\\t}\\n\\n\\tfunction queueProposal(\\n\\t\\tuint256 daoId,\\n\\t\\tuint256 proposalId,\\n\\t\\tuint256 snapshot,\\n\\t\\taddress voteToken\\n\\t) external onlyZkDaos {\\n\\t\\t_queueProposal(daoId, proposalId, snapshot, voteToken);\\n\\t}\\n\\n\\t/// =========================\\n\\t/// == Internal Functions ===\\n\\t/// =========================\\n\\n\\tfunction _initializeToken(\\n\\t\\taddress tokenClone,\\n\\t\\tGovernorTokenParams calldata tokenParams\\n\\t) internal {\\n\\t\\tIGovernorToken(tokenClone).initialize(\\n\\t\\t\\ttokenParams.name,\\n\\t\\t\\ttokenParams.symbol,\\n\\t\\t\\taddress(this)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _initializeTimelock(\\n\\t\\taddress timelockClone,\\n\\t\\tuint256 minDelay\\n\\t) internal {\\n\\t\\tITimeLock(timelockClone).initialize(\\n\\t\\t\\tminDelay,\\n\\t\\t\\tnew address[](0),\\n\\t\\t\\tnew address[](0),\\n\\t\\t\\taddress(this)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _initializeGovernor(\\n\\t\\taddress _governorClone,\\n\\t\\tIVotes _token,\\n\\t\\tTimelockControllerUpgradeable _timelock,\\n\\t\\tIVerifier _verifier,\\n\\t\\tGovernorParams calldata governorParams,\\n\\t\\tuint256 id\\n\\t) internal {\\n\\t\\tIGovernor.GovernorInitParams memory memoryParams = IGovernor\\n\\t\\t\\t.GovernorInitParams({\\n\\t\\t\\t\\tname: governorParams.name,\\n\\t\\t\\t\\ttoken: _token,\\n\\t\\t\\t\\ttimelock: _timelock,\\n\\t\\t\\t\\tvotingDelay: governorParams.votingDelay,\\n\\t\\t\\t\\tvotingPeriod: governorParams.votingPeriod,\\n\\t\\t\\t\\tproposalThreshold: governorParams.proposalThreshold,\\n\\t\\t\\t\\tvotesQuorumFraction: governorParams.quorumFraction,\\n\\t\\t\\t\\tid: id,\\n\\t\\t\\t\\tdescription: governorParams.description,\\n\\t\\t\\t\\tlogo: governorParams.logo\\n\\t\\t\\t});\\n\\n\\t\\tIGovernor(_governorClone).initialize(memoryParams, _verifier);\\n\\t}\\n}\\n\",\"keccak256\":\"0x33d8be348723e4403e9e9e7e72f842f7d31a9978627ca4b1e7ecb5b8988bb158\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n}\\n\",\"keccak256\":\"0xf2560b5386574153057104d19a9e68a32ee912cf23c0c8df1fe9a0607f42d543\",\"license\":\"MIT\"},\"solady/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n/// @dev Note:\\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\\n///   minting and transferring zero tokens, as well as self-approvals.\\n///   For performance, this implementation WILL NOT revert for such actions.\\n///   Please add any checks with overrides if desired.\\n/// - The `permit` function uses the ecrecover precompile (0x1).\\n///\\n/// If you are overriding:\\n/// - NEVER violate the ERC20 invariant:\\n///   the total sum of all balances must be equal to `totalSupply()`.\\n/// - Check that the overridden function is actually used in the function you want to\\n///   change the behavior of. Much of the code has been manually inlined for performance.\\nabstract contract ERC20 {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /// @dev The allowance of Permit2 is fixed at infinity.\\n    error Permit2AllowanceIsFixedAtInfinity();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 private constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev `keccak256(\\\"1\\\")`.\\n    /// If you need to use a different version, override `_versionHash`.\\n    bytes32 private constant _DEFAULT_VERSION_HASH =\\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @dev `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.\\n    /// Enabled by default. To disable, override `_givePermit2InfiniteAllowance()`.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the decimals places of the token.\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        if (_givePermit2InfiniteAllowance()) {\\n            if (spender == _PERMIT2) return type(uint256).max;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        // Code duplication is for zero-cost abstraction if possible.\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let from_ := shl(96, from)\\n                if iszero(eq(caller(), _PERMIT2)) {\\n                    // Compute the allowance slot and load its value.\\n                    mstore(0x20, caller())\\n                    mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n                    let allowanceSlot := keccak256(0x0c, 0x34)\\n                    let allowance_ := sload(allowanceSlot)\\n                    // If the allowance is not the maximum uint256 value.\\n                    if not(allowance_) {\\n                        // Revert if the amount to be transferred exceeds the allowance.\\n                        if gt(amount, allowance_) {\\n                            mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        // Subtract and store the updated allowance.\\n                        sstore(allowanceSlot, sub(allowance_, amount))\\n                    }\\n                }\\n                // Compute the balance slot and load its value.\\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\\n                let fromBalance := sload(fromBalanceSlot)\\n                // Revert if insufficient balance.\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated balance.\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                // Compute the balance slot of `to`.\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x20)\\n                // Add and store the updated balance of `to`.\\n                // Will not overflow because the sum of all user balances\\n                // cannot exceed the maximum uint256 value.\\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n                // Emit the {Transfer} event.\\n                mstore(0x20, amount)\\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let from_ := shl(96, from)\\n                // Compute the allowance slot and load its value.\\n                mstore(0x20, caller())\\n                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n                let allowanceSlot := keccak256(0x0c, 0x34)\\n                let allowance_ := sload(allowanceSlot)\\n                // If the allowance is not the maximum uint256 value.\\n                if not(allowance_) {\\n                    // Revert if the amount to be transferred exceeds the allowance.\\n                    if gt(amount, allowance_) {\\n                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    // Subtract and store the updated allowance.\\n                    sstore(allowanceSlot, sub(allowance_, amount))\\n                }\\n                // Compute the balance slot and load its value.\\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\\n                let fromBalance := sload(fromBalanceSlot)\\n                // Revert if insufficient balance.\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated balance.\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                // Compute the balance slot of `to`.\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x20)\\n                // Add and store the updated balance of `to`.\\n                // Will not overflow because the sum of all user balances\\n                // cannot exceed the maximum uint256 value.\\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n                // Emit the {Transfer} event.\\n                mstore(0x20, amount)\\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n            }\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          EIP-2612                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev For more performance, override to return the constant value\\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\\n\\n    /// @dev If you need a different value, override this function.\\n    function _versionHash() internal view virtual returns (bytes32 result) {\\n        result = _DEFAULT_VERSION_HASH;\\n    }\\n\\n    /// @dev For inheriting contracts to increment the nonce.\\n    function _incrementNonce(address owner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            sstore(nonceSlot, add(1, sload(nonceSlot)))\\n        }\\n    }\\n\\n    /// @dev Returns the current nonce for `owner`.\\n    /// This value is used to compute the signature for EIP-2612 permit.\\n    function nonces(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\\n    /// authorized by a signed approval by `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && value != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        bytes32 versionHash = _versionHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Revert if the block timestamp is greater than `deadline`.\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            // Clean the upper 96 bits.\\n            owner := shr(96, shl(96, owner))\\n            spender := shr(96, shl(96, spender))\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            let nonceValue := sload(nonceSlot)\\n            // Prepare the domain separator.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            mstore(0x2e, keccak256(m, 0xa0))\\n            // Prepare the struct hash.\\n            mstore(m, _PERMIT_TYPEHASH)\\n            mstore(add(m, 0x20), owner)\\n            mstore(add(m, 0x40), spender)\\n            mstore(add(m, 0x60), value)\\n            mstore(add(m, 0x80), nonceValue)\\n            mstore(add(m, 0xa0), deadline)\\n            mstore(0x4e, keccak256(m, 0xc0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0x00, keccak256(0x2c, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            let t := staticcall(gas(), 1, 0x00, 0x80, 0x20, 0x20)\\n            // If the ecrecover fails, the returndatasize will be 0x00,\\n            // `owner` will be checked if it equals the hash at 0x00,\\n            // which evaluates to false (i.e. 0), and we will revert.\\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\\n            // `owner` will be compared against the returned address at 0x20.\\n            if iszero(eq(mload(returndatasize()), owner)) {\\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Increment and store the updated nonce.\\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\\n            // Compute the allowance slot and store the value.\\n            // The `owner` is already at slot 0x20.\\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\\n            sstore(keccak256(0x2c, 0x34), value)\\n            // Emit the {Approval} event.\\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        bytes32 versionHash = _versionHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if not(allowance_) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          PERMIT2                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns whether to fix the Permit2 contract's allowance at infinity.\\n    ///\\n    /// This value should be kept constant after contract initialization,\\n    /// or else the actual allowance values may not match with the {Approval} events.\\n    /// For best performance, return a compile-time constant for zero-cost abstraction.\\n    function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x19826a737039994947e9971d996e80c658f3c380705e30e7d1b5c40d35f454ac\",\"license\":\"MIT\"},\"solady/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\nlibrary SafeTransferLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The ERC20 `totalSupply` query has failed.\\n    error TotalSupplyQueryFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /// @dev The Permit2 approve operation has failed.\\n    error Permit2ApproveFailed();\\n\\n    /// @dev The Permit2 lockdown operation has failed.\\n    error Permit2LockdownFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x34, 0) // Store 0 for the `amount`.\\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                    mstore(0x34, amount) // Store back the original `amount`.\\n                    // Retry the approval, reverting upon failure.\\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    if iszero(and(eq(mload(0x00), 1), success)) {\\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                    }\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Performs a `token.balanceOf(account)` check.\\n    /// `implemented` denotes whether the `token` does not implement `balanceOf`.\\n    /// `amount` is zero if the `token` does not implement `balanceOf`.\\n    function checkBalanceOf(address token, address account)\\n        internal\\n        view\\n        returns (bool implemented, uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            implemented :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                )\\n            amount := mul(mload(0x20), implemented)\\n        }\\n    }\\n\\n    /// @dev Returns the total supply of the `token`.\\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\\n    function totalSupply(address token) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(\\n                and(\\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(\\n                        add(m, 0x94),\\n                        lt(iszero(amount), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    )\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `amount != 0` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero( // Revert if token does not have code, or if the call fails.\\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Approves `spender` to spend `amount` of `token` for `address(this)`.\\n    function permit2Approve(address token, address spender, uint160 amount, uint48 expiration)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let addressMask := shr(96, not(0))\\n            let m := mload(0x40)\\n            mstore(m, 0x87517c45) // `approve(address,address,uint160,uint48)`.\\n            mstore(add(m, 0x20), and(addressMask, token))\\n            mstore(add(m, 0x40), and(addressMask, spender))\\n            mstore(add(m, 0x60), and(addressMask, amount))\\n            mstore(add(m, 0x80), and(0xffffffffffff, expiration))\\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\\n                mstore(0x00, 0x324f14ae) // `Permit2ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Revokes an approval for `token` and `spender` for `address(this)`.\\n    function permit2Lockdown(address token, address spender) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0xcc53287f) // `Permit2.lockdown`.\\n            mstore(add(m, 0x20), 0x20) // Offset of the `approvals`.\\n            mstore(add(m, 0x40), 1) // `approvals.length`.\\n            mstore(add(m, 0x60), shr(96, shl(96, token)))\\n            mstore(add(m, 0x80), shr(96, shl(96, spender)))\\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\\n                mstore(0x00, 0x96b3de23) // `Permit2LockdownFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x960d5b7ca568a090c4a7785ddfd88f6ce135ced94f5c79c34e5519a71772a817\",\"license\":\"MIT\"}},\"version\":1}",
	"bytecode": "0x6080604052674563918244f4000060135534801561001c57600080fd5b50604051615d7b380380615d7b83398101604081905261003b916100f6565b60048054336001600160a01b03199182168117909255600b80546001600160a81b0319166101009093029290921760011790915542600f556016805482166001600160a01b03988916179055601780548216968816969096179095556019805486169487169490941790935560188054851692861692909217909155601a8054841691851691909117905560158054909216921691909117905561016a565b80516001600160a01b03811681146100f157600080fd5b919050565b60008060008060008060c0878903121561010f57600080fd5b610118876100da565b9550610126602088016100da565b9450610134604088016100da565b9350610142606088016100da565b9250610150608088016100da565b915061015e60a088016100da565b90509295509295509295565b615c02806101796000396000f3fe60806040526004361061034e5760003560e01c8063a035b1fe116101bb578063c848ebde116100f7578063d462eaa411610095578063e8c016e61161006f578063e8c016e614610b8f578063f22cb87414610baf578063f2fde38b14610bc4578063f96ec28f14610be457600080fd5b8063d462eaa414610b40578063d966a59414610b60578063d9c39ba414610b7a57600080fd5b8063d01cf419116100d1578063d01cf41914610ac7578063d1e93d1414610add578063d2d16f3014610b0d578063d33219b414610b2057600080fd5b8063c848ebde1461098c578063cec9cf98146109ac578063cfa38da7146109d957600080fd5b8063af38187a11610164578063b404a5841161013e578063b404a58414610922578063b67be84214610942578063b8f7700514610957578063c45a01551461096c57600080fd5b8063af38187a146108d2578063b04dfe60146108f2578063b1e217491461090c57600080fd5b8063a2785f0b11610195578063a2785f0b14610879578063a3d3c0d21461088e578063ab37b0ad146108a457600080fd5b8063a035b1fe1461074d578063a07b57f614610763578063a0cf0aea1461085157600080fd5b80634b0795a81161028a5780636cd2c43d116102335780638da5cb5b1161020d5780638da5cb5b146106cb5780638fb987eb146106eb5780639681096f14610718578063977caf4f1461073857600080fd5b80636cd2c43d1461065b5780636e04ff0d14610671578063835f93601461069f57600080fd5b80635ff2d2aa116102645780635ff2d2aa1461059e578063615f64fe146105f8578063624cffd41461064557600080fd5b80634b0795a81461054457806357970e93146105595780635dc228a01461057957600080fd5b8063302288e2116102f75780633b257a5d116102d15780633b257a5d146104b45780633df10fa1146104d457806340785b46146104f45780634585e33b1461052457600080fd5b8063302288e21461045f57806334b65e2e1461047f5780633944ea3a1461049257600080fd5b80631a402c94116103285780631a402c94146103db5780632b7ac3f3146103fb5780632d0335ab1461041b57600080fd5b806307e32f0a1461035a5780630c340a241461037c5780630fc7a9b7146103b957600080fd5b3661035557005b600080fd5b34801561036657600080fd5b5061037a6103753660046144a3565b610c28565b005b34801561038857600080fd5b5060195461039c906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156103c557600080fd5b506103ce610c51565b6040516103b091906144bc565b3480156103e757600080fd5b5061037a6103f6366004614645565b610d0e565b34801561040757600080fd5b5060185461039c906001600160a01b031681565b34801561042757600080fd5b506104516104363660046146a1565b6001600160a01b031660009081526010602052604090205490565b6040519081526020016103b0565b34801561046b57600080fd5b5061037a61047a3660046144a3565b610daf565b61037a61048d36600461472d565b610f56565b34801561049e57600080fd5b506104a7611575565b6040516103b09190614853565b3480156104c057600080fd5b5061037a6104cf366004614645565b611603565b3480156104e057600080fd5b5061037a6104ef366004614874565b61167c565b34801561050057600080fd5b5061051461050f366004614891565b6116c3565b60405190151581526020016103b0565b34801561053057600080fd5b5061037a61053f3660046148bd565b6116fb565b34801561055057600080fd5b506104a7611b0f565b34801561056557600080fd5b50601a5461039c906001600160a01b031681565b34801561058557600080fd5b50600b5461039c9061010090046001600160a01b031681565b3480156105aa57600080fd5b5061037a6105b93660046146a1565b600b80546001600160a01b03909216610100027fffffffffffffffffffffff0000000000000000000000000000000000000000ff909216919091179055565b34801561060457600080fd5b50601654601754601954601854604080516001600160a01b0395861681529385166020850152918416918301919091529190911660608201526080016103b0565b34801561065157600080fd5b50610451600c5481565b34801561066757600080fd5b50610451600f5481565b34801561067d57600080fd5b5061069161068c3660046148bd565b611b1c565b6040516103b0929190614931565b3480156106ab57600080fd5b506106b4611ee7565b6040805192151583526020830191909152016103b0565b3480156106d757600080fd5b5060045461039c906001600160a01b031681565b3480156106f757600080fd5b506104516107063660046146a1565b60126020526000908152604090205481565b34801561072457600080fd5b50610451610733366004614960565b612030565b34801561074457600080fd5b50610451612104565b34801561075957600080fd5b5061045160135481565b34801561076f57600080fd5b506107f561077e3660046144a3565b60408051608081018252600080825260208201819052918101829052606081019190915250600090815260116020908152604091829020825160808101845281546001600160a01b039081168252600183015481169382019390935260028201548316938101939093526003015416606082015290565b6040516103b0919060006080820190506001600160a01b0383511682526001600160a01b0360208401511660208301526001600160a01b0360408401511660408301526001600160a01b03606084015116606083015292915050565b34801561085d57600080fd5b5061039c73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee81565b34801561088557600080fd5b50600554610451565b34801561089a57600080fd5b50610451600d5481565b3480156108b057600080fd5b5061037a6108bf366004614874565b600e805460ff1916911515919091179055565b3480156108de57600080fd5b5060165461039c906001600160a01b031681565b3480156108fe57600080fd5b50600e546105149060ff1681565b34801561091857600080fd5b5061045160005481565b34801561092e57600080fd5b5061037a61093d3660046149d5565b61222f565b34801561094e57600080fd5b5061037a6124f2565b34801561096357600080fd5b50600354610451565b34801561097857600080fd5b5060155461039c906001600160a01b031681565b34801561099857600080fd5b5061037a6109a7366004614aac565b6125a2565b3480156109b857600080fd5b506109cc6109c7366004614b1e565b61261d565b6040516103b09190614baf565b3480156109e557600080fd5b50610aba6109f4366004614891565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810191909152506001600160a01b03918216600090815260066020908152604080832093835292815290829020825160e081018452815485168152600182015492810192909252600281015492820192909252600382015460608201526004909101549182166080820152600160a01b820460ff908116151560a0830152600160a81b909204909116151560c082015290565b6040516103b09190614bc2565b348015610ad357600080fd5b5061045160145481565b348015610ae957600080fd5b50610514610af83660046144a3565b6000908152600a602052604090205460ff1690565b61037a610b1b366004614c25565b61297a565b348015610b2c57600080fd5b5060175461039c906001600160a01b031681565b348015610b4c57600080fd5b5061037a610b5b3660046144a3565b600f55565b348015610b6c57600080fd5b50600b546105149060ff1681565b348015610b8657600080fd5b5061037a612b83565b348015610b9b57600080fd5b5061037a610baa366004614d02565b612f13565b348015610bbb57600080fd5b5061037a612fc6565b348015610bd057600080fd5b5061037a610bdf3660046146a1565b612fd4565b348015610bf057600080fd5b50610bf961304d565b6040805196151587526020870195909552938501929092526060840152608083015260a082015260c0016103b0565b600f54600003610c375742600f555b80600f6000828254610c499190614d59565b909155505050565b60606003805480602002602001604051908101604052809291908181526020016000905b82821015610d055760008481526020908190206040805160e0810182526005860290920180546001600160a01b0390811684526001808301548587015260028301549385019390935260038201546060850152600490910154908116608084015260ff600160a01b82048116151560a0850152600160a81b90910416151560c08301529083529092019101610c75565b50505050905090565b6000828152600a602052604090205460ff16610d715760405162461bcd60e51b815260206004820152601360248201527f52657175657374206e6f742070656e64696e670000000000000000000000000060448201526064015b60405180910390fd5b600081604051602001610d849190614853565b60408051601f1981840301815260208301909152600082529150610da9848383613184565b50505050565b6000818152600a602052604090205460ff16610e0d5760405162461bcd60e51b815260206004820152601360248201527f52657175657374206e6f742070656e64696e67000000000000000000000000006044820152606401610d68565b60008181526008602052604081208054610e2690614d6c565b80601f0160208091040260200160405190810160405280929190818152602001828054610e5290614d6c565b8015610e9f5780601f10610e7457610100808354040283529160200191610e9f565b820191906000526020600020905b815481529060010190602001808311610e8257829003601f168201915b505050505090506000600960008481526020019081526020016000208054610ec690614d6c565b80601f0160208091040260200160405190810160405280929190818152602001828054610ef290614d6c565b8015610f3f5780601f10610f1457610100808354040283529160200191610f3f565b820191906000526020600020905b815481529060010190602001808311610f2257829003601f168201915b50505050509050610f51838383613184565b505050565b6015546001600160a01b03163314610f9a576040517f075fd2b100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b828114610fd3576040517f636e39bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b33600090815260106020526040812080548290610fef90614da0565b9190508190559050600060146000815461100890614da0565b918290555060165490915060009061102a906001600160a01b03163385613516565b601754909150600090611051906001600160a01b03163361104c876001614d59565b613516565b601954909150600090611073906001600160a01b03163361104c886002614d59565b9050611080856002614d59565b3360009081526010602052604090205561109a838d61356e565b6110a4828c6135eb565b6018546110c1908290859085906001600160a01b03168e89613648565b816001600160a01b0316632f2ff15d836001600160a01b0316638f61f4f56040518163ffffffff1660e01b8152600401602060405180830381865afa15801561110e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111329190614dba565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815260048101919091526001600160a01b0384166024820152604401600060405180830381600087803b15801561119257600080fd5b505af11580156111a6573d6000803e3d6000fd5b50505050816001600160a01b0316632f2ff15d836001600160a01b03166307bd02656040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121b9190614dba565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b168152600481019190915260006024820152604401600060405180830381600087803b15801561127357600080fd5b505af1158015611287573d6000803e3d6000fd5b50505050816001600160a01b03166336568abe836001600160a01b031663a217fddf6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156112d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112fc9190614dba565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b1681526004810191909152306024820152604401600060405180830381600087803b15801561135357600080fd5b505af1158015611367573d6000803e3d6000fd5b50506040517f7c88e3d90000000000000000000000000000000000000000000000000000000081526001600160a01b0386169250637c88e3d991506113b6908c908c908c908c90600401614e68565b600060405180830381600087803b1580156113d057600080fd5b505af11580156113e4573d6000803e3d6000fd5b50506040517ff2fde38b0000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301528616925063f2fde38b9150602401600060405180830381600087803b15801561144457600080fd5b505af1158015611458573d6000803e3d6000fd5b5050506001600160a01b0380831660008181526012602090815260408083208a90558051608081018252898616815288861681840190815281830195865233606083018181528d87526011909552948390209151825490881673ffffffffffffffffffffffffffffffffffffffff19918216178355905160018301805491891691831691909117905594516002820180549188169187169190911790559151600390920180549290951691909316179092555190915085907f3b785ea6f499a552d583841394f9e27727de143f34ed2585796814f93887d84f9061155f908790879087906001600160a01b0393841681529183166020830152909116604082015260600190565b60405180910390a3505050505050505050505050565b6001805461158290614d6c565b80601f01602080910402602001604051908101604052809291908181526020018280546115ae90614d6c565b80156115fb5780601f106115d0576101008083540402835291602001916115fb565b820191906000526020600020905b8154815290600101906020018083116115de57829003601f168201915b505050505081565b6000828152600a602052604090205460ff166116615760405162461bcd60e51b815260206004820152601360248201527f52657175657374206e6f742070656e64696e67000000000000000000000000006044820152606401610d68565b60408051602081019091526000815281610da9848383613184565b600b805460ff19168215159081179091556040519081527f597db723170e2062ff01c7a921f699b0274807a884be8bdce5f2fcf3d645844b9060200160405180910390a150565b6001600160a01b0382166000908152600660209081526040808320848452909152902060040154600160a01b900460ff165b92915050565b600b5461010090046001600160a01b031633148061171857503330145b61178a5760405162461bcd60e51b815260206004820152602660248201527f4f6e6c79206175746f6d6174696f6e2072656769737472792063616e2063616c60448201527f6c207468697300000000000000000000000000000000000000000000000000006064820152608401610d68565b600b5460ff166117dc5760405162461bcd60e51b815260206004820152601660248201527f4175746f6d6174696f6e2069732064697361626c6564000000000000000000006044820152606401610d68565b60006117ea82840184614ebe565b90506000815167ffffffffffffffff81111561180857611808614554565b60405190808252806020026020018201604052801561183b57816020015b60608152602001906001900390816118265790505b50905060005b8251811015611ab257600083828151811061185e5761185e614fd1565b60209081029190910181015180516001600160a01b031660009081526006835260408082208184015183529093529190912060040154909150606090600160a01b900460ff16611a025781516001600160a01b03166000908152600660209081526040808320818601518452909152902060040180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff16600160a01b17905581516119099061381a565b61191683602001516139fb565b61192384604001516139fb565b61193085606001516139fb565b61193d866080015161381a565b604051602001611951959493929190615003565b60405160208183030381529060405290508084848151811061197557611975614fd1565b60200260200101819052506119bf6040518060400160405280601481526020017f53657269616c697a65642070726f706f73616c3a00000000000000000000000081525082613b20565b81604001517f3e069fb74dcf5fbc07740b0d40d7f7fc48e9c0ca5dc3d19eb34d2e05d74c554383606001516040516119f991815260200190565b60405180910390a25b6040805161012081018252600d60e082019081527f717565756550726f706f73616c00000000000000000000000000000000000000610100830152815281516020808201845260008083528184019290925282840182905260608301829052608083018890528351828152908101909352611aa79260a0830191611a96565b6060815260200190600190039081611a815790505b508152600060209091015286613b97565b505050600101611841565b5042600c55600d8054906000611ac783614da0565b9190505550600d547f9fbc2aeb5bf6200e5499d345acddf1dd462c37becb4673d661250b89ced7ff6a8351604051611b0191815260200190565b60405180910390a250505050565b6002805461158290614d6c565b600e5460009060609060ff1615611b595760016003604051602001611b419190615144565b60405160208183030381529060405291509150611ee0565b600b5460ff16611b7b5750506040805160208101909152600080825290611ee0565b60008080600f5411611b8d5742611b91565b600f545b905060005b600354811015611c74578160038281548110611bb457611bb4614fd1565b90600052602060002090600502016003015411158015611c5957506006600060038381548110611be657611be6614fd1565b600091825260208083206005909202909101546001600160a01b0316835282019290925260400181206003805491929184908110611c2657611c26614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff16155b15611c6c5782611c6881614da0565b9350505b600101611b96565b5081600003611c9a57600060405180602001604052806000815250935093505050611ee0565b60008267ffffffffffffffff811115611cb557611cb5614554565b604051908082528060200260200182016040528015611d1c57816020015b6040805160e08101825260008082526020808301829052928201819052606082018190526080820181905260a0820181905260c08201528252600019909201910181611cd35790505b5090506000805b600354811015611eb2578360038281548110611d4157611d41614fd1565b90600052602060002090600502016003015411158015611de657506006600060038381548110611d7357611d73614fd1565b600091825260208083206005909202909101546001600160a01b0316835282019290925260400181206003805491929184908110611db357611db3614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff16155b15611eaa5760038181548110611dfe57611dfe614fd1565b60009182526020918290206040805160e081018252600590930290910180546001600160a01b0390811684526001820154948401949094526002810154918301919091526003810154606083015260040154918216608082015260ff600160a01b83048116151560a0830152600160a81b909204909116151560c08201528351849084908110611e9057611e90614fd1565b60200260200101819052508180611ea690614da0565b9250505b600101611d23565b5081604051602001611ec491906144bc565b6040516020818303038152906040529450600084119550505050505b9250929050565b600b54600090819060ff16611eff5750600091829150565b6040517f6e04ff0d000000000000000000000000000000000000000000000000000000008152602060048201526000602482018190529081903090636e04ff0d90604401600060405180830381865afa158015611f60573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611f889190810190615212565b915091508115612024576040517f4585e33b0000000000000000000000000000000000000000000000000000000081523090634585e33b90611fce908490600401614853565b600060405180830381600087803b158015611fe857600080fd5b505af1158015611ffc573d6000803e3d6000fd5b50505050600081806020019051810190612016919061526d565b516001969095509350505050565b50600093849350915050565b6004546000906001600160a01b0316331461207d5760405162461bcd60e51b815260206004820152600d60248201526c2737ba103a34329037bbb732b960991b6044820152606401610d68565b60058054429144913391600061209283614da0565b909155506040805160208101959095528401929092526bffffffffffffffffffffffff19606091821b1690830152607482015260940160408051601f1981840301815291815281516020928301206000818155818152600a9093529120805460ff191660011790559050949350505050565b6040517f6e04ff0d0000000000000000000000000000000000000000000000000000000081526020600482015260006024820181905290819081903090636e04ff0d90604401600060405180830381865afa158015612167573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261218f9190810190615212565b915091508115612226576040517f4585e33b0000000000000000000000000000000000000000000000000000000081523090634585e33b906121d5908490600401614853565b600060405180830381600087803b1580156121ef57600080fd5b505af1158015612203573d6000803e3d6000fd5b5050505060008180602001905181019061221d919061526d565b51949350505050565b60009250505090565b868514801561223d57508483145b6122895760405162461bcd60e51b815260206004820152601660248201527f417272617973206c656e677468206d69736d61746368000000000000000000006044820152606401610d68565b60005b878110156124e75760036040518060e001604052808b8b858181106122b3576122b3614fd1565b90506020020160208101906122c891906146a1565b6001600160a01b03168152602001600081526020018989858181106122ef576122ef614fd1565b90506020020135815260200187878581811061230d5761230d614fd1565b90506020020135815260200185858581811061232b5761232b614fd1565b905060200201602081019061234091906146a1565b6001600160a01b039081168252600060208084018290526040938401829052855460018181018855968352918190208551600590930201805492841673ffffffffffffffffffffffffffffffffffffffff19909316929092178255840151948101949094559082015160028401556060820151600384015560808201516004909301805460a084015160c0909401511515600160a81b0260ff60a81b19941515600160a01b0274ffffffffffffffffffffffffffffffffffffffffff199092169590931694909417939093179190911617905586868281811061242557612425614fd1565b9050602002013560008a8a8481811061244057612440614fd1565b905060200201602081019061245591906146a1565b6001600160a01b03167fb65a679ed33acf689f42e48df6479c5b17db675374667f1e11a2f24e3bed897a88888681811061249157612491614fd1565b905060200201358787878181106124aa576124aa614fd1565b90506020020160208101906124bf91906146a1565b604080519283526001600160a01b0390911660208301520160405180910390a460010161228c565b505050505050505050565b60005b60035481101561259f576000600660006003848154811061251857612518614fd1565b600091825260208083206005909202909101546001600160a01b031683528201929092526040018120600380549192918590811061255857612558614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160146101000a81548160ff02191690831515021790555080806001019150506124f5565b50565b6004546001600160a01b031633146125ec5760405162461bcd60e51b815260206004820152600d60248201526c2737ba103a34329037bbb732b960991b6044820152606401610d68565b600083815260086020526040902061260483826153bd565b506000838152600960205260409020610da982826153bd565b606081600160005b82518110156126a35782818151811061264057612640614fd1565b01602001517fff00000000000000000000000000000000000000000000000000000000000000167f7c000000000000000000000000000000000000000000000000000000000000000361269b578161269781614da0565b9250505b600101612625565b5060008167ffffffffffffffff8111156126bf576126bf614554565b6040519080825280602002602001820160405280156126f257816020015b60608152602001906001900390816126dd5790505b50905060008060005b85518110156128725785818151811061271657612716614fd1565b01602001517fff00000000000000000000000000000000000000000000000000000000000000167f7c000000000000000000000000000000000000000000000000000000000000000361286a57600061276f848361547c565b67ffffffffffffffff81111561278757612787614554565b6040519080825280601f01601f1916602001820160405280156127b1576020820181803683370190505b509050835b82811015612831578781815181106127d0576127d0614fd1565b01602001517fff000000000000000000000000000000000000000000000000000000000000001682612802878461547c565b8151811061281257612812614fd1565b60200101906001600160f81b031916908160001a9053506001016127b6565b5080858461283e81614da0565b95508151811061285057612850614fd1565b6020908102919091010152612866826001614d59565b9350505b6001016126fb565b50845182101561296f57600082865161288b919061547c565b67ffffffffffffffff8111156128a3576128a3614554565b6040519080825280601f01601f1916602001820160405280156128cd576020820181803683370190505b509050825b865181101561294e578681815181106128ed576128ed614fd1565b01602001517fff00000000000000000000000000000000000000000000000000000000000000168261291f868461547c565b8151811061292f5761292f614fd1565b60200101906001600160f81b031916908160001a9053506001016128d2565b508084838151811061296257612962614fd1565b6020026020010181905250505b509095945050505050565b601354601a546040517f70a082310000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03909116906370a0823190602401602060405180830381865afa1580156129de573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a029190614dba565b1015612a3a576040517fe793143800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601354601a546040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523360048201523060248201526001600160a01b039091169063dd62ed3e90604401602060405180830381865afa158015612aa4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ac89190614dba565b1015612b00576040517f0fd3919300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601a546040805160608101825233815230602082015260135491810191909152612b33916001600160a01b031690613ff1565b507f8e89a238ee2d1df84f7e9b3f32630993ecc9e38a775b1a9a7a28bcb158660da08888888888888888604051612b71989796959493929190615516565b60405180910390a15050505050505050565b6000805b600354811015612c33576006600060038381548110612ba857612ba8614fd1565b600091825260208083206005909202909101546001600160a01b0316835282019290925260400181206003805491929184908110612be857612be8614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff16612c2b5781612c2781614da0565b9250505b600101612b87565b5060008167ffffffffffffffff811115612c4f57612c4f614554565b604051908082528060200260200182016040528015612cb657816020015b6040805160e08101825260008082526020808301829052928201819052606082018190526080820181905260a0820181905260c08201528252600019909201910181612c6d5790505b5090506000805b600354811015612e1a576006600060038381548110612cde57612cde614fd1565b600091825260208083206005909202909101546001600160a01b0316835282019290925260400181206003805491929184908110612d1e57612d1e614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff16612e125760038181548110612d6657612d66614fd1565b60009182526020918290206040805160e081018252600590930290910180546001600160a01b0390811684526001820154948401949094526002810154918301919091526003810154606083015260040154918216608082015260ff600160a01b83048116151560a0830152600160a81b909204909116151560c08201528351849084908110612df857612df8614fd1565b60200260200101819052508180612e0e90614da0565b9250505b600101612cbd565b50612e2760036000614418565b60005b8251811015610da9576003838281518110612e4757612e47614fd1565b602090810291909101810151825460018181018555600094855293839020825160059092020180546001600160a01b0392831673ffffffffffffffffffffffffffffffffffffffff199091161781559282015183850155604082015160028401556060820151600384015560808201516004909301805460a084015160c0909401511515600160a81b0260ff60a81b19941515600160a01b0274ffffffffffffffffffffffffffffffffffffffffff199092169590931694909417939093179190911617905501612e2a565b3360009081526012602052604081205490819003612f60576040517f442d09d900000000000000000000000000000000000000000000000000000000815260048101829052602401610d68565b6000818152601160205260409020600201546001600160a01b03163314612fb3576040517f075fd2b100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612fbf85858585614094565b5050505050565b612fd260036000614418565b565b6004546001600160a01b0316331461301e5760405162461bcd60e51b815260206004820152600d60248201526c2737ba103a34329037bbb732b960991b6044820152606401610d68565b6004805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b600080600080600080600080600080600f541161306a574261306e565b600f545b905060005b60035481101561315d57816003828154811061309157613091614fd1565b906000526020600020906005020160030154116131555760066000600383815481106130bf576130bf614fd1565b600091825260208083206005909202909101546001600160a01b03168352820192909252604001812060038054919291849081106130ff576130ff614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff1615613147578261313f81614da0565b935050613155565b8361315181614da0565b9450505b600101613073565b5050600b54600354600c54600d5460ff9093169b919a509398509196509194509092509050565b6000838152600a602052604090205460ff166131cf576040517fd068bf5b00000000000000000000000000000000000000000000000000000000815260048101849052602401610d68565b6000838152600a60205260409020805460ff1916905560016131f183826153bd565b5060026131fe82826153bd565b508151156134d55760008280602001905181019061321c919061567d565b905060006132298261261d565b905060006007600080548152602001908152602001600020805480602002602001604051908101604052809291908181526020016000905b828210156132f15760008481526020908190206040805160e0810182526005860290920180546001600160a01b0390811684526001808301548587015260028301549385019390935260038201546060850152600490910154908116608084015260ff600160a01b82048116151560a0850152600160a81b90910416151560c08301529083529092019101613261565b50505050905060005b81518110156134d0576006600083838151811061331957613319614fd1565b6020026020010151600001516001600160a01b03166001600160a01b03168152602001908152602001600020600083838151811061335957613359614fd1565b602002602001015160400151815260200190815260200160002060040160159054906101000a900460ff166134c85781818151811061339a5761339a614fd1565b6020026020010151600001516001600160a01b0316633216e1f68383815181106133c6576133c6614fd1565b6020026020010151604001518584815181106133e4576133e4614fd1565b60200260200101516040518363ffffffff1660e01b81526004016134099291906156c6565b600060405180830381600087803b15801561342357600080fd5b505af1158015613437573d6000803e3d6000fd5b5050505060016006600084848151811061345357613453614fd1565b6020026020010151600001516001600160a01b03166001600160a01b03168152602001908152602001600020600084848151811061349357613493614fd1565b602002602001015160400151815260200190815260200160002060040160156101000a81548160ff0219169083151502179055505b6001016132fa565b505050505b827f7873807bf6ddc50401cd3d29bbe0decee23fd4d68d273f4b5eb83cded4d2f17260016002604051613509929190615762565b60405180910390a2505050565b6040516bffffffffffffffffffffffff19606084901b1660208201526034810182905260009081906054016040516020818303038152906040528051906020012090506135638582614259565b9150505b9392505050565b6001600160a01b03821663077f224a6135878380615787565b6135946020860186615787565b306040518663ffffffff1660e01b81526004016135b59594939291906157ce565b600060405180830381600087803b1580156135cf57600080fd5b505af11580156135e3573d6000803e3d6000fd5b505050505050565b60408051600080825260208201908152818301928390527fc4c4c7b3000000000000000000000000000000000000000000000000000000009092526001600160a01b0384169163c4c4c7b3916135b591859190306044830161584c565b604080516101408101909152600090806136628580615787565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050908252506001600160a01b038089166020830152871660408201526060908101906136c69060808701908701615892565b65ffffffffffff1681526020016136e360a08601608087016158ad565b63ffffffff1681526020018460a0013581526020018460c0013581526020018381526020018480602001906137189190615787565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509082525060200161375f6040860186615787565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509152506040517fb08d74340000000000000000000000000000000000000000000000000000000081529091506001600160a01b0388169063b08d7434906137df90849088906004016158c8565b600060405180830381600087803b1580156137f957600080fd5b505af115801561380d573d6000803e3d6000fd5b5050505050505050505050565b60408051602a8082526060828101909352600091906020820181803683370190505090507f30000000000000000000000000000000000000000000000000000000000000008160008151811061387257613872614fd1565b60200101906001600160f81b031916908160001a9053507f7800000000000000000000000000000000000000000000000000000000000000816001815181106138bd576138bd614fd1565b60200101906001600160f81b031916908160001a90535060005b60148110156139f45760006138ed82601361547c565b6138f89060086159b4565b613903906002615ab2565b613916906001600160a01b038716615ad4565b60f81b9050600060108260f81c61392d9190615ae8565b60f81b905060008160f81c60106139449190615b0a565b8360f81c6139529190615b26565b60f81b905061396082614267565b8561396c8660026159b4565b613977906002614d59565b8151811061398757613987614fd1565b60200101906001600160f81b031916908160001a9053506139a781614267565b856139b38660026159b4565b6139be906003614d59565b815181106139ce576139ce614fd1565b60200101906001600160f81b031916908160001a90535050600190920191506138d79050565b5092915050565b606081600003613a3e57505060408051808201909152600181527f3000000000000000000000000000000000000000000000000000000000000000602082015290565b6000825b8015613a685781613a5281614da0565b9250613a619050600a82615ad4565b9050613a42565b60008267ffffffffffffffff811115613a8357613a83614554565b6040519080825280601f01601f191660200182016040528015613aad576020820181803683370190505b5090505b8415613b1857613ac260018461547c565b9250613acf600a86615b3f565b613ada906030614d59565b60f81b818481518110613aef57613aef614fd1565b60200101906001600160f81b031916908160001a905350613b11600a86615ad4565b9450613ab1565b949350505050565b613b938282604051602401613b36929190615b53565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f4b5c4277000000000000000000000000000000000000000000000000000000001790526142a2565b5050565b6004546000906001600160a01b03163314613be45760405162461bcd60e51b815260206004820152600d60248201526c2737ba103a34329037bbb732b960991b6044820152606401610d68565b600580544291449133916000613bf983614da0565b909155506040805160208101959095528401929092526bffffffffffffffffffffffff19606091821b1690830152607482015260940160405160208183030381529060405280519060200120905060005b8251811015613f8b5760008281526007602052604090208351849083908110613c7557613c75614fd1565b6020908102919091018101518254600181810185556000948552838520835160059093020180546001600160a01b0393841673ffffffffffffffffffffffffffffffffffffffff199091161781559383015190840155604082015160028401556060820151600384015560808201516004909301805460a084015160c0909401511515600160a81b0260ff60a81b19941515600160a01b0274ffffffffffffffffffffffffffffffffffffffffff19909216959093169490941793909317919091161790555b600354811015613f8257838281518110613d5757613d57614fd1565b6020026020010151600001516001600160a01b031660038281548110613d7f57613d7f614fd1565b60009182526020909120600590910201546001600160a01b0316148015613de65750838281518110613db357613db3614fd1565b60200260200101516040015160038281548110613dd257613dd2614fd1565b906000526020600020906005020160020154145b15613f7a5760038054613dfb9060019061547c565b81548110613e0b57613e0b614fd1565b906000526020600020906005020160038281548110613e2c57613e2c614fd1565b600091825260209091208254600590920201805473ffffffffffffffffffffffffffffffffffffffff199081166001600160a01b0393841617825560018085015490830155600280850154908301556003808501548184015560049485018054959093018054928316959094169485178455825460ff600160a01b918290048116151590910274ffffffffffffffffffffffffffffffffffffffffff19909316909517919091178084559154600160a81b90819004909416151590930260ff60a81b19909116179055805480613f0457613f04615b78565b600082815260208120600560001990930192830201805473ffffffffffffffffffffffffffffffffffffffff191681556001810182905560028101829055600381019190915560040180547fffffffffffffffffffff000000000000000000000000000000000000000000001690559055613f82565b600101613d3b565b50600101613c4a565b506000818155818152600a602052604090819020805460ff1916600117905583516080850151915183927f5e87b5b259a63aac337d64eab6329a5b338a5c09b41c8fa0e5c4730da890d6d292613fe392909190615b8e565b60405180910390a292915050565b60408101516000907fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b038516016140765780341015614063576040517f74c5672b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6140718360200151826142ab565b61408a565b61408a8484600001518560200151846142c7565b5060019392505050565b6040805160e081018252338082526020808301888152838501888152606085018881526001600160a01b0388811660808801818152600060a08a0181815260c08b018281526003805460018101825593529a517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b6005909302928301805473ffffffffffffffffffffffffffffffffffffffff191691871691909117905596517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85c82015594517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85d86015592517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85e85015591517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85f9093018054945197519390911674ffffffffffffffffffffffffffffffffffffffffff1990941693909317600160a01b961515969096029590951760ff60a81b1916600160a81b91151591909102179055835186815290810192909252859287927fb65a679ed33acf689f42e48df6479c5b17db675374667f1e11a2f24e3bed897a910160405180910390a450505050565b60006135678383600061432e565b6000600a60f883901c101561428e5761428560f883901c6030615bb3565b60f81b92915050565b61428560f883901c6057615bb3565b919050565b61259f816143f7565b60003860003884865af1613b935763b12d13eb6000526004601cfd5b60405181606052826040528360601b602c526f23b872dd000000000000000000000000600c52602060006064601c6000895af1806001600051141661431f57803d873b15171061431f57637939f4246000526004601cfd5b50600060605260405250505050565b600081471015614373576040517fcf47918100000000000000000000000000000000000000000000000000000000815247600482015260248101839052604401610d68565b763d602d80600a3d3981f3363d3d373d3d3d363d730000008460601b60e81c176000526e5af43d82803e903d91602b57fd5bf38460781b17602052826037600984f590506001600160a01b038116613567576040517fb06ebf3d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b508054600082556005029060005260206000209081019061259f91905b8082111561449f57805473ffffffffffffffffffffffffffffffffffffffff191681556000600182018190556002820181905560038201556004810180547fffffffffffffffffffff00000000000000000000000000000000000000000000169055600501614435565b5090565b6000602082840312156144b557600080fd5b5035919050565b602080825282518282018190526000918401906040840190835b8181101561296f5761453e8385516001600160a01b0381511682526020810151602083015260408101516040830152606081015160608301526001600160a01b03608082015116608083015260a0810151151560a083015260c0810151151560c08301525050565b6020939093019260e092909201916001016144d6565b634e487b7160e01b600052604160045260246000fd5b60405160e0810167ffffffffffffffff8111828210171561458d5761458d614554565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156145bc576145bc614554565b604052919050565b600067ffffffffffffffff8211156145de576145de614554565b50601f01601f191660200190565b600082601f8301126145fd57600080fd5b8135602083016000614616614611846145c4565b614593565b905082815285838301111561462a57600080fd5b82826020830137600092810160200192909252509392505050565b6000806040838503121561465857600080fd5b82359150602083013567ffffffffffffffff81111561467657600080fd5b614682858286016145ec565b9150509250929050565b6001600160a01b038116811461259f57600080fd5b6000602082840312156146b357600080fd5b81356135678161468c565b6000604082840312156146d057600080fd5b50919050565b600060e082840312156146d057600080fd5b60008083601f8401126146fa57600080fd5b50813567ffffffffffffffff81111561471257600080fd5b6020830191508360208260051b8501011115611ee057600080fd5b600080600080600080600060a0888a03121561474857600080fd5b873567ffffffffffffffff81111561475f57600080fd5b61476b8a828b016146be565b97505060208801359550604088013567ffffffffffffffff81111561478f57600080fd5b61479b8a828b016146d6565b955050606088013567ffffffffffffffff8111156147b857600080fd5b6147c48a828b016146e8565b909550935050608088013567ffffffffffffffff8111156147e457600080fd5b6147f08a828b016146e8565b989b979a50959850939692959293505050565b60005b8381101561481e578181015183820152602001614806565b50506000910152565b6000815180845261483f816020860160208601614803565b601f01601f19169290920160200192915050565b6020815260006135676020830184614827565b801515811461259f57600080fd5b60006020828403121561488657600080fd5b813561356781614866565b600080604083850312156148a457600080fd5b82356148af8161468c565b946020939093013593505050565b600080602083850312156148d057600080fd5b823567ffffffffffffffff8111156148e757600080fd5b8301601f810185136148f857600080fd5b803567ffffffffffffffff81111561490f57600080fd5b85602082840101111561492157600080fd5b6020919091019590945092505050565b8215158152604060208201526000613b186040830184614827565b803563ffffffff8116811461429d57600080fd5b6000806000806080858703121561497657600080fd5b843567ffffffffffffffff81111561498d57600080fd5b614999878288016145ec565b945050602085013567ffffffffffffffff811681146149b757600080fd5b92506149c56040860161494c565b9396929550929360600135925050565b6000806000806000806000806080898b0312156149f157600080fd5b883567ffffffffffffffff811115614a0857600080fd5b614a148b828c016146e8565b909950975050602089013567ffffffffffffffff811115614a3457600080fd5b614a408b828c016146e8565b909750955050604089013567ffffffffffffffff811115614a6057600080fd5b614a6c8b828c016146e8565b909550935050606089013567ffffffffffffffff811115614a8c57600080fd5b614a988b828c016146e8565b999c989b5096995094979396929594505050565b600080600060608486031215614ac157600080fd5b83359250602084013567ffffffffffffffff811115614adf57600080fd5b614aeb868287016145ec565b925050604084013567ffffffffffffffff811115614b0857600080fd5b614b14868287016145ec565b9150509250925092565b600060208284031215614b3057600080fd5b813567ffffffffffffffff811115614b4757600080fd5b613b18848285016145ec565b600082825180855260208501945060208160051b8301016020850160005b83811015614ba357601f19858403018852614b8d838351614827565b6020988901989093509190910190600101614b71565b50909695505050505050565b6020815260006135676020830184614b53565b60e081016116f582846001600160a01b0381511682526020810151602083015260408101516040830152606081015160608301526001600160a01b03608082015116608083015260a0810151151560a083015260c0810151151560c08301525050565b60008060008060008060008060c0898b031215614c4157600080fd5b883567ffffffffffffffff811115614c5857600080fd5b614c648b828c016146be565b98505060208901359650604089013567ffffffffffffffff811115614c8857600080fd5b614c948b828c016146d6565b965050606089013567ffffffffffffffff811115614cb157600080fd5b614cbd8b828c016146e8565b909650945050608089013567ffffffffffffffff811115614cdd57600080fd5b614ce98b828c016146e8565b999c989b50969995989497949560a00135949350505050565b60008060008060808587031215614d1857600080fd5b8435935060208501359250604085013591506060850135614d388161468c565b939692955090935050565b634e487b7160e01b600052601160045260246000fd5b808201808211156116f5576116f5614d43565b600181811c90821680614d8057607f821691505b6020821081036146d057634e487b7160e01b600052602260045260246000fd5b60006000198203614db357614db3614d43565b5060010190565b600060208284031215614dcc57600080fd5b5051919050565b81835260208301925060008160005b84811015614e13578135614df58161468c565b6001600160a01b031686526020958601959190910190600101614de2565b5093949350505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115614e4f57600080fd5b8260051b80836020870137939093016020019392505050565b604081526000614e7c604083018688614dd3565b8281036020840152614e8f818587614e1d565b979650505050505050565b600067ffffffffffffffff821115614eb457614eb4614554565b5060051b60200190565b600060208284031215614ed057600080fd5b813567ffffffffffffffff811115614ee757600080fd5b8201601f81018413614ef857600080fd5b8035614f0661461182614e9a565b80828252602082019150602060e08402850101925086831115614f2857600080fd5b6020840193505b82841015614fc75760e08488031215614f4757600080fd5b614f4f61456a565b8435614f5a8161468c565b81526020858101359082015260408086013590820152606080860135908201526080850135614f888161468c565b608082015260a0850135614f9b81614866565b60a082015260c0850135614fae81614866565b60c0820152825260e09390930192602090910190614f2f565b9695505050505050565b634e487b7160e01b600052603260045260246000fd5b60008151614ff9818560208601614803565b9290920192915050565b7f64616f3d0000000000000000000000000000000000000000000000000000000081526000865161503b816004850160208b01614803565b7f3b64616f49643d00000000000000000000000000000000000000000000000000600491840191820152865161507881600b840160208b01614803565b6004818301019150507f3b70726f706f73616c49643d0000000000000000000000000000000000000000600782015285516150ba816013840160208a01614803565b6007818301019150507f3b736e617073686f743d00000000000000000000000000000000000000000000600c82015284516150fc816016840160208901614803565b6151376151316016848401017f3b766f7465546f6b656e3d0000000000000000000000000000000000000000008152600b0190565b86614fe7565b9998505050505050505050565b602080825282548282018190526000848152918220906040840190835b8181101561296f5783546001600160a01b039081168452600185015460208501526002850154604085015260038501546060850152600485015490811660808501526151b760a0850160ff8360a01c1615159052565b6151cb60c0850160ff8360a81c1615159052565b506005939093019260e09290920191600101615161565b60006151f0614611846145c4565b905082815283838301111561520457600080fd5b613567836020830184614803565b6000806040838503121561522557600080fd5b825161523081614866565b602084015190925067ffffffffffffffff81111561524d57600080fd5b8301601f8101851361525e57600080fd5b614682858251602084016151e2565b60006020828403121561527f57600080fd5b815167ffffffffffffffff81111561529657600080fd5b8201601f810184136152a757600080fd5b80516152b561461182614e9a565b80828252602082019150602060e084028501019250868311156152d757600080fd5b6020840193505b82841015614fc75760e084880312156152f657600080fd5b6152fe61456a565b84516153098161468c565b815260208581015190820152604080860151908201526060808601519082015260808501516153378161468c565b608082015260a085015161534a81614866565b60a082015260c085015161535d81614866565b60c0820152825260e093909301926020909101906152de565b601f821115610f5157806000526020600020601f840160051c8101602085101561539d5750805b601f840160051c820191505b81811015612fbf57600081556001016153a9565b815167ffffffffffffffff8111156153d7576153d7614554565b6153eb816153e58454614d6c565b84615376565b6020601f82116001811461541f57600083156154075750848201515b600019600385901b1c1916600184901b178455612fbf565b600084815260208120601f198516915b8281101561544f578785015182556020948501946001909201910161542f565b508482101561546d5786840151600019600387901b60f8161c191681555b50505050600190811b01905550565b818103818111156116f5576116f5614d43565b6000808335601e198436030181126154a657600080fd5b830160208101925035905067ffffffffffffffff8111156154c657600080fd5b803603821315611ee057600080fd5b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b803565ffffffffffff8116811461429d57600080fd5b60c0815260006155268a8b61548f565b604060c085015261553c610100850182846154d5565b91505061554c60208c018c61548f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff408584030160e08601526155818382846154d5565b92505050896020840152828103604084015261559d898a61548f565b60e083526155af60e0840182846154d5565b9150506155bf60208b018b61548f565b83830360208501526155d28382846154d5565b925050506155e360408b018b61548f565b83830360408501526155f68382846154d5565b9250505065ffffffffffff61560d60608c01615500565b16606083015263ffffffff61562460808c0161494c565b16608083015260a08a8101359083015260c0808b013590830152838103606085015261565181898b614dd3565b9150508281036080840152615667818688614e1d565b9150508260a08301529998505050505050505050565b60006020828403121561568f57600080fd5b815167ffffffffffffffff8111156156a657600080fd5b8201601f810184136156b757600080fd5b613b18848251602084016151e2565b828152604060208201526000613b186040830184614827565b600081546156ec81614d6c565b808552600182168015615706576001811461572257615759565b60ff1983166020870152602082151560051b8701019350615759565b84600052602060002060005b838110156157505781546020828a01015260018201915060208101905061572e565b87016020019450505b50505092915050565b60408152600061577560408301856156df565b828103602084015261356381856156df565b6000808335601e1984360301811261579e57600080fd5b83018035915067ffffffffffffffff8211156157b957600080fd5b602001915036819003821315611ee057600080fd5b6060815260006157e26060830187896154d5565b82810360208401526157f58186886154d5565b9150506001600160a01b03831660408301529695505050505050565b600081518084526020840193506020830160005b82811015614e135781516001600160a01b0316865260209586019590910190600101615825565b8481526080602082015260006158656080830186615811565b82810360408401526158778186615811565b9150506001600160a01b038316606083015295945050505050565b6000602082840312156158a457600080fd5b61356782615500565b6000602082840312156158bf57600080fd5b6135678261494c565b604081526000835161014060408401526158e6610180840182614827565b9050602085015161590260608501826001600160a01b03169052565b5060408501516001600160a01b038116608085015250606085015165ffffffffffff811660a085015250608085015163ffffffff811660c08501525060a085015160e084015260c085015161010084015260e0850151610120840152610100850151603f198483030161014085015261597b8282614827565b915050610120850151603f198483030161016085015261599b8282614827565b9250505061356760208301846001600160a01b03169052565b80820281158282048414176116f5576116f5614d43565b6001815b6001841115615a06578085048111156159ea576159ea614d43565b60018416156159f857908102905b60019390931c9280026159cf565b935093915050565b600082615a1d575060016116f5565b81615a2a575060006116f5565b8160018114615a405760028114615a4a57615a66565b60019150506116f5565b60ff841115615a5b57615a5b614d43565b50506001821b6116f5565b5060208310610133831016604e8410600b8410161715615a89575081810a6116f5565b615a9660001984846159cb565b8060001904821115615aaa57615aaa614d43565b029392505050565b60006135678383615a0e565b634e487b7160e01b600052601260045260246000fd5b600082615ae357615ae3615abe565b500490565b600060ff831680615afb57615afb615abe565b8060ff84160491505092915050565b60ff81811683821602908116908181146139f4576139f4614d43565b60ff82811682821603908111156116f5576116f5614d43565b600082615b4e57615b4e615abe565b500690565b604081526000615b666040830185614827565b82810360208401526135638185614827565b634e487b7160e01b600052603160045260246000fd5b604081526000615ba16040830185614827565b82810360208401526135638185614b53565b60ff81811683821601908111156116f5576116f5614d4356fea2646970667358221220637c3c223f61d207c632303ddd34ebab8391f230804366b195a35c08294e063464736f6c634300081c0033",
	"deployedBytecode": "0x60806040526004361061034e5760003560e01c8063a035b1fe116101bb578063c848ebde116100f7578063d462eaa411610095578063e8c016e61161006f578063e8c016e614610b8f578063f22cb87414610baf578063f2fde38b14610bc4578063f96ec28f14610be457600080fd5b8063d462eaa414610b40578063d966a59414610b60578063d9c39ba414610b7a57600080fd5b8063d01cf419116100d1578063d01cf41914610ac7578063d1e93d1414610add578063d2d16f3014610b0d578063d33219b414610b2057600080fd5b8063c848ebde1461098c578063cec9cf98146109ac578063cfa38da7146109d957600080fd5b8063af38187a11610164578063b404a5841161013e578063b404a58414610922578063b67be84214610942578063b8f7700514610957578063c45a01551461096c57600080fd5b8063af38187a146108d2578063b04dfe60146108f2578063b1e217491461090c57600080fd5b8063a2785f0b11610195578063a2785f0b14610879578063a3d3c0d21461088e578063ab37b0ad146108a457600080fd5b8063a035b1fe1461074d578063a07b57f614610763578063a0cf0aea1461085157600080fd5b80634b0795a81161028a5780636cd2c43d116102335780638da5cb5b1161020d5780638da5cb5b146106cb5780638fb987eb146106eb5780639681096f14610718578063977caf4f1461073857600080fd5b80636cd2c43d1461065b5780636e04ff0d14610671578063835f93601461069f57600080fd5b80635ff2d2aa116102645780635ff2d2aa1461059e578063615f64fe146105f8578063624cffd41461064557600080fd5b80634b0795a81461054457806357970e93146105595780635dc228a01461057957600080fd5b8063302288e2116102f75780633b257a5d116102d15780633b257a5d146104b45780633df10fa1146104d457806340785b46146104f45780634585e33b1461052457600080fd5b8063302288e21461045f57806334b65e2e1461047f5780633944ea3a1461049257600080fd5b80631a402c94116103285780631a402c94146103db5780632b7ac3f3146103fb5780632d0335ab1461041b57600080fd5b806307e32f0a1461035a5780630c340a241461037c5780630fc7a9b7146103b957600080fd5b3661035557005b600080fd5b34801561036657600080fd5b5061037a6103753660046144a3565b610c28565b005b34801561038857600080fd5b5060195461039c906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156103c557600080fd5b506103ce610c51565b6040516103b091906144bc565b3480156103e757600080fd5b5061037a6103f6366004614645565b610d0e565b34801561040757600080fd5b5060185461039c906001600160a01b031681565b34801561042757600080fd5b506104516104363660046146a1565b6001600160a01b031660009081526010602052604090205490565b6040519081526020016103b0565b34801561046b57600080fd5b5061037a61047a3660046144a3565b610daf565b61037a61048d36600461472d565b610f56565b34801561049e57600080fd5b506104a7611575565b6040516103b09190614853565b3480156104c057600080fd5b5061037a6104cf366004614645565b611603565b3480156104e057600080fd5b5061037a6104ef366004614874565b61167c565b34801561050057600080fd5b5061051461050f366004614891565b6116c3565b60405190151581526020016103b0565b34801561053057600080fd5b5061037a61053f3660046148bd565b6116fb565b34801561055057600080fd5b506104a7611b0f565b34801561056557600080fd5b50601a5461039c906001600160a01b031681565b34801561058557600080fd5b50600b5461039c9061010090046001600160a01b031681565b3480156105aa57600080fd5b5061037a6105b93660046146a1565b600b80546001600160a01b03909216610100027fffffffffffffffffffffff0000000000000000000000000000000000000000ff909216919091179055565b34801561060457600080fd5b50601654601754601954601854604080516001600160a01b0395861681529385166020850152918416918301919091529190911660608201526080016103b0565b34801561065157600080fd5b50610451600c5481565b34801561066757600080fd5b50610451600f5481565b34801561067d57600080fd5b5061069161068c3660046148bd565b611b1c565b6040516103b0929190614931565b3480156106ab57600080fd5b506106b4611ee7565b6040805192151583526020830191909152016103b0565b3480156106d757600080fd5b5060045461039c906001600160a01b031681565b3480156106f757600080fd5b506104516107063660046146a1565b60126020526000908152604090205481565b34801561072457600080fd5b50610451610733366004614960565b612030565b34801561074457600080fd5b50610451612104565b34801561075957600080fd5b5061045160135481565b34801561076f57600080fd5b506107f561077e3660046144a3565b60408051608081018252600080825260208201819052918101829052606081019190915250600090815260116020908152604091829020825160808101845281546001600160a01b039081168252600183015481169382019390935260028201548316938101939093526003015416606082015290565b6040516103b0919060006080820190506001600160a01b0383511682526001600160a01b0360208401511660208301526001600160a01b0360408401511660408301526001600160a01b03606084015116606083015292915050565b34801561085d57600080fd5b5061039c73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee81565b34801561088557600080fd5b50600554610451565b34801561089a57600080fd5b50610451600d5481565b3480156108b057600080fd5b5061037a6108bf366004614874565b600e805460ff1916911515919091179055565b3480156108de57600080fd5b5060165461039c906001600160a01b031681565b3480156108fe57600080fd5b50600e546105149060ff1681565b34801561091857600080fd5b5061045160005481565b34801561092e57600080fd5b5061037a61093d3660046149d5565b61222f565b34801561094e57600080fd5b5061037a6124f2565b34801561096357600080fd5b50600354610451565b34801561097857600080fd5b5060155461039c906001600160a01b031681565b34801561099857600080fd5b5061037a6109a7366004614aac565b6125a2565b3480156109b857600080fd5b506109cc6109c7366004614b1e565b61261d565b6040516103b09190614baf565b3480156109e557600080fd5b50610aba6109f4366004614891565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810191909152506001600160a01b03918216600090815260066020908152604080832093835292815290829020825160e081018452815485168152600182015492810192909252600281015492820192909252600382015460608201526004909101549182166080820152600160a01b820460ff908116151560a0830152600160a81b909204909116151560c082015290565b6040516103b09190614bc2565b348015610ad357600080fd5b5061045160145481565b348015610ae957600080fd5b50610514610af83660046144a3565b6000908152600a602052604090205460ff1690565b61037a610b1b366004614c25565b61297a565b348015610b2c57600080fd5b5060175461039c906001600160a01b031681565b348015610b4c57600080fd5b5061037a610b5b3660046144a3565b600f55565b348015610b6c57600080fd5b50600b546105149060ff1681565b348015610b8657600080fd5b5061037a612b83565b348015610b9b57600080fd5b5061037a610baa366004614d02565b612f13565b348015610bbb57600080fd5b5061037a612fc6565b348015610bd057600080fd5b5061037a610bdf3660046146a1565b612fd4565b348015610bf057600080fd5b50610bf961304d565b6040805196151587526020870195909552938501929092526060840152608083015260a082015260c0016103b0565b600f54600003610c375742600f555b80600f6000828254610c499190614d59565b909155505050565b60606003805480602002602001604051908101604052809291908181526020016000905b82821015610d055760008481526020908190206040805160e0810182526005860290920180546001600160a01b0390811684526001808301548587015260028301549385019390935260038201546060850152600490910154908116608084015260ff600160a01b82048116151560a0850152600160a81b90910416151560c08301529083529092019101610c75565b50505050905090565b6000828152600a602052604090205460ff16610d715760405162461bcd60e51b815260206004820152601360248201527f52657175657374206e6f742070656e64696e670000000000000000000000000060448201526064015b60405180910390fd5b600081604051602001610d849190614853565b60408051601f1981840301815260208301909152600082529150610da9848383613184565b50505050565b6000818152600a602052604090205460ff16610e0d5760405162461bcd60e51b815260206004820152601360248201527f52657175657374206e6f742070656e64696e67000000000000000000000000006044820152606401610d68565b60008181526008602052604081208054610e2690614d6c565b80601f0160208091040260200160405190810160405280929190818152602001828054610e5290614d6c565b8015610e9f5780601f10610e7457610100808354040283529160200191610e9f565b820191906000526020600020905b815481529060010190602001808311610e8257829003601f168201915b505050505090506000600960008481526020019081526020016000208054610ec690614d6c565b80601f0160208091040260200160405190810160405280929190818152602001828054610ef290614d6c565b8015610f3f5780601f10610f1457610100808354040283529160200191610f3f565b820191906000526020600020905b815481529060010190602001808311610f2257829003601f168201915b50505050509050610f51838383613184565b505050565b6015546001600160a01b03163314610f9a576040517f075fd2b100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b828114610fd3576040517f636e39bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b33600090815260106020526040812080548290610fef90614da0565b9190508190559050600060146000815461100890614da0565b918290555060165490915060009061102a906001600160a01b03163385613516565b601754909150600090611051906001600160a01b03163361104c876001614d59565b613516565b601954909150600090611073906001600160a01b03163361104c886002614d59565b9050611080856002614d59565b3360009081526010602052604090205561109a838d61356e565b6110a4828c6135eb565b6018546110c1908290859085906001600160a01b03168e89613648565b816001600160a01b0316632f2ff15d836001600160a01b0316638f61f4f56040518163ffffffff1660e01b8152600401602060405180830381865afa15801561110e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111329190614dba565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815260048101919091526001600160a01b0384166024820152604401600060405180830381600087803b15801561119257600080fd5b505af11580156111a6573d6000803e3d6000fd5b50505050816001600160a01b0316632f2ff15d836001600160a01b03166307bd02656040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121b9190614dba565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b168152600481019190915260006024820152604401600060405180830381600087803b15801561127357600080fd5b505af1158015611287573d6000803e3d6000fd5b50505050816001600160a01b03166336568abe836001600160a01b031663a217fddf6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156112d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112fc9190614dba565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b1681526004810191909152306024820152604401600060405180830381600087803b15801561135357600080fd5b505af1158015611367573d6000803e3d6000fd5b50506040517f7c88e3d90000000000000000000000000000000000000000000000000000000081526001600160a01b0386169250637c88e3d991506113b6908c908c908c908c90600401614e68565b600060405180830381600087803b1580156113d057600080fd5b505af11580156113e4573d6000803e3d6000fd5b50506040517ff2fde38b0000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301528616925063f2fde38b9150602401600060405180830381600087803b15801561144457600080fd5b505af1158015611458573d6000803e3d6000fd5b5050506001600160a01b0380831660008181526012602090815260408083208a90558051608081018252898616815288861681840190815281830195865233606083018181528d87526011909552948390209151825490881673ffffffffffffffffffffffffffffffffffffffff19918216178355905160018301805491891691831691909117905594516002820180549188169187169190911790559151600390920180549290951691909316179092555190915085907f3b785ea6f499a552d583841394f9e27727de143f34ed2585796814f93887d84f9061155f908790879087906001600160a01b0393841681529183166020830152909116604082015260600190565b60405180910390a3505050505050505050505050565b6001805461158290614d6c565b80601f01602080910402602001604051908101604052809291908181526020018280546115ae90614d6c565b80156115fb5780601f106115d0576101008083540402835291602001916115fb565b820191906000526020600020905b8154815290600101906020018083116115de57829003601f168201915b505050505081565b6000828152600a602052604090205460ff166116615760405162461bcd60e51b815260206004820152601360248201527f52657175657374206e6f742070656e64696e67000000000000000000000000006044820152606401610d68565b60408051602081019091526000815281610da9848383613184565b600b805460ff19168215159081179091556040519081527f597db723170e2062ff01c7a921f699b0274807a884be8bdce5f2fcf3d645844b9060200160405180910390a150565b6001600160a01b0382166000908152600660209081526040808320848452909152902060040154600160a01b900460ff165b92915050565b600b5461010090046001600160a01b031633148061171857503330145b61178a5760405162461bcd60e51b815260206004820152602660248201527f4f6e6c79206175746f6d6174696f6e2072656769737472792063616e2063616c60448201527f6c207468697300000000000000000000000000000000000000000000000000006064820152608401610d68565b600b5460ff166117dc5760405162461bcd60e51b815260206004820152601660248201527f4175746f6d6174696f6e2069732064697361626c6564000000000000000000006044820152606401610d68565b60006117ea82840184614ebe565b90506000815167ffffffffffffffff81111561180857611808614554565b60405190808252806020026020018201604052801561183b57816020015b60608152602001906001900390816118265790505b50905060005b8251811015611ab257600083828151811061185e5761185e614fd1565b60209081029190910181015180516001600160a01b031660009081526006835260408082208184015183529093529190912060040154909150606090600160a01b900460ff16611a025781516001600160a01b03166000908152600660209081526040808320818601518452909152902060040180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff16600160a01b17905581516119099061381a565b61191683602001516139fb565b61192384604001516139fb565b61193085606001516139fb565b61193d866080015161381a565b604051602001611951959493929190615003565b60405160208183030381529060405290508084848151811061197557611975614fd1565b60200260200101819052506119bf6040518060400160405280601481526020017f53657269616c697a65642070726f706f73616c3a00000000000000000000000081525082613b20565b81604001517f3e069fb74dcf5fbc07740b0d40d7f7fc48e9c0ca5dc3d19eb34d2e05d74c554383606001516040516119f991815260200190565b60405180910390a25b6040805161012081018252600d60e082019081527f717565756550726f706f73616c00000000000000000000000000000000000000610100830152815281516020808201845260008083528184019290925282840182905260608301829052608083018890528351828152908101909352611aa79260a0830191611a96565b6060815260200190600190039081611a815790505b508152600060209091015286613b97565b505050600101611841565b5042600c55600d8054906000611ac783614da0565b9190505550600d547f9fbc2aeb5bf6200e5499d345acddf1dd462c37becb4673d661250b89ced7ff6a8351604051611b0191815260200190565b60405180910390a250505050565b6002805461158290614d6c565b600e5460009060609060ff1615611b595760016003604051602001611b419190615144565b60405160208183030381529060405291509150611ee0565b600b5460ff16611b7b5750506040805160208101909152600080825290611ee0565b60008080600f5411611b8d5742611b91565b600f545b905060005b600354811015611c74578160038281548110611bb457611bb4614fd1565b90600052602060002090600502016003015411158015611c5957506006600060038381548110611be657611be6614fd1565b600091825260208083206005909202909101546001600160a01b0316835282019290925260400181206003805491929184908110611c2657611c26614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff16155b15611c6c5782611c6881614da0565b9350505b600101611b96565b5081600003611c9a57600060405180602001604052806000815250935093505050611ee0565b60008267ffffffffffffffff811115611cb557611cb5614554565b604051908082528060200260200182016040528015611d1c57816020015b6040805160e08101825260008082526020808301829052928201819052606082018190526080820181905260a0820181905260c08201528252600019909201910181611cd35790505b5090506000805b600354811015611eb2578360038281548110611d4157611d41614fd1565b90600052602060002090600502016003015411158015611de657506006600060038381548110611d7357611d73614fd1565b600091825260208083206005909202909101546001600160a01b0316835282019290925260400181206003805491929184908110611db357611db3614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff16155b15611eaa5760038181548110611dfe57611dfe614fd1565b60009182526020918290206040805160e081018252600590930290910180546001600160a01b0390811684526001820154948401949094526002810154918301919091526003810154606083015260040154918216608082015260ff600160a01b83048116151560a0830152600160a81b909204909116151560c08201528351849084908110611e9057611e90614fd1565b60200260200101819052508180611ea690614da0565b9250505b600101611d23565b5081604051602001611ec491906144bc565b6040516020818303038152906040529450600084119550505050505b9250929050565b600b54600090819060ff16611eff5750600091829150565b6040517f6e04ff0d000000000000000000000000000000000000000000000000000000008152602060048201526000602482018190529081903090636e04ff0d90604401600060405180830381865afa158015611f60573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611f889190810190615212565b915091508115612024576040517f4585e33b0000000000000000000000000000000000000000000000000000000081523090634585e33b90611fce908490600401614853565b600060405180830381600087803b158015611fe857600080fd5b505af1158015611ffc573d6000803e3d6000fd5b50505050600081806020019051810190612016919061526d565b516001969095509350505050565b50600093849350915050565b6004546000906001600160a01b0316331461207d5760405162461bcd60e51b815260206004820152600d60248201526c2737ba103a34329037bbb732b960991b6044820152606401610d68565b60058054429144913391600061209283614da0565b909155506040805160208101959095528401929092526bffffffffffffffffffffffff19606091821b1690830152607482015260940160408051601f1981840301815291815281516020928301206000818155818152600a9093529120805460ff191660011790559050949350505050565b6040517f6e04ff0d0000000000000000000000000000000000000000000000000000000081526020600482015260006024820181905290819081903090636e04ff0d90604401600060405180830381865afa158015612167573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261218f9190810190615212565b915091508115612226576040517f4585e33b0000000000000000000000000000000000000000000000000000000081523090634585e33b906121d5908490600401614853565b600060405180830381600087803b1580156121ef57600080fd5b505af1158015612203573d6000803e3d6000fd5b5050505060008180602001905181019061221d919061526d565b51949350505050565b60009250505090565b868514801561223d57508483145b6122895760405162461bcd60e51b815260206004820152601660248201527f417272617973206c656e677468206d69736d61746368000000000000000000006044820152606401610d68565b60005b878110156124e75760036040518060e001604052808b8b858181106122b3576122b3614fd1565b90506020020160208101906122c891906146a1565b6001600160a01b03168152602001600081526020018989858181106122ef576122ef614fd1565b90506020020135815260200187878581811061230d5761230d614fd1565b90506020020135815260200185858581811061232b5761232b614fd1565b905060200201602081019061234091906146a1565b6001600160a01b039081168252600060208084018290526040938401829052855460018181018855968352918190208551600590930201805492841673ffffffffffffffffffffffffffffffffffffffff19909316929092178255840151948101949094559082015160028401556060820151600384015560808201516004909301805460a084015160c0909401511515600160a81b0260ff60a81b19941515600160a01b0274ffffffffffffffffffffffffffffffffffffffffff199092169590931694909417939093179190911617905586868281811061242557612425614fd1565b9050602002013560008a8a8481811061244057612440614fd1565b905060200201602081019061245591906146a1565b6001600160a01b03167fb65a679ed33acf689f42e48df6479c5b17db675374667f1e11a2f24e3bed897a88888681811061249157612491614fd1565b905060200201358787878181106124aa576124aa614fd1565b90506020020160208101906124bf91906146a1565b604080519283526001600160a01b0390911660208301520160405180910390a460010161228c565b505050505050505050565b60005b60035481101561259f576000600660006003848154811061251857612518614fd1565b600091825260208083206005909202909101546001600160a01b031683528201929092526040018120600380549192918590811061255857612558614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160146101000a81548160ff02191690831515021790555080806001019150506124f5565b50565b6004546001600160a01b031633146125ec5760405162461bcd60e51b815260206004820152600d60248201526c2737ba103a34329037bbb732b960991b6044820152606401610d68565b600083815260086020526040902061260483826153bd565b506000838152600960205260409020610da982826153bd565b606081600160005b82518110156126a35782818151811061264057612640614fd1565b01602001517fff00000000000000000000000000000000000000000000000000000000000000167f7c000000000000000000000000000000000000000000000000000000000000000361269b578161269781614da0565b9250505b600101612625565b5060008167ffffffffffffffff8111156126bf576126bf614554565b6040519080825280602002602001820160405280156126f257816020015b60608152602001906001900390816126dd5790505b50905060008060005b85518110156128725785818151811061271657612716614fd1565b01602001517fff00000000000000000000000000000000000000000000000000000000000000167f7c000000000000000000000000000000000000000000000000000000000000000361286a57600061276f848361547c565b67ffffffffffffffff81111561278757612787614554565b6040519080825280601f01601f1916602001820160405280156127b1576020820181803683370190505b509050835b82811015612831578781815181106127d0576127d0614fd1565b01602001517fff000000000000000000000000000000000000000000000000000000000000001682612802878461547c565b8151811061281257612812614fd1565b60200101906001600160f81b031916908160001a9053506001016127b6565b5080858461283e81614da0565b95508151811061285057612850614fd1565b6020908102919091010152612866826001614d59565b9350505b6001016126fb565b50845182101561296f57600082865161288b919061547c565b67ffffffffffffffff8111156128a3576128a3614554565b6040519080825280601f01601f1916602001820160405280156128cd576020820181803683370190505b509050825b865181101561294e578681815181106128ed576128ed614fd1565b01602001517fff00000000000000000000000000000000000000000000000000000000000000168261291f868461547c565b8151811061292f5761292f614fd1565b60200101906001600160f81b031916908160001a9053506001016128d2565b508084838151811061296257612962614fd1565b6020026020010181905250505b509095945050505050565b601354601a546040517f70a082310000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b03909116906370a0823190602401602060405180830381865afa1580156129de573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a029190614dba565b1015612a3a576040517fe793143800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601354601a546040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523360048201523060248201526001600160a01b039091169063dd62ed3e90604401602060405180830381865afa158015612aa4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ac89190614dba565b1015612b00576040517f0fd3919300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601a546040805160608101825233815230602082015260135491810191909152612b33916001600160a01b031690613ff1565b507f8e89a238ee2d1df84f7e9b3f32630993ecc9e38a775b1a9a7a28bcb158660da08888888888888888604051612b71989796959493929190615516565b60405180910390a15050505050505050565b6000805b600354811015612c33576006600060038381548110612ba857612ba8614fd1565b600091825260208083206005909202909101546001600160a01b0316835282019290925260400181206003805491929184908110612be857612be8614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff16612c2b5781612c2781614da0565b9250505b600101612b87565b5060008167ffffffffffffffff811115612c4f57612c4f614554565b604051908082528060200260200182016040528015612cb657816020015b6040805160e08101825260008082526020808301829052928201819052606082018190526080820181905260a0820181905260c08201528252600019909201910181612c6d5790505b5090506000805b600354811015612e1a576006600060038381548110612cde57612cde614fd1565b600091825260208083206005909202909101546001600160a01b0316835282019290925260400181206003805491929184908110612d1e57612d1e614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff16612e125760038181548110612d6657612d66614fd1565b60009182526020918290206040805160e081018252600590930290910180546001600160a01b0390811684526001820154948401949094526002810154918301919091526003810154606083015260040154918216608082015260ff600160a01b83048116151560a0830152600160a81b909204909116151560c08201528351849084908110612df857612df8614fd1565b60200260200101819052508180612e0e90614da0565b9250505b600101612cbd565b50612e2760036000614418565b60005b8251811015610da9576003838281518110612e4757612e47614fd1565b602090810291909101810151825460018181018555600094855293839020825160059092020180546001600160a01b0392831673ffffffffffffffffffffffffffffffffffffffff199091161781559282015183850155604082015160028401556060820151600384015560808201516004909301805460a084015160c0909401511515600160a81b0260ff60a81b19941515600160a01b0274ffffffffffffffffffffffffffffffffffffffffff199092169590931694909417939093179190911617905501612e2a565b3360009081526012602052604081205490819003612f60576040517f442d09d900000000000000000000000000000000000000000000000000000000815260048101829052602401610d68565b6000818152601160205260409020600201546001600160a01b03163314612fb3576040517f075fd2b100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612fbf85858585614094565b5050505050565b612fd260036000614418565b565b6004546001600160a01b0316331461301e5760405162461bcd60e51b815260206004820152600d60248201526c2737ba103a34329037bbb732b960991b6044820152606401610d68565b6004805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b600080600080600080600080600080600f541161306a574261306e565b600f545b905060005b60035481101561315d57816003828154811061309157613091614fd1565b906000526020600020906005020160030154116131555760066000600383815481106130bf576130bf614fd1565b600091825260208083206005909202909101546001600160a01b03168352820192909252604001812060038054919291849081106130ff576130ff614fd1565b906000526020600020906005020160020154815260200190815260200160002060040160149054906101000a900460ff1615613147578261313f81614da0565b935050613155565b8361315181614da0565b9450505b600101613073565b5050600b54600354600c54600d5460ff9093169b919a509398509196509194509092509050565b6000838152600a602052604090205460ff166131cf576040517fd068bf5b00000000000000000000000000000000000000000000000000000000815260048101849052602401610d68565b6000838152600a60205260409020805460ff1916905560016131f183826153bd565b5060026131fe82826153bd565b508151156134d55760008280602001905181019061321c919061567d565b905060006132298261261d565b905060006007600080548152602001908152602001600020805480602002602001604051908101604052809291908181526020016000905b828210156132f15760008481526020908190206040805160e0810182526005860290920180546001600160a01b0390811684526001808301548587015260028301549385019390935260038201546060850152600490910154908116608084015260ff600160a01b82048116151560a0850152600160a81b90910416151560c08301529083529092019101613261565b50505050905060005b81518110156134d0576006600083838151811061331957613319614fd1565b6020026020010151600001516001600160a01b03166001600160a01b03168152602001908152602001600020600083838151811061335957613359614fd1565b602002602001015160400151815260200190815260200160002060040160159054906101000a900460ff166134c85781818151811061339a5761339a614fd1565b6020026020010151600001516001600160a01b0316633216e1f68383815181106133c6576133c6614fd1565b6020026020010151604001518584815181106133e4576133e4614fd1565b60200260200101516040518363ffffffff1660e01b81526004016134099291906156c6565b600060405180830381600087803b15801561342357600080fd5b505af1158015613437573d6000803e3d6000fd5b5050505060016006600084848151811061345357613453614fd1565b6020026020010151600001516001600160a01b03166001600160a01b03168152602001908152602001600020600084848151811061349357613493614fd1565b602002602001015160400151815260200190815260200160002060040160156101000a81548160ff0219169083151502179055505b6001016132fa565b505050505b827f7873807bf6ddc50401cd3d29bbe0decee23fd4d68d273f4b5eb83cded4d2f17260016002604051613509929190615762565b60405180910390a2505050565b6040516bffffffffffffffffffffffff19606084901b1660208201526034810182905260009081906054016040516020818303038152906040528051906020012090506135638582614259565b9150505b9392505050565b6001600160a01b03821663077f224a6135878380615787565b6135946020860186615787565b306040518663ffffffff1660e01b81526004016135b59594939291906157ce565b600060405180830381600087803b1580156135cf57600080fd5b505af11580156135e3573d6000803e3d6000fd5b505050505050565b60408051600080825260208201908152818301928390527fc4c4c7b3000000000000000000000000000000000000000000000000000000009092526001600160a01b0384169163c4c4c7b3916135b591859190306044830161584c565b604080516101408101909152600090806136628580615787565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050908252506001600160a01b038089166020830152871660408201526060908101906136c69060808701908701615892565b65ffffffffffff1681526020016136e360a08601608087016158ad565b63ffffffff1681526020018460a0013581526020018460c0013581526020018381526020018480602001906137189190615787565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509082525060200161375f6040860186615787565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509152506040517fb08d74340000000000000000000000000000000000000000000000000000000081529091506001600160a01b0388169063b08d7434906137df90849088906004016158c8565b600060405180830381600087803b1580156137f957600080fd5b505af115801561380d573d6000803e3d6000fd5b5050505050505050505050565b60408051602a8082526060828101909352600091906020820181803683370190505090507f30000000000000000000000000000000000000000000000000000000000000008160008151811061387257613872614fd1565b60200101906001600160f81b031916908160001a9053507f7800000000000000000000000000000000000000000000000000000000000000816001815181106138bd576138bd614fd1565b60200101906001600160f81b031916908160001a90535060005b60148110156139f45760006138ed82601361547c565b6138f89060086159b4565b613903906002615ab2565b613916906001600160a01b038716615ad4565b60f81b9050600060108260f81c61392d9190615ae8565b60f81b905060008160f81c60106139449190615b0a565b8360f81c6139529190615b26565b60f81b905061396082614267565b8561396c8660026159b4565b613977906002614d59565b8151811061398757613987614fd1565b60200101906001600160f81b031916908160001a9053506139a781614267565b856139b38660026159b4565b6139be906003614d59565b815181106139ce576139ce614fd1565b60200101906001600160f81b031916908160001a90535050600190920191506138d79050565b5092915050565b606081600003613a3e57505060408051808201909152600181527f3000000000000000000000000000000000000000000000000000000000000000602082015290565b6000825b8015613a685781613a5281614da0565b9250613a619050600a82615ad4565b9050613a42565b60008267ffffffffffffffff811115613a8357613a83614554565b6040519080825280601f01601f191660200182016040528015613aad576020820181803683370190505b5090505b8415613b1857613ac260018461547c565b9250613acf600a86615b3f565b613ada906030614d59565b60f81b818481518110613aef57613aef614fd1565b60200101906001600160f81b031916908160001a905350613b11600a86615ad4565b9450613ab1565b949350505050565b613b938282604051602401613b36929190615b53565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f4b5c4277000000000000000000000000000000000000000000000000000000001790526142a2565b5050565b6004546000906001600160a01b03163314613be45760405162461bcd60e51b815260206004820152600d60248201526c2737ba103a34329037bbb732b960991b6044820152606401610d68565b600580544291449133916000613bf983614da0565b909155506040805160208101959095528401929092526bffffffffffffffffffffffff19606091821b1690830152607482015260940160405160208183030381529060405280519060200120905060005b8251811015613f8b5760008281526007602052604090208351849083908110613c7557613c75614fd1565b6020908102919091018101518254600181810185556000948552838520835160059093020180546001600160a01b0393841673ffffffffffffffffffffffffffffffffffffffff199091161781559383015190840155604082015160028401556060820151600384015560808201516004909301805460a084015160c0909401511515600160a81b0260ff60a81b19941515600160a01b0274ffffffffffffffffffffffffffffffffffffffffff19909216959093169490941793909317919091161790555b600354811015613f8257838281518110613d5757613d57614fd1565b6020026020010151600001516001600160a01b031660038281548110613d7f57613d7f614fd1565b60009182526020909120600590910201546001600160a01b0316148015613de65750838281518110613db357613db3614fd1565b60200260200101516040015160038281548110613dd257613dd2614fd1565b906000526020600020906005020160020154145b15613f7a5760038054613dfb9060019061547c565b81548110613e0b57613e0b614fd1565b906000526020600020906005020160038281548110613e2c57613e2c614fd1565b600091825260209091208254600590920201805473ffffffffffffffffffffffffffffffffffffffff199081166001600160a01b0393841617825560018085015490830155600280850154908301556003808501548184015560049485018054959093018054928316959094169485178455825460ff600160a01b918290048116151590910274ffffffffffffffffffffffffffffffffffffffffff19909316909517919091178084559154600160a81b90819004909416151590930260ff60a81b19909116179055805480613f0457613f04615b78565b600082815260208120600560001990930192830201805473ffffffffffffffffffffffffffffffffffffffff191681556001810182905560028101829055600381019190915560040180547fffffffffffffffffffff000000000000000000000000000000000000000000001690559055613f82565b600101613d3b565b50600101613c4a565b506000818155818152600a602052604090819020805460ff1916600117905583516080850151915183927f5e87b5b259a63aac337d64eab6329a5b338a5c09b41c8fa0e5c4730da890d6d292613fe392909190615b8e565b60405180910390a292915050565b60408101516000907fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b038516016140765780341015614063576040517f74c5672b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6140718360200151826142ab565b61408a565b61408a8484600001518560200151846142c7565b5060019392505050565b6040805160e081018252338082526020808301888152838501888152606085018881526001600160a01b0388811660808801818152600060a08a0181815260c08b018281526003805460018101825593529a517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b6005909302928301805473ffffffffffffffffffffffffffffffffffffffff191691871691909117905596517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85c82015594517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85d86015592517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85e85015591517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85f9093018054945197519390911674ffffffffffffffffffffffffffffffffffffffffff1990941693909317600160a01b961515969096029590951760ff60a81b1916600160a81b91151591909102179055835186815290810192909252859287927fb65a679ed33acf689f42e48df6479c5b17db675374667f1e11a2f24e3bed897a910160405180910390a450505050565b60006135678383600061432e565b6000600a60f883901c101561428e5761428560f883901c6030615bb3565b60f81b92915050565b61428560f883901c6057615bb3565b919050565b61259f816143f7565b60003860003884865af1613b935763b12d13eb6000526004601cfd5b60405181606052826040528360601b602c526f23b872dd000000000000000000000000600c52602060006064601c6000895af1806001600051141661431f57803d873b15171061431f57637939f4246000526004601cfd5b50600060605260405250505050565b600081471015614373576040517fcf47918100000000000000000000000000000000000000000000000000000000815247600482015260248101839052604401610d68565b763d602d80600a3d3981f3363d3d373d3d3d363d730000008460601b60e81c176000526e5af43d82803e903d91602b57fd5bf38460781b17602052826037600984f590506001600160a01b038116613567576040517fb06ebf3d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b508054600082556005029060005260206000209081019061259f91905b8082111561449f57805473ffffffffffffffffffffffffffffffffffffffff191681556000600182018190556002820181905560038201556004810180547fffffffffffffffffffff00000000000000000000000000000000000000000000169055600501614435565b5090565b6000602082840312156144b557600080fd5b5035919050565b602080825282518282018190526000918401906040840190835b8181101561296f5761453e8385516001600160a01b0381511682526020810151602083015260408101516040830152606081015160608301526001600160a01b03608082015116608083015260a0810151151560a083015260c0810151151560c08301525050565b6020939093019260e092909201916001016144d6565b634e487b7160e01b600052604160045260246000fd5b60405160e0810167ffffffffffffffff8111828210171561458d5761458d614554565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156145bc576145bc614554565b604052919050565b600067ffffffffffffffff8211156145de576145de614554565b50601f01601f191660200190565b600082601f8301126145fd57600080fd5b8135602083016000614616614611846145c4565b614593565b905082815285838301111561462a57600080fd5b82826020830137600092810160200192909252509392505050565b6000806040838503121561465857600080fd5b82359150602083013567ffffffffffffffff81111561467657600080fd5b614682858286016145ec565b9150509250929050565b6001600160a01b038116811461259f57600080fd5b6000602082840312156146b357600080fd5b81356135678161468c565b6000604082840312156146d057600080fd5b50919050565b600060e082840312156146d057600080fd5b60008083601f8401126146fa57600080fd5b50813567ffffffffffffffff81111561471257600080fd5b6020830191508360208260051b8501011115611ee057600080fd5b600080600080600080600060a0888a03121561474857600080fd5b873567ffffffffffffffff81111561475f57600080fd5b61476b8a828b016146be565b97505060208801359550604088013567ffffffffffffffff81111561478f57600080fd5b61479b8a828b016146d6565b955050606088013567ffffffffffffffff8111156147b857600080fd5b6147c48a828b016146e8565b909550935050608088013567ffffffffffffffff8111156147e457600080fd5b6147f08a828b016146e8565b989b979a50959850939692959293505050565b60005b8381101561481e578181015183820152602001614806565b50506000910152565b6000815180845261483f816020860160208601614803565b601f01601f19169290920160200192915050565b6020815260006135676020830184614827565b801515811461259f57600080fd5b60006020828403121561488657600080fd5b813561356781614866565b600080604083850312156148a457600080fd5b82356148af8161468c565b946020939093013593505050565b600080602083850312156148d057600080fd5b823567ffffffffffffffff8111156148e757600080fd5b8301601f810185136148f857600080fd5b803567ffffffffffffffff81111561490f57600080fd5b85602082840101111561492157600080fd5b6020919091019590945092505050565b8215158152604060208201526000613b186040830184614827565b803563ffffffff8116811461429d57600080fd5b6000806000806080858703121561497657600080fd5b843567ffffffffffffffff81111561498d57600080fd5b614999878288016145ec565b945050602085013567ffffffffffffffff811681146149b757600080fd5b92506149c56040860161494c565b9396929550929360600135925050565b6000806000806000806000806080898b0312156149f157600080fd5b883567ffffffffffffffff811115614a0857600080fd5b614a148b828c016146e8565b909950975050602089013567ffffffffffffffff811115614a3457600080fd5b614a408b828c016146e8565b909750955050604089013567ffffffffffffffff811115614a6057600080fd5b614a6c8b828c016146e8565b909550935050606089013567ffffffffffffffff811115614a8c57600080fd5b614a988b828c016146e8565b999c989b5096995094979396929594505050565b600080600060608486031215614ac157600080fd5b83359250602084013567ffffffffffffffff811115614adf57600080fd5b614aeb868287016145ec565b925050604084013567ffffffffffffffff811115614b0857600080fd5b614b14868287016145ec565b9150509250925092565b600060208284031215614b3057600080fd5b813567ffffffffffffffff811115614b4757600080fd5b613b18848285016145ec565b600082825180855260208501945060208160051b8301016020850160005b83811015614ba357601f19858403018852614b8d838351614827565b6020988901989093509190910190600101614b71565b50909695505050505050565b6020815260006135676020830184614b53565b60e081016116f582846001600160a01b0381511682526020810151602083015260408101516040830152606081015160608301526001600160a01b03608082015116608083015260a0810151151560a083015260c0810151151560c08301525050565b60008060008060008060008060c0898b031215614c4157600080fd5b883567ffffffffffffffff811115614c5857600080fd5b614c648b828c016146be565b98505060208901359650604089013567ffffffffffffffff811115614c8857600080fd5b614c948b828c016146d6565b965050606089013567ffffffffffffffff811115614cb157600080fd5b614cbd8b828c016146e8565b909650945050608089013567ffffffffffffffff811115614cdd57600080fd5b614ce98b828c016146e8565b999c989b50969995989497949560a00135949350505050565b60008060008060808587031215614d1857600080fd5b8435935060208501359250604085013591506060850135614d388161468c565b939692955090935050565b634e487b7160e01b600052601160045260246000fd5b808201808211156116f5576116f5614d43565b600181811c90821680614d8057607f821691505b6020821081036146d057634e487b7160e01b600052602260045260246000fd5b60006000198203614db357614db3614d43565b5060010190565b600060208284031215614dcc57600080fd5b5051919050565b81835260208301925060008160005b84811015614e13578135614df58161468c565b6001600160a01b031686526020958601959190910190600101614de2565b5093949350505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115614e4f57600080fd5b8260051b80836020870137939093016020019392505050565b604081526000614e7c604083018688614dd3565b8281036020840152614e8f818587614e1d565b979650505050505050565b600067ffffffffffffffff821115614eb457614eb4614554565b5060051b60200190565b600060208284031215614ed057600080fd5b813567ffffffffffffffff811115614ee757600080fd5b8201601f81018413614ef857600080fd5b8035614f0661461182614e9a565b80828252602082019150602060e08402850101925086831115614f2857600080fd5b6020840193505b82841015614fc75760e08488031215614f4757600080fd5b614f4f61456a565b8435614f5a8161468c565b81526020858101359082015260408086013590820152606080860135908201526080850135614f888161468c565b608082015260a0850135614f9b81614866565b60a082015260c0850135614fae81614866565b60c0820152825260e09390930192602090910190614f2f565b9695505050505050565b634e487b7160e01b600052603260045260246000fd5b60008151614ff9818560208601614803565b9290920192915050565b7f64616f3d0000000000000000000000000000000000000000000000000000000081526000865161503b816004850160208b01614803565b7f3b64616f49643d00000000000000000000000000000000000000000000000000600491840191820152865161507881600b840160208b01614803565b6004818301019150507f3b70726f706f73616c49643d0000000000000000000000000000000000000000600782015285516150ba816013840160208a01614803565b6007818301019150507f3b736e617073686f743d00000000000000000000000000000000000000000000600c82015284516150fc816016840160208901614803565b6151376151316016848401017f3b766f7465546f6b656e3d0000000000000000000000000000000000000000008152600b0190565b86614fe7565b9998505050505050505050565b602080825282548282018190526000848152918220906040840190835b8181101561296f5783546001600160a01b039081168452600185015460208501526002850154604085015260038501546060850152600485015490811660808501526151b760a0850160ff8360a01c1615159052565b6151cb60c0850160ff8360a81c1615159052565b506005939093019260e09290920191600101615161565b60006151f0614611846145c4565b905082815283838301111561520457600080fd5b613567836020830184614803565b6000806040838503121561522557600080fd5b825161523081614866565b602084015190925067ffffffffffffffff81111561524d57600080fd5b8301601f8101851361525e57600080fd5b614682858251602084016151e2565b60006020828403121561527f57600080fd5b815167ffffffffffffffff81111561529657600080fd5b8201601f810184136152a757600080fd5b80516152b561461182614e9a565b80828252602082019150602060e084028501019250868311156152d757600080fd5b6020840193505b82841015614fc75760e084880312156152f657600080fd5b6152fe61456a565b84516153098161468c565b815260208581015190820152604080860151908201526060808601519082015260808501516153378161468c565b608082015260a085015161534a81614866565b60a082015260c085015161535d81614866565b60c0820152825260e093909301926020909101906152de565b601f821115610f5157806000526020600020601f840160051c8101602085101561539d5750805b601f840160051c820191505b81811015612fbf57600081556001016153a9565b815167ffffffffffffffff8111156153d7576153d7614554565b6153eb816153e58454614d6c565b84615376565b6020601f82116001811461541f57600083156154075750848201515b600019600385901b1c1916600184901b178455612fbf565b600084815260208120601f198516915b8281101561544f578785015182556020948501946001909201910161542f565b508482101561546d5786840151600019600387901b60f8161c191681555b50505050600190811b01905550565b818103818111156116f5576116f5614d43565b6000808335601e198436030181126154a657600080fd5b830160208101925035905067ffffffffffffffff8111156154c657600080fd5b803603821315611ee057600080fd5b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b803565ffffffffffff8116811461429d57600080fd5b60c0815260006155268a8b61548f565b604060c085015261553c610100850182846154d5565b91505061554c60208c018c61548f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff408584030160e08601526155818382846154d5565b92505050896020840152828103604084015261559d898a61548f565b60e083526155af60e0840182846154d5565b9150506155bf60208b018b61548f565b83830360208501526155d28382846154d5565b925050506155e360408b018b61548f565b83830360408501526155f68382846154d5565b9250505065ffffffffffff61560d60608c01615500565b16606083015263ffffffff61562460808c0161494c565b16608083015260a08a8101359083015260c0808b013590830152838103606085015261565181898b614dd3565b9150508281036080840152615667818688614e1d565b9150508260a08301529998505050505050505050565b60006020828403121561568f57600080fd5b815167ffffffffffffffff8111156156a657600080fd5b8201601f810184136156b757600080fd5b613b18848251602084016151e2565b828152604060208201526000613b186040830184614827565b600081546156ec81614d6c565b808552600182168015615706576001811461572257615759565b60ff1983166020870152602082151560051b8701019350615759565b84600052602060002060005b838110156157505781546020828a01015260018201915060208101905061572e565b87016020019450505b50505092915050565b60408152600061577560408301856156df565b828103602084015261356381856156df565b6000808335601e1984360301811261579e57600080fd5b83018035915067ffffffffffffffff8211156157b957600080fd5b602001915036819003821315611ee057600080fd5b6060815260006157e26060830187896154d5565b82810360208401526157f58186886154d5565b9150506001600160a01b03831660408301529695505050505050565b600081518084526020840193506020830160005b82811015614e135781516001600160a01b0316865260209586019590910190600101615825565b8481526080602082015260006158656080830186615811565b82810360408401526158778186615811565b9150506001600160a01b038316606083015295945050505050565b6000602082840312156158a457600080fd5b61356782615500565b6000602082840312156158bf57600080fd5b6135678261494c565b604081526000835161014060408401526158e6610180840182614827565b9050602085015161590260608501826001600160a01b03169052565b5060408501516001600160a01b038116608085015250606085015165ffffffffffff811660a085015250608085015163ffffffff811660c08501525060a085015160e084015260c085015161010084015260e0850151610120840152610100850151603f198483030161014085015261597b8282614827565b915050610120850151603f198483030161016085015261599b8282614827565b9250505061356760208301846001600160a01b03169052565b80820281158282048414176116f5576116f5614d43565b6001815b6001841115615a06578085048111156159ea576159ea614d43565b60018416156159f857908102905b60019390931c9280026159cf565b935093915050565b600082615a1d575060016116f5565b81615a2a575060006116f5565b8160018114615a405760028114615a4a57615a66565b60019150506116f5565b60ff841115615a5b57615a5b614d43565b50506001821b6116f5565b5060208310610133831016604e8410600b8410161715615a89575081810a6116f5565b615a9660001984846159cb565b8060001904821115615aaa57615aaa614d43565b029392505050565b60006135678383615a0e565b634e487b7160e01b600052601260045260246000fd5b600082615ae357615ae3615abe565b500490565b600060ff831680615afb57615afb615abe565b8060ff84160491505092915050565b60ff81811683821602908116908181146139f4576139f4614d43565b60ff82811682821603908111156116f5576116f5614d43565b600082615b4e57615b4e615abe565b500690565b604081526000615b666040830185614827565b82810360208401526135638185614827565b634e487b7160e01b600052603160045260246000fd5b604081526000615ba16040830185614827565b82810360208401526135638185614b53565b60ff81811683821601908111156116f5576116f5614d4356fea2646970667358221220637c3c223f61d207c632303ddd34ebab8391f230804366b195a35c08294e063464736f6c634300081c0033",
	"devdoc": {
		"errors": {
			"FailedDeployment()": [
				{
					"details": "The deployment failed."
				}
			],
			"InsufficientBalance(uint256,uint256)": [
				{
					"details": "The ETH balance of the account is not enough to perform the operation."
				}
			]
		},
		"kind": "dev",
		"methods": {
			"autoFulfillRequest(bytes32)": {
				"params": {
					"requestId": "Request ID to auto-fulfill"
				}
			},
			"createDao((string,string),uint256,(string,string,string,uint48,uint32,uint256,uint256),address[],uint256[])": {
				"details": "Arrays _to and _amounts must have the same lengthEmits DaoCreated event upon successful creation",
				"params": {
					"_amounts": "Array of token amounts corresponding to _to addresses",
					"_governorParams": "Parameters for the governor contract",
					"_minDelay": "Minimum delay for timelock operations (in seconds)",
					"_to": "Array of addresses to receive initial token allocation",
					"_tokenParams": "Parameters for the governance token"
				}
			},
			"getImplementations()": {
				"returns": {
					"_governor": "Governor implementation address",
					"_governorToken": "Governor token implementation address",
					"_timelock": "Timelock implementation address",
					"_verifier": "ZK verifier implementation address"
				}
			},
			"getNonce(address)": {
				"params": {
					"account": "User address"
				},
				"returns": {
					"_0": "Current nonce value"
				}
			},
			"mockFulfillRequest(bytes32,string)": {
				"params": {
					"_cids": "Merkle root for the proposal",
					"_requestId": "The request ID to fulfill"
				}
			},
			"mockFulfillRequestWithError(bytes32,string)": {
				"params": {
					"errorMessage": "Error message to return",
					"requestId": "The request ID to fulfill with error"
				}
			},
			"queueProposal(uint256,uint256,uint256,address)": {
				"details": "Only callable by registered Governor contracts",
				"params": {
					"daoId": "DAO identifier",
					"proposalId": "Proposal identifier within the DAO",
					"snapshot": "Block number snapshot for the proposal"
				}
			},
			"setPredefinedResponse(bytes32,bytes,bytes)": {
				"params": {
					"err": "Error data",
					"requestId": "Request ID",
					"response": "Response data"
				}
			}
		},
		"version": 1
	},
	"userdoc": {
		"errors": {
			"DAO_NOT_FOUND(uint256)": [
				{
					"notice": "====================== ======= ZK DAO ======= ======================"
				}
			],
			"INSUFFICIENT_ALLOWANCE()": [
				{
					"notice": "====================== ====== Generic ======= ======================"
				}
			],
			"INVALID_VOTE_TYPE()": [
				{
					"notice": "====================== ====== Governor ====== ======================"
				}
			],
			"UnexpectedRequestID(bytes32)": [
				{
					"notice": "====================== ======= Errors ======= ======================"
				}
			]
		},
		"events": {
			"DaoCreated(uint256,address,address,address,address)": {
				"notice": "====================== ======= Events ======= ======================"
			},
			"ProposalQueued(address,uint256,uint256,uint256,address)": {
				"notice": "====================== ======= Events ======= ======================"
			},
			"Response(bytes32,bytes,bytes)": {
				"notice": "====================== ======= Events ======= ======================"
			}
		},
		"kind": "user",
		"methods": {
			"advanceTime(uint256)": {
				"notice": "Advance mock time by specified seconds"
			},
			"autoFulfillRequest(bytes32)": {
				"notice": "Auto-fulfill request with predefined response"
			},
			"automationEnabled()": {
				"notice": "========================= === Storage Variables === ========================="
			},
			"batchQueueProposals(address[],uint256[],uint256[],address[])": {
				"notice": "Batch queue multiple proposals for testing"
			},
			"checkUpkeep(bytes)": {
				"notice": "========================== ===== View Functions ===== =========================="
			},
			"cleanupQueue()": {
				"notice": "Remove processed proposals from queue"
			},
			"clearProcessedProposals()": {
				"notice": "Clear all processed proposals (for testing)"
			},
			"clearQueue()": {
				"notice": "Clear the entire queue (for testing)"
			},
			"constructor": {
				"notice": "========================= ====== Constructor ====== ========================="
			},
			"createDao((string,string),uint256,(string,string,string,uint48,uint32,uint256,uint256),address[],uint256[])": {
				"notice": "Create a new DAO with governance token, timelock, and governor"
			},
			"getAutomationStats()": {
				"notice": "Get automation stats for monitoring"
			},
			"getDao(uint256)": {
				"notice": "========================== ===== View Functions ===== =========================="
			},
			"getImplementations()": {
				"notice": "Get all implementation contract addresses"
			},
			"getNonce(address)": {
				"notice": "Get user's current nonce for deterministic address generation"
			},
			"getRequestCounter()": {
				"notice": "Get request counter for testing"
			},
			"isRequestPending(bytes32)": {
				"notice": "Check if request is pending"
			},
			"manualUpkeep()": {
				"notice": "Manually trigger upkeep (simulates Chainlink calling performUpkeep)"
			},
			"mockFulfillRequest(bytes32,string)": {
				"notice": "Mock function to simulate successful response"
			},
			"mockFulfillRequestWithError(bytes32,string)": {
				"notice": "Mock function to simulate error response"
			},
			"payForDaoCreation((string,string),uint256,(string,string,string,uint48,uint32,uint256,uint256),address[],uint256[],uint256)": {
				"notice": "================================= == External / Public Functions == ================================="
			},
			"performUpkeep(bytes)": {
				"notice": "================================= == External / Public Functions == ================================="
			},
			"queueProposal(uint256,uint256,uint256,address)": {
				"notice": "Queue a proposal for processing (called by Governor contracts)"
			},
			"s_lastRequestId()": {
				"notice": "========================= === Storage Variables === ========================="
			},
			"sendRequestCBOR(bytes,uint64,uint32,bytes32)": {
				"notice": "Send a pre-encoded CBOR request (mocked)"
			},
			"setAutomationRegistry(address)": {
				"notice": "Set automation registry address"
			},
			"setForceUpkeepNeeded(bool)": {
				"notice": "Force upkeep to be needed for testing"
			},
			"setMockBlockTimestamp(uint256)": {
				"notice": "Set mock block timestamp for testing time-dependent logic"
			},
			"setPredefinedResponse(bytes32,bytes,bytes)": {
				"notice": "Set predefined response for a request (for advanced testing)"
			},
			"simulateAutomationCycle()": {
				"notice": "Simulate automated upkeep cycle"
			},
			"toggleAutomation(bool)": {
				"notice": "Toggle automation on/off for testing"
			},
			"transferOwnership(address)": {
				"notice": "Transfer ownership"
			}
		},
		"version": 1
	},
	"storageLayout": {
		"storage": [
			{
				"astId": 27721,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "s_lastRequestId",
				"offset": 0,
				"slot": "0",
				"type": "t_bytes32"
			},
			{
				"astId": 27723,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "s_lastResponse",
				"offset": 0,
				"slot": "1",
				"type": "t_bytes_storage"
			},
			{
				"astId": 27725,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "s_lastError",
				"offset": 0,
				"slot": "2",
				"type": "t_bytes_storage"
			},
			{
				"astId": 27729,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "queue",
				"offset": 0,
				"slot": "3",
				"type": "t_array(t_struct(Proposal)27696_storage)dyn_storage"
			},
			{
				"astId": 27731,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "owner",
				"offset": 0,
				"slot": "4",
				"type": "t_address"
			},
			{
				"astId": 27733,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "requestCounter",
				"offset": 0,
				"slot": "5",
				"type": "t_uint256"
			},
			{
				"astId": 27741,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "proposals",
				"offset": 0,
				"slot": "6",
				"type": "t_mapping(t_contract(IGovernor)27145,t_mapping(t_uint256,t_struct(Proposal)27696_storage))"
			},
			{
				"astId": 27747,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "pendingProposals",
				"offset": 0,
				"slot": "7",
				"type": "t_mapping(t_bytes32,t_array(t_struct(Proposal)27696_storage)dyn_storage)"
			},
			{
				"astId": 27751,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "mockResponses",
				"offset": 0,
				"slot": "8",
				"type": "t_mapping(t_bytes32,t_bytes_storage)"
			},
			{
				"astId": 27755,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "mockErrors",
				"offset": 0,
				"slot": "9",
				"type": "t_mapping(t_bytes32,t_bytes_storage)"
			},
			{
				"astId": 27759,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "pendingRequests",
				"offset": 0,
				"slot": "10",
				"type": "t_mapping(t_bytes32,t_bool)"
			},
			{
				"astId": 28736,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "automationEnabled",
				"offset": 0,
				"slot": "11",
				"type": "t_bool"
			},
			{
				"astId": 28738,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "automationRegistry",
				"offset": 1,
				"slot": "11",
				"type": "t_address"
			},
			{
				"astId": 28740,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "lastUpkeepTimestamp",
				"offset": 0,
				"slot": "12",
				"type": "t_uint256"
			},
			{
				"astId": 28742,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "upkeepCounter",
				"offset": 0,
				"slot": "13",
				"type": "t_uint256"
			},
			{
				"astId": 28744,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "forceUpkeepNeeded",
				"offset": 0,
				"slot": "14",
				"type": "t_bool"
			},
			{
				"astId": 28746,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "mockBlockTimestamp",
				"offset": 0,
				"slot": "15",
				"type": "t_uint256"
			},
			{
				"astId": 30035,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "nonces",
				"offset": 0,
				"slot": "16",
				"type": "t_mapping(t_address,t_uint256)"
			},
			{
				"astId": 30040,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "daos",
				"offset": 0,
				"slot": "17",
				"type": "t_mapping(t_uint256,t_struct(DAO)27286_storage)"
			},
			{
				"astId": 30044,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "daoIds",
				"offset": 0,
				"slot": "18",
				"type": "t_mapping(t_address,t_uint256)"
			},
			{
				"astId": 30047,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "price",
				"offset": 0,
				"slot": "19",
				"type": "t_uint256"
			},
			{
				"astId": 30049,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "daoCount",
				"offset": 0,
				"slot": "20",
				"type": "t_uint256"
			},
			{
				"astId": 30051,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "factory",
				"offset": 0,
				"slot": "21",
				"type": "t_address"
			},
			{
				"astId": 30054,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "governorToken",
				"offset": 0,
				"slot": "22",
				"type": "t_contract(IGovernorToken)27180"
			},
			{
				"astId": 30057,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "timelock",
				"offset": 0,
				"slot": "23",
				"type": "t_contract(ITimeLock)27243"
			},
			{
				"astId": 30060,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "verifier",
				"offset": 0,
				"slot": "24",
				"type": "t_contract(IVerifier)24860"
			},
			{
				"astId": 30063,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "governor",
				"offset": 0,
				"slot": "25",
				"type": "t_contract(IGovernor)27145"
			},
			{
				"astId": 30066,
				"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
				"label": "linkToken",
				"offset": 0,
				"slot": "26",
				"type": "t_contract(IERC20)9387"
			}
		],
		"types": {
			"t_address": {
				"encoding": "inplace",
				"label": "address",
				"numberOfBytes": "20"
			},
			"t_array(t_struct(Proposal)27696_storage)dyn_storage": {
				"base": "t_struct(Proposal)27696_storage",
				"encoding": "dynamic_array",
				"label": "struct MockConsumer.Proposal[]",
				"numberOfBytes": "32"
			},
			"t_bool": {
				"encoding": "inplace",
				"label": "bool",
				"numberOfBytes": "1"
			},
			"t_bytes32": {
				"encoding": "inplace",
				"label": "bytes32",
				"numberOfBytes": "32"
			},
			"t_bytes_storage": {
				"encoding": "bytes",
				"label": "bytes",
				"numberOfBytes": "32"
			},
			"t_contract(IERC20)9387": {
				"encoding": "inplace",
				"label": "contract IERC20",
				"numberOfBytes": "20"
			},
			"t_contract(IGovernor)27145": {
				"encoding": "inplace",
				"label": "contract IGovernor",
				"numberOfBytes": "20"
			},
			"t_contract(IGovernorToken)27180": {
				"encoding": "inplace",
				"label": "contract IGovernorToken",
				"numberOfBytes": "20"
			},
			"t_contract(ITimeLock)27243": {
				"encoding": "inplace",
				"label": "contract ITimeLock",
				"numberOfBytes": "20"
			},
			"t_contract(IVerifier)24860": {
				"encoding": "inplace",
				"label": "contract IVerifier",
				"numberOfBytes": "20"
			},
			"t_mapping(t_address,t_uint256)": {
				"encoding": "mapping",
				"key": "t_address",
				"label": "mapping(address => uint256)",
				"numberOfBytes": "32",
				"value": "t_uint256"
			},
			"t_mapping(t_bytes32,t_array(t_struct(Proposal)27696_storage)dyn_storage)": {
				"encoding": "mapping",
				"key": "t_bytes32",
				"label": "mapping(bytes32 => struct MockConsumer.Proposal[])",
				"numberOfBytes": "32",
				"value": "t_array(t_struct(Proposal)27696_storage)dyn_storage"
			},
			"t_mapping(t_bytes32,t_bool)": {
				"encoding": "mapping",
				"key": "t_bytes32",
				"label": "mapping(bytes32 => bool)",
				"numberOfBytes": "32",
				"value": "t_bool"
			},
			"t_mapping(t_bytes32,t_bytes_storage)": {
				"encoding": "mapping",
				"key": "t_bytes32",
				"label": "mapping(bytes32 => bytes)",
				"numberOfBytes": "32",
				"value": "t_bytes_storage"
			},
			"t_mapping(t_contract(IGovernor)27145,t_mapping(t_uint256,t_struct(Proposal)27696_storage))": {
				"encoding": "mapping",
				"key": "t_contract(IGovernor)27145",
				"label": "mapping(contract IGovernor => mapping(uint256 => struct MockConsumer.Proposal))",
				"numberOfBytes": "32",
				"value": "t_mapping(t_uint256,t_struct(Proposal)27696_storage)"
			},
			"t_mapping(t_uint256,t_struct(DAO)27286_storage)": {
				"encoding": "mapping",
				"key": "t_uint256",
				"label": "mapping(uint256 => struct IZKDAO.DAO)",
				"numberOfBytes": "32",
				"value": "t_struct(DAO)27286_storage"
			},
			"t_mapping(t_uint256,t_struct(Proposal)27696_storage)": {
				"encoding": "mapping",
				"key": "t_uint256",
				"label": "mapping(uint256 => struct MockConsumer.Proposal)",
				"numberOfBytes": "32",
				"value": "t_struct(Proposal)27696_storage"
			},
			"t_struct(DAO)27286_storage": {
				"encoding": "inplace",
				"label": "struct IZKDAO.DAO",
				"members": [
					{
						"astId": 27277,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "token",
						"offset": 0,
						"slot": "0",
						"type": "t_contract(IGovernorToken)27180"
					},
					{
						"astId": 27280,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "timelock",
						"offset": 0,
						"slot": "1",
						"type": "t_contract(ITimeLock)27243"
					},
					{
						"astId": 27283,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "governor",
						"offset": 0,
						"slot": "2",
						"type": "t_contract(IGovernor)27145"
					},
					{
						"astId": 27285,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "deployer",
						"offset": 0,
						"slot": "3",
						"type": "t_address"
					}
				],
				"numberOfBytes": "128"
			},
			"t_struct(Proposal)27696_storage": {
				"encoding": "inplace",
				"label": "struct MockConsumer.Proposal",
				"members": [
					{
						"astId": 27683,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "dao",
						"offset": 0,
						"slot": "0",
						"type": "t_contract(IGovernor)27145"
					},
					{
						"astId": 27685,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "daoId",
						"offset": 0,
						"slot": "1",
						"type": "t_uint256"
					},
					{
						"astId": 27687,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "proposalId",
						"offset": 0,
						"slot": "2",
						"type": "t_uint256"
					},
					{
						"astId": 27689,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "snapshot",
						"offset": 0,
						"slot": "3",
						"type": "t_uint256"
					},
					{
						"astId": 27691,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "voteToken",
						"offset": 0,
						"slot": "4",
						"type": "t_address"
					},
					{
						"astId": 27693,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "queued",
						"offset": 20,
						"slot": "4",
						"type": "t_bool"
					},
					{
						"astId": 27695,
						"contract": "contracts/core/mocks/MockZKDAO.sol:MockZKDAO",
						"label": "executed",
						"offset": 21,
						"slot": "4",
						"type": "t_bool"
					}
				],
				"numberOfBytes": "160"
			},
			"t_uint256": {
				"encoding": "inplace",
				"label": "uint256",
				"numberOfBytes": "32"
			}
		}
	}
}
