{
	"address": "0x0F2742DB0a81168ca621CddA1AcA66E87F4579a4",
	"abi": [
		{
			"inputs": [],
			"name": "AMOUNT_MISMATCH",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "daoId",
					"type": "uint256"
				}
			],
			"name": "DAONotFound",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "daoId",
					"type": "uint256"
				}
			],
			"name": "DAO_NOT_FOUND",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "DOUBLE_VOTE",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "uint64",
					"name": "destinationChainSelector",
					"type": "uint64"
				}
			],
			"name": "DestinationChainNotAllowlisted",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "EmptyArgs",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "EmptySecrets",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "EmptySource",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "FailedDeployment",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "owner",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "target",
					"type": "address"
				},
				{
					"internalType": "uint256",
					"name": "value",
					"type": "uint256"
				}
			],
			"name": "FailedToWithdrawEth",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INSUFFICIENT_ALLOWANCE",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INSUFFICIENT_FUNDS",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INVALID_NULLIFIER",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INVALID_PROPOSAL_ID",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "INVALID_VOTE_TYPE",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "balance",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "needed",
					"type": "uint256"
				}
			],
			"name": "InsufficientBalance",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "InvalidArrayLength",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "InvalidParameters",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "InvalidReceiverAddress",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "MISMATCH",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "NoInlineSecrets",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "currentBalance",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "calculatedfee",
					"type": "uint256"
				}
			],
			"name": "NotEnoughBalance",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "NothingToWithdraw",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "OnlyRouterCanFulfill",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "UNAUTHORIZED",
			"type": "error"
		},
		{
			"inputs": [
				{
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				}
			],
			"name": "UNEXPECTED_REQUEST_ID",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "UnauthorizedCaller",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "VOTING_CLOSED",
			"type": "error"
		},
		{
			"inputs": [],
			"name": "ZK_PROOF_FAILED",
			"type": "error"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "id",
					"type": "uint256"
				},
				{
					"indexed": true,
					"internalType": "address",
					"name": "deployer",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "token",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "timelock",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "governor",
					"type": "address"
				}
			],
			"name": "DaoCreated",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "symbol",
							"type": "string"
						}
					],
					"indexed": false,
					"internalType": "struct ZKDAO.GovernorTokenParams",
					"name": "tokenParams",
					"type": "tuple"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "minDelay",
					"type": "uint256"
				},
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "uint48",
							"name": "votingDelay",
							"type": "uint48"
						},
						{
							"internalType": "uint32",
							"name": "votingPeriod",
							"type": "uint32"
						},
						{
							"internalType": "uint256",
							"name": "proposalThreshold",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "quorumFraction",
							"type": "uint256"
						},
						{
							"internalType": "string",
							"name": "description",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "logo",
							"type": "string"
						}
					],
					"indexed": false,
					"internalType": "struct ZKDAO.GovernorParams",
					"name": "governorParams",
					"type": "tuple"
				},
				{
					"indexed": false,
					"internalType": "address[]",
					"name": "to",
					"type": "address[]"
				},
				{
					"indexed": false,
					"internalType": "uint256[]",
					"name": "amounts",
					"type": "uint256[]"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "value",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "creator",
					"type": "address"
				}
			],
			"name": "PaidForDaoCreation",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "address",
					"name": "dao",
					"type": "address"
				},
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "daoId",
					"type": "uint256"
				},
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "proposalId",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "snapshot",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "proposalBlock",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "voteToken",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "string[]",
					"name": "args",
					"type": "string[]"
				}
			],
			"name": "ProposalDequeued",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "address",
					"name": "dao",
					"type": "address"
				},
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "daoId",
					"type": "uint256"
				},
				{
					"indexed": true,
					"internalType": "uint256",
					"name": "proposalId",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "snapshot",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "proposalBlock",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "voteToken",
					"type": "address"
				}
			],
			"name": "ProposalQueued",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "bytes32",
					"name": "id",
					"type": "bytes32"
				}
			],
			"name": "RequestFulfilled",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "bytes32",
					"name": "id",
					"type": "bytes32"
				}
			],
			"name": "RequestSent",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				},
				{
					"indexed": false,
					"internalType": "bytes",
					"name": "response",
					"type": "bytes"
				},
				{
					"indexed": false,
					"internalType": "bytes",
					"name": "err",
					"type": "bytes"
				}
			],
			"name": "Response",
			"type": "event"
		},
		{
			"anonymous": false,
			"inputs": [
				{
					"indexed": true,
					"internalType": "bytes32",
					"name": "messageId",
					"type": "bytes32"
				},
				{
					"indexed": true,
					"internalType": "uint64",
					"name": "destinationChainSelector",
					"type": "uint64"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "receiver",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "token",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "tokenAmount",
					"type": "uint256"
				},
				{
					"indexed": false,
					"internalType": "address",
					"name": "feeToken",
					"type": "address"
				},
				{
					"indexed": false,
					"internalType": "uint256",
					"name": "fee",
					"type": "uint256"
				}
			],
			"name": "TokensTransferred",
			"type": "event"
		},
		{
			"inputs": [],
			"name": "NATIVE",
			"outputs": [
				{
					"internalType": "address",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint64",
					"name": "_destinationChainSelector",
					"type": "uint64"
				},
				{
					"internalType": "bool",
					"name": "allowed",
					"type": "bool"
				}
			],
			"name": "allowlistDestinationChain",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint64",
					"name": "",
					"type": "uint64"
				}
			],
			"name": "allowlistedChains",
			"outputs": [
				{
					"internalType": "bool",
					"name": "",
					"type": "bool"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes",
					"name": "",
					"type": "bytes"
				}
			],
			"name": "checkUpkeep",
			"outputs": [
				{
					"internalType": "bool",
					"name": "upkeepNeeded",
					"type": "bool"
				},
				{
					"internalType": "bytes",
					"name": "performData",
					"type": "bytes"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "symbol",
							"type": "string"
						}
					],
					"internalType": "struct ZKDAO.GovernorTokenParams",
					"name": "_tokenParams",
					"type": "tuple"
				},
				{
					"internalType": "uint256",
					"name": "_minDelay",
					"type": "uint256"
				},
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "uint48",
							"name": "votingDelay",
							"type": "uint48"
						},
						{
							"internalType": "uint32",
							"name": "votingPeriod",
							"type": "uint32"
						},
						{
							"internalType": "uint256",
							"name": "proposalThreshold",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "quorumFraction",
							"type": "uint256"
						},
						{
							"internalType": "string",
							"name": "description",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "logo",
							"type": "string"
						}
					],
					"internalType": "struct ZKDAO.GovernorParams",
					"name": "_governorParams",
					"type": "tuple"
				},
				{
					"internalType": "address[]",
					"name": "_to",
					"type": "address[]"
				},
				{
					"internalType": "uint256[]",
					"name": "_amounts",
					"type": "uint256[]"
				},
				{
					"internalType": "address",
					"name": "creator",
					"type": "address"
				}
			],
			"name": "createDao",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_token",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_account",
					"type": "address"
				}
			],
			"name": "getBalance",
			"outputs": [],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_receiver",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_token",
					"type": "address"
				},
				{
					"internalType": "uint256",
					"name": "_amount",
					"type": "uint256"
				}
			],
			"name": "getCcipFee",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getCcipRouter",
			"outputs": [
				{
					"internalType": "contract IRouterClient",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "id",
					"type": "uint256"
				}
			],
			"name": "getDao",
			"outputs": [
				{
					"components": [
						{
							"internalType": "uint256",
							"name": "id",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "createdAt",
							"type": "uint256"
						},
						{
							"internalType": "address",
							"name": "creator",
							"type": "address"
						},
						{
							"internalType": "contract IGovernorToken",
							"name": "token",
							"type": "address"
						},
						{
							"internalType": "contract ITimeLock",
							"name": "timelock",
							"type": "address"
						},
						{
							"internalType": "contract IGovernor",
							"name": "governor",
							"type": "address"
						},
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "description",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "logo",
							"type": "string"
						}
					],
					"internalType": "struct ZKDAO.Dao",
					"name": "",
					"type": "tuple"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getDaoCounter",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "account",
					"type": "address"
				}
			],
			"name": "getDaoId",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getDestinationChainSelector",
			"outputs": [
				{
					"internalType": "uint64",
					"name": "",
					"type": "uint64"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getDonID",
			"outputs": [
				{
					"internalType": "bytes32",
					"name": "",
					"type": "bytes32"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getFactory",
			"outputs": [
				{
					"internalType": "address",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getGasLimit",
			"outputs": [
				{
					"internalType": "uint32",
					"name": "",
					"type": "uint32"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getImplementations",
			"outputs": [
				{
					"internalType": "address",
					"name": "_factory",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_linkToken",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_governorToken",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_timelock",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_governor",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_verifier",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getLinkToken",
			"outputs": [
				{
					"internalType": "contract IERC20",
					"name": "",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getNonce",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getPrice",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getQueue",
			"outputs": [
				{
					"components": [
						{
							"internalType": "contract IGovernor",
							"name": "dao",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "voteToken",
							"type": "address"
						},
						{
							"internalType": "uint256",
							"name": "daoId",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "proposalId",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "snapshot",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "proposalBlock",
							"type": "uint256"
						},
						{
							"internalType": "bool",
							"name": "queued",
							"type": "bool"
						},
						{
							"internalType": "bool",
							"name": "executed",
							"type": "bool"
						}
					],
					"internalType": "struct ConsumerUpgradable.Proposal[]",
					"name": "",
					"type": "tuple[]"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getQueueWithTimeLeft",
			"outputs": [
				{
					"components": [
						{
							"internalType": "contract IGovernor",
							"name": "dao",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "voteToken",
							"type": "address"
						},
						{
							"internalType": "uint256",
							"name": "daoId",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "proposalId",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "snapshot",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "proposalBlock",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "timeLeft",
							"type": "uint256"
						},
						{
							"internalType": "bool",
							"name": "queued",
							"type": "bool"
						},
						{
							"internalType": "bool",
							"name": "executed",
							"type": "bool"
						}
					],
					"internalType": "struct ConsumerUpgradable.ProposalWithTimeLeft[]",
					"name": "_allProposals",
					"type": "tuple[]"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getRequestCounter",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getSubscriptionId",
			"outputs": [
				{
					"internalType": "uint64",
					"name": "",
					"type": "uint64"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "getTreasury",
			"outputs": [
				{
					"internalType": "uint256",
					"name": "",
					"type": "uint256"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				},
				{
					"internalType": "bytes",
					"name": "response",
					"type": "bytes"
				},
				{
					"internalType": "bytes",
					"name": "err",
					"type": "bytes"
				}
			],
			"name": "handleOracleFulfillment",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"components": [
						{
							"internalType": "address",
							"name": "governorToken",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "timelock",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "governor",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "verifier",
							"type": "address"
						}
					],
					"internalType": "struct ZKDAO.Implementations",
					"name": "_implementations",
					"type": "tuple"
				},
				{
					"components": [
						{
							"internalType": "address",
							"name": "linkToken",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "ccipRouter",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "ccipBnmToken",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "ccipLnmToken",
							"type": "address"
						},
						{
							"internalType": "address",
							"name": "usdcToken",
							"type": "address"
						},
						{
							"internalType": "uint64",
							"name": "destinationChainSelector",
							"type": "uint64"
						}
					],
					"internalType": "struct ZKDAO.CcipParams",
					"name": "_ccipParams",
					"type": "tuple"
				},
				{
					"internalType": "address",
					"name": "_factory",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_functionsRouter",
					"type": "address"
				},
				{
					"internalType": "uint64",
					"name": "_subscriptionId",
					"type": "uint64"
				},
				{
					"internalType": "uint32",
					"name": "_gasLimit",
					"type": "uint32"
				},
				{
					"internalType": "bytes32",
					"name": "_donID",
					"type": "bytes32"
				},
				{
					"internalType": "string",
					"name": "_source",
					"type": "string"
				}
			],
			"name": "initialize",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "symbol",
							"type": "string"
						}
					],
					"internalType": "struct ZKDAO.GovernorTokenParams",
					"name": "_tokenParams",
					"type": "tuple"
				},
				{
					"internalType": "uint256",
					"name": "_minDelay",
					"type": "uint256"
				},
				{
					"components": [
						{
							"internalType": "string",
							"name": "name",
							"type": "string"
						},
						{
							"internalType": "uint48",
							"name": "votingDelay",
							"type": "uint48"
						},
						{
							"internalType": "uint32",
							"name": "votingPeriod",
							"type": "uint32"
						},
						{
							"internalType": "uint256",
							"name": "proposalThreshold",
							"type": "uint256"
						},
						{
							"internalType": "uint256",
							"name": "quorumFraction",
							"type": "uint256"
						},
						{
							"internalType": "string",
							"name": "description",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "logo",
							"type": "string"
						}
					],
					"internalType": "struct ZKDAO.GovernorParams",
					"name": "_governorParams",
					"type": "tuple"
				},
				{
					"internalType": "address[]",
					"name": "_to",
					"type": "address[]"
				},
				{
					"internalType": "uint256[]",
					"name": "_amounts",
					"type": "uint256[]"
				},
				{
					"internalType": "uint256",
					"name": "_value",
					"type": "uint256"
				}
			],
			"name": "payForDaoCreation",
			"outputs": [],
			"stateMutability": "payable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes",
					"name": "performData",
					"type": "bytes"
				}
			],
			"name": "performUpkeep",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "daoId",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "proposalId",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "snapshot",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "proposalBlock",
					"type": "uint256"
				},
				{
					"internalType": "address",
					"name": "voteToken",
					"type": "address"
				}
			],
			"name": "queueProposal",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_token",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_to",
					"type": "address"
				}
			],
			"name": "recoverFunds",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "s_lastError",
			"outputs": [
				{
					"internalType": "bytes",
					"name": "",
					"type": "bytes"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "s_lastRequestId",
			"outputs": [
				{
					"internalType": "bytes32",
					"name": "",
					"type": "bytes32"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "s_lastResponse",
			"outputs": [
				{
					"internalType": "bytes",
					"name": "",
					"type": "bytes"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes",
					"name": "_request",
					"type": "bytes"
				},
				{
					"internalType": "uint64",
					"name": "_subscriptionId",
					"type": "uint64"
				},
				{
					"internalType": "uint32",
					"name": "_gasLimit",
					"type": "uint32"
				},
				{
					"internalType": "bytes32",
					"name": "_donID",
					"type": "bytes32"
				}
			],
			"name": "sendRequestCBOR",
			"outputs": [
				{
					"internalType": "bytes32",
					"name": "requestId",
					"type": "bytes32"
				}
			],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes32",
					"name": "_donID",
					"type": "bytes32"
				}
			],
			"name": "setDonID",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_factory",
					"type": "address"
				}
			],
			"name": "setFactory",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint32",
					"name": "_gasLimit",
					"type": "uint32"
				}
			],
			"name": "setGasLimit",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_governor",
					"type": "address"
				}
			],
			"name": "setGovernor",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_governorToken",
					"type": "address"
				}
			],
			"name": "setGovernorToken",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint256",
					"name": "_price",
					"type": "uint256"
				}
			],
			"name": "setPrice",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "string",
					"name": "_source",
					"type": "string"
				}
			],
			"name": "setSource",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "uint64",
					"name": "_subscriptionId",
					"type": "uint64"
				}
			],
			"name": "setSubscriptionId",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_timelock",
					"type": "address"
				}
			],
			"name": "setTimelock",
			"outputs": [],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "source",
			"outputs": [
				{
					"internalType": "string",
					"name": "",
					"type": "string"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_receiver",
					"type": "address"
				},
				{
					"internalType": "address",
					"name": "_token",
					"type": "address"
				},
				{
					"internalType": "uint256",
					"name": "_amount",
					"type": "uint256"
				},
				{
					"internalType": "uint256",
					"name": "_fee",
					"type": "uint256"
				}
			],
			"name": "transferCrosschain",
			"outputs": [
				{
					"internalType": "bytes32",
					"name": "messageId",
					"type": "bytes32"
				}
			],
			"stateMutability": "nonpayable",
			"type": "function"
		},
		{
			"stateMutability": "payable",
			"type": "receive"
		}
	],
	"numDeployments": 4,
	"solcInputHash": "60b0d40accb152e3816fed52aab69c8e",
	"metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AMOUNT_MISMATCH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"}],\"name\":\"DAONotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"}],\"name\":\"DAO_NOT_FOUND\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DOUBLE_VOTE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"}],\"name\":\"DestinationChainNotAllowlisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyArgs\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptySecrets\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptySource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedDeployment\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FailedToWithdrawEth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_ALLOWANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_FUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_NULLIFIER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PROPOSAL_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_VOTE_TYPE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReceiverAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoInlineSecrets\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calculatedfee\",\"type\":\"uint256\"}],\"name\":\"NotEnoughBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToWithdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRouterCanFulfill\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"UNEXPECTED_REQUEST_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VOTING_CLOSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZK_PROOF_FAILED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"timelock\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"DaoCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct ZKDAO.GovernorTokenParams\",\"name\":\"tokenParams\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minDelay\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint48\",\"name\":\"votingDelay\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"votingPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumFraction\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logo\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct ZKDAO.GovernorParams\",\"name\":\"governorParams\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"PaidForDaoCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voteToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"args\",\"type\":\"string[]\"}],\"name\":\"ProposalDequeued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voteToken\",\"type\":\"address\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"RequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"RequestSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"err\",\"type\":\"bytes\"}],\"name\":\"Response\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"TokensTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NATIVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"allowlistDestinationChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"allowlistedChains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct ZKDAO.GovernorTokenParams\",\"name\":\"_tokenParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_minDelay\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint48\",\"name\":\"votingDelay\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"votingPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumFraction\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logo\",\"type\":\"string\"}],\"internalType\":\"struct ZKDAO.GovernorParams\",\"name\":\"_governorParams\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"createDao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getCcipFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCcipRouter\",\"outputs\":[{\"internalType\":\"contract IRouterClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getDao\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"contract IGovernorToken\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ITimeLock\",\"name\":\"timelock\",\"type\":\"address\"},{\"internalType\":\"contract IGovernor\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logo\",\"type\":\"string\"}],\"internalType\":\"struct ZKDAO.Dao\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDaoCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getDaoId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDestinationChainSelector\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDonID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGasLimit\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_linkToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governorToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timelock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLinkToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQueue\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IGovernor\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"voteToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"queued\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"internalType\":\"struct ConsumerUpgradable.Proposal[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQueueWithTimeLeft\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IGovernor\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"voteToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLeft\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"queued\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"internalType\":\"struct ConsumerUpgradable.ProposalWithTimeLeft[]\",\"name\":\"_allProposals\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequestCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubscriptionId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTreasury\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"err\",\"type\":\"bytes\"}],\"name\":\"handleOracleFulfillment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"governorToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"timelock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"internalType\":\"struct ZKDAO.Implementations\",\"name\":\"_implementations\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"linkToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ccipRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ccipBnmToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ccipLnmToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdcToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"}],\"internalType\":\"struct ZKDAO.CcipParams\",\"name\":\"_ccipParams\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_functionsRouter\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_donID\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_source\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct ZKDAO.GovernorTokenParams\",\"name\":\"_tokenParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_minDelay\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint48\",\"name\":\"votingDelay\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"votingPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumFraction\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logo\",\"type\":\"string\"}],\"internalType\":\"struct ZKDAO.GovernorParams\",\"name\":\"_governorParams\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"payForDaoCreation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daoId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voteToken\",\"type\":\"address\"}],\"name\":\"queueProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"recoverFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_lastError\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_lastRequestId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_lastResponse\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_donID\",\"type\":\"bytes32\"}],\"name\":\"sendRequestCBOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_donID\",\"type\":\"bytes32\"}],\"name\":\"setDonID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_gasLimit\",\"type\":\"uint32\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"}],\"name\":\"setGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governorToken\",\"type\":\"address\"}],\"name\":\"setGovernorToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_source\",\"type\":\"string\"}],\"name\":\"setSource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_subscriptionId\",\"type\":\"uint64\"}],\"name\":\"setSubscriptionId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_timelock\",\"type\":\"address\"}],\"name\":\"setTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"source\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"transferCrosschain\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"errors\":{\"FailedDeployment()\":[{\"details\":\"The deployment failed.\"}],\"InsufficientBalance(uint256,uint256)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}]},\"kind\":\"dev\",\"methods\":{\"handleOracleFulfillment(bytes32,bytes,bytes)\":{\"details\":\"Either response or error parameter will be set, but never both.\",\"params\":{\"err\":\"Aggregated error either from the request's source code or from the execution pipeline.\",\"requestId\":\"The requestId returned by FunctionsClient.sendRequest().\",\"response\":\"Aggregated response from the request's source code.\"}},\"performUpkeep(bytes)\":{\"details\":\"The input to this method should not be trusted, and the caller of the method should not even be restricted to any single registry. Anyone should be able call it, and the input should be validated, there is no guarantee that the data passed in is the performData returned from checkUpkeep. This could happen due to malicious keepers, racing keepers, or simply a state change while the performUpkeep transaction is waiting for confirmation. Always validate the data passed in.\",\"params\":{\"performData\":\"is the data which was passed back from the checkData simulation. If it is encoded, it can easily be decoded into other types by calling `abi.decode`. This data should not be trusted, and should be validated against the contract's current state.\"}},\"sendRequestCBOR(bytes,uint64,uint32,bytes32)\":{\"params\":{\"_donID\":\"ID of the job to be invoked\",\"_gasLimit\":\"The maximum amount of gas the request can consume\",\"_request\":\"CBOR-encoded request data\",\"_subscriptionId\":\"Billing ID\"},\"returns\":{\"requestId\":\"The ID of the sent request\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"DAO_NOT_FOUND(uint256)\":[{\"notice\":\"====================== ======= ZK DAO ======= ======================\"}],\"INSUFFICIENT_ALLOWANCE()\":[{\"notice\":\"====================== ====== Generic ======= ======================\"}],\"INVALID_VOTE_TYPE()\":[{\"notice\":\"====================== ====== Governor ====== ======================\"}],\"NotEnoughBalance(uint256,uint256)\":[{\"notice\":\"====================== ======= Errors ======= ======================\"}]},\"events\":{\"DaoCreated(uint256,address,address,address,address)\":{\"notice\":\"====================== ======= Events ======= ======================\"},\"ProposalQueued(address,uint256,uint256,uint256,uint256,address)\":{\"notice\":\"====================== ======= Events ======= ======================\"},\"Response(bytes32,bytes,bytes)\":{\"notice\":\"====================== ======= Events ======= ======================\"}},\"kind\":\"user\",\"methods\":{\"checkUpkeep(bytes)\":{\"notice\":\"========================== === External Functions === ==========================\"},\"getPrice()\":{\"notice\":\"========================== === External Functions === ==========================\"},\"getSubscriptionId()\":{\"notice\":\"========================== === External Functions === ==========================\"},\"handleOracleFulfillment(bytes32,bytes,bytes)\":{\"notice\":\"Chainlink Functions response handler called by the Functions Router during fullilment from the designated transmitter node in an OCR round.\"},\"initialize((address,address,address,address),(address,address,address,address,address,uint64),address,address,uint64,uint32,bytes32,string)\":{\"notice\":\"========================= ====== Initializer ====== =========================\"},\"performUpkeep(bytes)\":{\"notice\":\"method that is actually executed by the keepers, via the registry. The data returned by the checkUpkeep simulation will be passed into this method to actually be executed.\"},\"sendRequestCBOR(bytes,uint64,uint32,bytes32)\":{\"notice\":\"Send a pre-encoded CBOR request\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/ZKDAO.sol\":\"ZKDAO\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouterClient {\\n  error UnsupportedDestinationChain(uint64 destChainSelector);\\n  error InsufficientFeeTokenAmount();\\n  error InvalidMsgValue();\\n\\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\\n  /// @param destChainSelector The chain to check.\\n  /// @return supported is true if it is supported, false if not.\\n  function isChainSupported(\\n    uint64 destChainSelector\\n  ) external view returns (bool supported);\\n\\n  /// @param destinationChainSelector The destination chainSelector.\\n  /// @param message The cross-chain CCIP message including data and/or tokens.\\n  /// @return fee returns execution fee for the message.\\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\\n  /// @dev Reverts with appropriate reason upon invalid message.\\n  function getFee(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage memory message\\n  ) external view returns (uint256 fee);\\n\\n  /// @notice Request a message to be sent to the destination chain.\\n  /// @param destinationChainSelector The destination chain ID.\\n  /// @param message The cross-chain CCIP message including data and/or tokens.\\n  /// @return messageId The message ID.\\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept.\\n  /// the overpayment with no refund.\\n  /// @dev Reverts with appropriate reason upon invalid message.\\n  function ccipSend(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage calldata message\\n  ) external payable returns (bytes32);\\n}\\n\",\"keccak256\":\"0x21280104a988eb7022f8968b1672bafba80a74e59f5512415009dff9a37be46a\",\"license\":\"MIT\"},\"@chainlink/contracts-ccip/contracts/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\\n    bytes data; // Data payload.\\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2).\\n  }\\n\\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(\\n    EVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\\n  // for a chain.\\n  // Note: not available for Solana VM based chains.\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\\n\\n  /// @param gasLimit: gas limit for the callback on the destination chain.\\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\\n  /// enforced, meaning if the expected value is not set, the message request will revert.\\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\\n  struct GenericExtraArgsV2 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n  }\\n\\n  // Extra args tag for chains that use the Solana VM.\\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\\n\\n  struct SVMExtraArgsV1 {\\n    uint32 computeUnits;\\n    uint64 accountIsWritableBitmap;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\\n\\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\\n    + 32 // token_address\\n    + 4 // gas_amount\\n    + 4 // extra_data overhead\\n    + 32 // amount\\n    + 32 // size of the token lookup table account\\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\\n    + 32 // per-chain token pool config, not included in the token lookup table\\n    + 32 // per-chain token billing config, not always included in the token lookup table\\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\\n\\n  /// @dev Number of overhead accounts needed for message execution on SVM.\\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\\n\\n  /// @dev The size of each SVM account address in bytes.\\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\\n\\n  function _argsToBytes(\\n    GenericExtraArgsV2 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\\n  }\\n\\n  function _svmArgsToBytes(\\n    SVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\",\"keccak256\":\"0x7c736e12ebb1d0e3a0c99436eacfac14d16ec941843050c9a7d82a6bff5b35a1\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/automation/AutomationBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract AutomationBase {\\n  error OnlySimulatedBackend();\\n\\n  /**\\n   * @notice method that allows it to be simulated via eth_call by checking that\\n   * the sender is the zero address.\\n   */\\n  function _preventExecution() internal view {\\n    // solhint-disable-next-line avoid-tx-origin\\n    if (tx.origin != address(0) && tx.origin != address(0x1111111111111111111111111111111111111111)) {\\n      revert OnlySimulatedBackend();\\n    }\\n  }\\n\\n  /**\\n   * @notice modifier that allows it to be simulated via eth_call by checking\\n   * that the sender is the zero address.\\n   */\\n  modifier cannotExecute() {\\n    _preventExecution();\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x8c97744adc25cf30d1a2509bff6c0ddc9b36feb75f8e38c85d5c62b8ec773159\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {AutomationBase} from \\\"./AutomationBase.sol\\\";\\nimport {AutomationCompatibleInterface} from \\\"./interfaces/AutomationCompatibleInterface.sol\\\";\\n\\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}\\n\",\"keccak256\":\"0xce623f3e7fa4addf240032d2817b2b489ac08e79fae14a5cc5850ed3f1acddf8\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// solhint-disable-next-line interface-starts-with-i\\ninterface AutomationCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\",\"keccak256\":\"0xf504b227c442cd4ed31b336b7bd15cfcb23220c84c26e750975c7e7d959125aa\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/functions/dev/v1_X/interfaces/IFunctionsClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @title Chainlink Functions client interface.\\ninterface IFunctionsClient {\\n  /// @notice Chainlink Functions response handler called by the Functions Router\\n  /// during fullilment from the designated transmitter node in an OCR round.\\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\\n  /// @param response Aggregated response from the request's source code.\\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\\n  /// @dev Either response or error parameter will be set, but never both.\\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\\n}\\n\",\"keccak256\":\"0x6117b82e7c4eec44ce557b0fc8bc1ac5f49e5d160ac6d4485452d6aafdd762ff\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/functions/dev/v1_X/interfaces/IFunctionsRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {FunctionsResponse} from \\\"../libraries/FunctionsResponse.sol\\\";\\n\\n/// @title Chainlink Functions Router interface.\\ninterface IFunctionsRouter {\\n  /// @notice The identifier of the route to retrieve the address of the access control contract\\n  /// The access control contract controls which accounts can manage subscriptions\\n  /// @return id - bytes32 id that can be passed to the \\\"getContractById\\\" of the Router\\n  function getAllowListId() external view returns (bytes32);\\n\\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\\n  /// The access control contract controls which accounts can manage subscriptions\\n  function setAllowListId(bytes32 allowListId) external;\\n\\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\\n  /// @return adminFee\\n  function getAdminFee() external view returns (uint72 adminFee);\\n\\n  /// @notice Sends a request using the provided subscriptionId\\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\\n  /// a client can make requests from different contracts referencing the same subscription\\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\\n  /// @param dataVersion - Gas limit for the fulfillment callback\\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\\n  /// @param donId - An identifier used to determine which route to send the request along\\n  /// @return requestId - A unique request identifier\\n  function sendRequest(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) external returns (bytes32);\\n\\n  /// @notice Sends a request to the proposed contracts\\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\\n  /// a client can make requests from different contracts referencing the same subscription\\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\\n  /// @param dataVersion - Gas limit for the fulfillment callback\\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\\n  /// @param donId - An identifier used to determine which route to send the request along\\n  /// @return requestId - A unique request identifier\\n  function sendRequestToProposed(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) external returns (bytes32);\\n\\n  /// @notice Fulfill the request by:\\n  /// - calling back the data that the Oracle returned to the client contract\\n  /// - pay the DON for processing the request\\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\\n  /// @param response response data from DON consensus\\n  /// @param err error from DON consensus\\n  /// @param juelsPerGas - current rate of juels/gas\\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\\n  /// @param transmitter - The Node that transmitted the OCR report\\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\\n  /// @return fulfillResult -\\n  /// @return callbackGasCostJuels -\\n  function fulfill(\\n    bytes memory response,\\n    bytes memory err,\\n    uint96 juelsPerGas,\\n    uint96 costWithoutFulfillment,\\n    address transmitter,\\n    FunctionsResponse.Commitment memory commitment\\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\\n\\n  /// @notice Validate requested gas limit is below the subscription max.\\n  /// @param subscriptionId subscription ID\\n  /// @param callbackGasLimit desired callback gas limit\\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\\n\\n  /// @notice Get the current contract given an ID\\n  /// @param id A bytes32 identifier for the route\\n  /// @return contract The current contract address\\n  function getContractById(bytes32 id) external view returns (address);\\n\\n  /// @notice Get the proposed next contract given an ID\\n  /// @param id A bytes32 identifier for the route\\n  /// @return contract The current or proposed contract address\\n  function getProposedContractById(bytes32 id) external view returns (address);\\n\\n  /// @notice Return the latest proprosal set\\n  /// @return ids The identifiers of the contracts to update\\n  /// @return to The addresses of the contracts that will be updated to\\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\\n\\n  /// @notice Proposes one or more updates to the contract routes\\n  /// @dev Only callable by owner\\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\\n\\n  /// @notice Updates the current contract routes to the proposed contracts\\n  /// @dev Only callable by owner\\n  function updateContracts() external;\\n\\n  /// @dev Puts the system into an emergency stopped state.\\n  /// @dev Only callable by owner\\n  function pause() external;\\n\\n  /// @dev Takes the system out of an emergency stopped state.\\n  /// @dev Only callable by owner\\n  function unpause() external;\\n}\\n\",\"keccak256\":\"0x44db41e8ff90c2828ca0ada125abc4b411921a86514a4a047fd9fd43ba9d7e08\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/functions/dev/v1_X/libraries/FunctionsRequest.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {CBOR} from \\\"../../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\\\";\\n\\n/// @title Library for encoding the input data of a Functions request into CBOR\\nlibrary FunctionsRequest {\\n  using CBOR for CBOR.CBORBuffer;\\n\\n  uint16 public constant REQUEST_DATA_VERSION = 1;\\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\\n\\n  enum Location {\\n    Inline, // Provided within the Request\\n    Remote, // Hosted through remote location that can be accessed through a provided URL\\n    DONHosted // Hosted on the DON's storage\\n  }\\n\\n  enum CodeLanguage {\\n    JavaScript\\n    // In future version we may add other languages\\n  }\\n\\n  struct Request {\\n    Location codeLocation; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 The location of the source code that will be executed on each node in the DON\\n    Location secretsLocation; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 The location of secrets that will be passed into the source code. *Only Remote secrets are supported\\n    CodeLanguage language; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 The coding language that the source code is written in\\n    string source; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\\n    bytes encryptedSecretsReference; // \\u2550\\u2550\\u2578 Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\\n    string[] args; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 String arguments that will be passed into the source code\\n    bytes[] bytesArgs; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 Bytes arguments that will be passed into the source code\\n  }\\n\\n  error EmptySource();\\n  error EmptySecrets();\\n  error EmptyArgs();\\n  error NoInlineSecrets();\\n\\n  /// @notice Encodes a Request to CBOR encoded bytes\\n  /// @param self The request to encode\\n  /// @return CBOR encoded bytes\\n  function _encodeCBOR(Request memory self) internal pure returns (bytes memory) {\\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\\n\\n    buffer.writeString(\\\"codeLocation\\\");\\n    buffer.writeUInt256(uint256(self.codeLocation));\\n\\n    buffer.writeString(\\\"language\\\");\\n    buffer.writeUInt256(uint256(self.language));\\n\\n    buffer.writeString(\\\"source\\\");\\n    buffer.writeString(self.source);\\n\\n    if (self.args.length > 0) {\\n      buffer.writeString(\\\"args\\\");\\n      buffer.startArray();\\n      for (uint256 i = 0; i < self.args.length; ++i) {\\n        buffer.writeString(self.args[i]);\\n      }\\n      buffer.endSequence();\\n    }\\n\\n    if (self.encryptedSecretsReference.length > 0) {\\n      if (self.secretsLocation == Location.Inline) {\\n        revert NoInlineSecrets();\\n      }\\n      buffer.writeString(\\\"secretsLocation\\\");\\n      buffer.writeUInt256(uint256(self.secretsLocation));\\n      buffer.writeString(\\\"secrets\\\");\\n      buffer.writeBytes(self.encryptedSecretsReference);\\n    }\\n\\n    if (self.bytesArgs.length > 0) {\\n      buffer.writeString(\\\"bytesArgs\\\");\\n      buffer.startArray();\\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\\n        buffer.writeBytes(self.bytesArgs[i]);\\n      }\\n      buffer.endSequence();\\n    }\\n\\n    return buffer.buf.buf;\\n  }\\n\\n  /// @notice Initializes a Chainlink Functions Request\\n  /// @dev Sets the codeLocation and code on the request\\n  /// @param self The uninitialized request\\n  /// @param codeLocation The user provided source code location\\n  /// @param language The programming language of the user code\\n  /// @param source The user provided source code or a url\\n  function _initializeRequest(\\n    Request memory self,\\n    Location codeLocation,\\n    CodeLanguage language,\\n    string memory source\\n  ) internal pure {\\n    if (bytes(source).length == 0) revert EmptySource();\\n\\n    self.codeLocation = codeLocation;\\n    self.language = language;\\n    self.source = source;\\n  }\\n\\n  /// @notice Initializes a Chainlink Functions Request\\n  /// @dev Simplified version of initializeRequest for PoC\\n  /// @param self The uninitialized request\\n  /// @param javaScriptSource The user provided JS code (must not be empty)\\n  function _initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\\n    _initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\\n  }\\n\\n  /// @notice Adds Remote user encrypted secrets to a Request\\n  /// @param self The initialized request\\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\\n  function _addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\\n\\n    self.secretsLocation = Location.Remote;\\n    self.encryptedSecretsReference = encryptedSecretsReference;\\n  }\\n\\n  /// @notice Adds DON-hosted secrets reference to a Request\\n  /// @param self The initialized request\\n  /// @param slotID Slot ID of the user's secrets hosted on DON\\n  /// @param version User data version (for the slotID)\\n  function _addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\\n\\n    buffer.writeString(\\\"slotID\\\");\\n    buffer.writeUInt64(slotID);\\n    buffer.writeString(\\\"version\\\");\\n    buffer.writeUInt64(version);\\n\\n    self.secretsLocation = Location.DONHosted;\\n    self.encryptedSecretsReference = buffer.buf.buf;\\n  }\\n\\n  /// @notice Sets args for the user run function\\n  /// @param self The initialized request\\n  /// @param args The array of string args (must not be empty)\\n  function _setArgs(Request memory self, string[] memory args) internal pure {\\n    if (args.length == 0) revert EmptyArgs();\\n\\n    self.args = args;\\n  }\\n\\n  /// @notice Sets bytes args for the user run function\\n  /// @param self The initialized request\\n  /// @param args The array of bytes args (must not be empty)\\n  function _setBytesArgs(Request memory self, bytes[] memory args) internal pure {\\n    if (args.length == 0) revert EmptyArgs();\\n\\n    self.bytesArgs = args;\\n  }\\n}\\n\",\"keccak256\":\"0xfa17a5ee24d7822979ebfb48aab2610ba233f6e209016b96c51a223fa56397c5\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/functions/dev/v1_X/libraries/FunctionsResponse.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @title Library of types that are used for fulfillment of a Functions request\\nlibrary FunctionsResponse {\\n  // Used to send request information from the Router to the Coordinator\\n  struct RequestMeta {\\n    bytes data; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\\n    bytes32 flags; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 Per-subscription flags\\n    address requestingContract; // \\u2550\\u2550\\u2557 The client contract that is sending the request\\n    uint96 availableBalance; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u255d Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\\n    uint72 adminFee; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557 Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\\n    uint64 subscriptionId; //        \\u2551 Identifier of the billing subscription that will be charged for the request\\n    uint64 initiatedRequests; //     \\u2551 The number of requests that have been started\\n    uint32 callbackGasLimit; //      \\u2551 The amount of gas that the callback to the consuming contract will be given\\n    uint16 dataVersion; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d The version of the structure of the CBOR encoded request data\\n    uint64 completedRequests; // \\u2550\\u2550\\u2550\\u2550\\u2557 The number of requests that have successfully completed or timed out\\n    address subscriptionOwner; // \\u2550\\u2550\\u2550\\u255d The owner of the billing subscription\\n  }\\n\\n  enum FulfillResult {\\n    FULFILLED, // 0\\n    USER_CALLBACK_ERROR, // 1\\n    INVALID_REQUEST_ID, // 2\\n    COST_EXCEEDS_COMMITMENT, // 3\\n    INSUFFICIENT_GAS_PROVIDED, // 4\\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\\n    INVALID_COMMITMENT // 6\\n  }\\n\\n  struct Commitment {\\n    bytes32 requestId; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 A unique identifier for a Chainlink Functions request\\n    address coordinator; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557 The Coordinator contract that manages the DON that is servicing a request\\n    uint96 estimatedTotalCostJuels; // \\u2550\\u2550\\u2550\\u2550\\u255d The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\\n    address client; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557 The client contract that sent the request\\n    uint64 subscriptionId; //              \\u2551 Identifier of the billing subscription that will be charged for the request\\n    uint32 callbackGasLimit; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d The amount of gas that the callback to the consuming contract will be given\\n    uint72 adminFee; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557 Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\\n    uint72 donFee; //                      \\u2551 Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\\n    uint40 gasOverheadBeforeCallback; //   \\u2551 Represents the average gas execution cost before the fulfillment callback.\\n    uint40 gasOverheadAfterCallback; //    \\u2551 Represents the average gas execution cost after the fulfillment callback.\\n    uint32 timeoutTimestamp; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d The timestamp at which a request will be eligible to be timed out\\n  }\\n}\\n\",\"keccak256\":\"0xc72eb037effef32146f7cd4086af00f44f28c8649d891e5e404fec5fda7e802b\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IFunctionsRouter} from './interfaces/IFunctionsRouter.sol';\\nimport {IFunctionsClient} from './interfaces/IFunctionsClient.sol';\\n\\nimport {FunctionsRequest} from './libraries/FunctionsRequest.sol';\\n\\n/// @title The Chainlink Functions client contract\\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\\nabstract contract FunctionsClient is IFunctionsClient {\\n\\tusing FunctionsRequest for FunctionsRequest.Request;\\n\\n\\tIFunctionsRouter internal i_router;\\n\\n\\tevent RequestSent(bytes32 indexed id);\\n\\tevent RequestFulfilled(bytes32 indexed id);\\n\\n\\terror OnlyRouterCanFulfill();\\n\\n\\tconstructor(address router) {\\n\\t\\ti_router = IFunctionsRouter(router);\\n\\t}\\n\\n\\t/// @notice Sends a Chainlink Functions request\\n\\t/// @param data The CBOR encoded bytes data for a Functions request\\n\\t/// @param subscriptionId The subscription ID that will be charged to service the request\\n\\t/// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\\n\\t/// @return requestId The generated request ID for this request\\n\\tfunction _sendRequest(\\n\\t\\tbytes memory data,\\n\\t\\tuint64 subscriptionId,\\n\\t\\tuint32 callbackGasLimit,\\n\\t\\tbytes32 donId\\n\\t) internal returns (bytes32) {\\n\\t\\tbytes32 requestId = i_router.sendRequest(\\n\\t\\t\\tsubscriptionId,\\n\\t\\t\\tdata,\\n\\t\\t\\tFunctionsRequest.REQUEST_DATA_VERSION,\\n\\t\\t\\tcallbackGasLimit,\\n\\t\\t\\tdonId\\n\\t\\t);\\n\\t\\temit RequestSent(requestId);\\n\\t\\treturn requestId;\\n\\t}\\n\\n\\t/// @notice User defined function to handle a response from the DON\\n\\t/// @param requestId The request ID, returned by sendRequest()\\n\\t/// @param response Aggregated response from the execution of the user's source code\\n\\t/// @param err Aggregated error from the execution of the user code or from the execution pipeline\\n\\t/// @dev Either response or error parameter will be set, but never both\\n\\tfunction fulfillRequest(\\n\\t\\tbytes32 requestId,\\n\\t\\tbytes memory response,\\n\\t\\tbytes memory err\\n\\t) internal virtual;\\n\\n\\t/// @inheritdoc IFunctionsClient\\n\\tfunction handleOracleFulfillment(\\n\\t\\tbytes32 requestId,\\n\\t\\tbytes memory response,\\n\\t\\tbytes memory err\\n\\t) external override {\\n\\t\\tif (msg.sender != address(i_router)) {\\n\\t\\t\\trevert OnlyRouterCanFulfill();\\n\\t\\t}\\n\\t\\tfulfillRequest(requestId, response, err);\\n\\t\\temit RequestFulfilled(requestId);\\n\\t}\\n}\\n\",\"keccak256\":\"0x5f800b9178f4fc96d40a941fa98f706a2d4048e6b82e58fb3387152080193151\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @title Chainlink Functions client interface.\\ninterface IFunctionsClient {\\n  /// @notice Chainlink Functions response handler called by the Functions Router\\n  /// during fullilment from the designated transmitter node in an OCR round.\\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\\n  /// @param response Aggregated response from the request's source code.\\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\\n  /// @dev Either response or error parameter will be set, but never both.\\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\\n}\\n\",\"keccak256\":\"0x6117b82e7c4eec44ce557b0fc8bc1ac5f49e5d160ac6d4485452d6aafdd762ff\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {FunctionsResponse} from \\\"../libraries/FunctionsResponse.sol\\\";\\n\\n/// @title Chainlink Functions Router interface.\\ninterface IFunctionsRouter {\\n  /// @notice The identifier of the route to retrieve the address of the access control contract\\n  /// The access control contract controls which accounts can manage subscriptions\\n  /// @return id - bytes32 id that can be passed to the \\\"getContractById\\\" of the Router\\n  function getAllowListId() external view returns (bytes32);\\n\\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\\n  /// The access control contract controls which accounts can manage subscriptions\\n  function setAllowListId(bytes32 allowListId) external;\\n\\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\\n  /// @return adminFee\\n  function getAdminFee() external view returns (uint72 adminFee);\\n\\n  /// @notice Sends a request using the provided subscriptionId\\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\\n  /// a client can make requests from different contracts referencing the same subscription\\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\\n  /// @param dataVersion - Gas limit for the fulfillment callback\\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\\n  /// @param donId - An identifier used to determine which route to send the request along\\n  /// @return requestId - A unique request identifier\\n  function sendRequest(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) external returns (bytes32);\\n\\n  /// @notice Sends a request to the proposed contracts\\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\\n  /// a client can make requests from different contracts referencing the same subscription\\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\\n  /// @param dataVersion - Gas limit for the fulfillment callback\\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\\n  /// @param donId - An identifier used to determine which route to send the request along\\n  /// @return requestId - A unique request identifier\\n  function sendRequestToProposed(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) external returns (bytes32);\\n\\n  /// @notice Fulfill the request by:\\n  /// - calling back the data that the Oracle returned to the client contract\\n  /// - pay the DON for processing the request\\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\\n  /// @param response response data from DON consensus\\n  /// @param err error from DON consensus\\n  /// @param juelsPerGas - current rate of juels/gas\\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\\n  /// @param transmitter - The Node that transmitted the OCR report\\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\\n  /// @return fulfillResult -\\n  /// @return callbackGasCostJuels -\\n  function fulfill(\\n    bytes memory response,\\n    bytes memory err,\\n    uint96 juelsPerGas,\\n    uint96 costWithoutFulfillment,\\n    address transmitter,\\n    FunctionsResponse.Commitment memory commitment\\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\\n\\n  /// @notice Validate requested gas limit is below the subscription max.\\n  /// @param subscriptionId subscription ID\\n  /// @param callbackGasLimit desired callback gas limit\\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\\n\\n  /// @notice Get the current contract given an ID\\n  /// @param id A bytes32 identifier for the route\\n  /// @return contract The current contract address\\n  function getContractById(bytes32 id) external view returns (address);\\n\\n  /// @notice Get the proposed next contract given an ID\\n  /// @param id A bytes32 identifier for the route\\n  /// @return contract The current or proposed contract address\\n  function getProposedContractById(bytes32 id) external view returns (address);\\n\\n  /// @notice Return the latest proprosal set\\n  /// @return ids The identifiers of the contracts to update\\n  /// @return to The addresses of the contracts that will be updated to\\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\\n\\n  /// @notice Proposes one or more updates to the contract routes\\n  /// @dev Only callable by owner\\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\\n\\n  /// @notice Updates the current contract routes to the proposed contracts\\n  /// @dev Only callable by owner\\n  function updateContracts() external;\\n\\n  /// @dev Puts the system into an emergency stopped state.\\n  /// @dev Only callable by owner\\n  function pause() external;\\n\\n  /// @dev Takes the system out of an emergency stopped state.\\n  /// @dev Only callable by owner\\n  function unpause() external;\\n}\\n\",\"keccak256\":\"0x44db41e8ff90c2828ca0ada125abc4b411921a86514a4a047fd9fd43ba9d7e08\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {CBOR} from \\\"../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\\\";\\n\\n/// @title Library for encoding the input data of a Functions request into CBOR\\nlibrary FunctionsRequest {\\n  using CBOR for CBOR.CBORBuffer;\\n\\n  uint16 public constant REQUEST_DATA_VERSION = 1;\\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\\n\\n  enum Location {\\n    Inline, // Provided within the Request\\n    Remote, // Hosted through remote location that can be accessed through a provided URL\\n    DONHosted // Hosted on the DON's storage\\n  }\\n\\n  enum CodeLanguage {\\n    JavaScript\\n    // In future version we may add other languages\\n  }\\n\\n  struct Request {\\n    Location codeLocation; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 The location of the source code that will be executed on each node in the DON\\n    Location secretsLocation; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 The location of secrets that will be passed into the source code. *Only Remote secrets are supported\\n    CodeLanguage language; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 The coding language that the source code is written in\\n    string source; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\\n    bytes encryptedSecretsReference; // \\u2550\\u2550\\u2578 Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\\n    string[] args; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 String arguments that will be passed into the source code\\n    bytes[] bytesArgs; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 Bytes arguments that will be passed into the source code\\n  }\\n\\n  error EmptySource();\\n  error EmptySecrets();\\n  error EmptyArgs();\\n  error NoInlineSecrets();\\n\\n  /// @notice Encodes a Request to CBOR encoded bytes\\n  /// @param self The request to encode\\n  /// @return CBOR encoded bytes\\n  function encodeCBOR(Request memory self) internal pure returns (bytes memory) {\\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\\n\\n    buffer.writeString(\\\"codeLocation\\\");\\n    buffer.writeUInt256(uint256(self.codeLocation));\\n\\n    buffer.writeString(\\\"language\\\");\\n    buffer.writeUInt256(uint256(self.language));\\n\\n    buffer.writeString(\\\"source\\\");\\n    buffer.writeString(self.source);\\n\\n    if (self.args.length > 0) {\\n      buffer.writeString(\\\"args\\\");\\n      buffer.startArray();\\n      for (uint256 i = 0; i < self.args.length; ++i) {\\n        buffer.writeString(self.args[i]);\\n      }\\n      buffer.endSequence();\\n    }\\n\\n    if (self.encryptedSecretsReference.length > 0) {\\n      if (self.secretsLocation == Location.Inline) {\\n        revert NoInlineSecrets();\\n      }\\n      buffer.writeString(\\\"secretsLocation\\\");\\n      buffer.writeUInt256(uint256(self.secretsLocation));\\n      buffer.writeString(\\\"secrets\\\");\\n      buffer.writeBytes(self.encryptedSecretsReference);\\n    }\\n\\n    if (self.bytesArgs.length > 0) {\\n      buffer.writeString(\\\"bytesArgs\\\");\\n      buffer.startArray();\\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\\n        buffer.writeBytes(self.bytesArgs[i]);\\n      }\\n      buffer.endSequence();\\n    }\\n\\n    return buffer.buf.buf;\\n  }\\n\\n  /// @notice Initializes a Chainlink Functions Request\\n  /// @dev Sets the codeLocation and code on the request\\n  /// @param self The uninitialized request\\n  /// @param codeLocation The user provided source code location\\n  /// @param language The programming language of the user code\\n  /// @param source The user provided source code or a url\\n  function initializeRequest(\\n    Request memory self,\\n    Location codeLocation,\\n    CodeLanguage language,\\n    string memory source\\n  ) internal pure {\\n    if (bytes(source).length == 0) revert EmptySource();\\n\\n    self.codeLocation = codeLocation;\\n    self.language = language;\\n    self.source = source;\\n  }\\n\\n  /// @notice Initializes a Chainlink Functions Request\\n  /// @dev Simplified version of initializeRequest for PoC\\n  /// @param self The uninitialized request\\n  /// @param javaScriptSource The user provided JS code (must not be empty)\\n  function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\\n    initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\\n  }\\n\\n  /// @notice Adds Remote user encrypted secrets to a Request\\n  /// @param self The initialized request\\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\\n  function addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\\n\\n    self.secretsLocation = Location.Remote;\\n    self.encryptedSecretsReference = encryptedSecretsReference;\\n  }\\n\\n  /// @notice Adds DON-hosted secrets reference to a Request\\n  /// @param self The initialized request\\n  /// @param slotID Slot ID of the user's secrets hosted on DON\\n  /// @param version User data version (for the slotID)\\n  function addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\\n\\n    buffer.writeString(\\\"slotID\\\");\\n    buffer.writeUInt64(slotID);\\n    buffer.writeString(\\\"version\\\");\\n    buffer.writeUInt64(version);\\n\\n    self.secretsLocation = Location.DONHosted;\\n    self.encryptedSecretsReference = buffer.buf.buf;\\n  }\\n\\n  /// @notice Sets args for the user run function\\n  /// @param self The initialized request\\n  /// @param args The array of string args (must not be empty)\\n  function setArgs(Request memory self, string[] memory args) internal pure {\\n    if (args.length == 0) revert EmptyArgs();\\n\\n    self.args = args;\\n  }\\n\\n  /// @notice Sets bytes args for the user run function\\n  /// @param self The initialized request\\n  /// @param args The array of bytes args (must not be empty)\\n  function setBytesArgs(Request memory self, bytes[] memory args) internal pure {\\n    if (args.length == 0) revert EmptyArgs();\\n\\n    self.bytesArgs = args;\\n  }\\n}\\n\",\"keccak256\":\"0xed75be0eaba358d468f1fe18adc377d5044f57eff0070081f884a1f212d0adc2\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsResponse.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @title Library of types that are used for fulfillment of a Functions request\\nlibrary FunctionsResponse {\\n  // Used to send request information from the Router to the Coordinator\\n  struct RequestMeta {\\n    bytes data; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\\n    bytes32 flags; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 Per-subscription flags\\n    address requestingContract; // \\u2550\\u2550\\u2557 The client contract that is sending the request\\n    uint96 availableBalance; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u255d Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\\n    uint72 adminFee; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557 Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\\n    uint64 subscriptionId; //        \\u2551 Identifier of the billing subscription that will be charged for the request\\n    uint64 initiatedRequests; //     \\u2551 The number of requests that have been started\\n    uint32 callbackGasLimit; //      \\u2551 The amount of gas that the callback to the consuming contract will be given\\n    uint16 dataVersion; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d The version of the structure of the CBOR encoded request data\\n    uint64 completedRequests; // \\u2550\\u2550\\u2550\\u2550\\u2557 The number of requests that have successfully completed or timed out\\n    address subscriptionOwner; // \\u2550\\u2550\\u2550\\u255d The owner of the billing subscription\\n  }\\n\\n  enum FulfillResult {\\n    FULFILLED, // 0\\n    USER_CALLBACK_ERROR, // 1\\n    INVALID_REQUEST_ID, // 2\\n    COST_EXCEEDS_COMMITMENT, // 3\\n    INSUFFICIENT_GAS_PROVIDED, // 4\\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\\n    INVALID_COMMITMENT // 6\\n  }\\n\\n  struct Commitment {\\n    bytes32 requestId; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2578 A unique identifier for a Chainlink Functions request\\n    address coordinator; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557 The Coordinator contract that manages the DON that is servicing a request\\n    uint96 estimatedTotalCostJuels; // \\u2550\\u2550\\u2550\\u2550\\u255d The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\\n    address client; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557 The client contract that sent the request\\n    uint64 subscriptionId; //              \\u2551 Identifier of the billing subscription that will be charged for the request\\n    uint32 callbackGasLimit; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d The amount of gas that the callback to the consuming contract will be given\\n    uint72 adminFee; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557 Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\\n    uint72 donFee; //                      \\u2551 Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\\n    uint40 gasOverheadBeforeCallback; //   \\u2551 Represents the average gas execution cost before the fulfillment callback.\\n    uint40 gasOverheadAfterCallback; //    \\u2551 Represents the average gas execution cost after the fulfillment callback.\\n    uint32 timeoutTimestamp; // \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d The timestamp at which a request will be eligible to be timed out\\n  }\\n}\\n\",\"keccak256\":\"0xc72eb037effef32146f7cd4086af00f44f28c8649d891e5e404fec5fda7e802b\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ConfirmedOwnerWithProposal} from \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/// @title The ConfirmedOwner contract\\n/// @notice A contract with helpers for basic contract ownership.\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\",\"keccak256\":\"0xdcb0e9135ddbe71ee27ba99fa06656960c66c964cf2ecb29696da1c1427d9861\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @title The ConfirmedOwner contract\\n/// @notice A contract with helpers for basic contract ownership.\\ncontract ConfirmedOwnerWithProposal is IOwnable {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    // solhint-disable-next-line gas-custom-errors\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address.\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    // solhint-disable-next-line gas-custom-errors\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  function _transferOwnership(address to) private {\\n    // solhint-disable-next-line gas-custom-errors\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    // solhint-disable-next-line gas-custom-errors\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x2422a055657a87e98be61f8f31abb1824ec50fd0f73949f4e3c6ac877efb6da8\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ConfirmedOwner} from \\\"./ConfirmedOwner.sol\\\";\\n\\n/// @title The OwnerIsCreator contract\\n/// @notice A contract with helpers for basic contract ownership.\\ncontract OwnerIsCreator is ConfirmedOwner {\\n  constructor() ConfirmedOwner(msg.sender) {}\\n}\\n\",\"keccak256\":\"0x895af02d6a3df2930bbb6ec1f2d68118b492ca6e710ba0c34fcb6b574a0906aa\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\",\"keccak256\":\"0x885de72b7b4e4f1bf8ba817a3f2bcc37fd9022d342c4ce76782151c30122d767\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/vendor/@ensdomains/buffer/v0.1.0/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for appending to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            let fpm := add(32, add(ptr, capacity))\\n            if lt(fpm, ptr) {\\n                revert(0, 0)\\n            }\\n            mstore(0x40, fpm)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        uint off = buf.buf.length;\\n        uint newCapacity = off + len;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(newCapacity, buflen) {\\n                mstore(bufptr, newCapacity)\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return append(buf, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint offPlusOne = off + 1;\\n        if (off >= buf.capacity) {\\n            resize(buf, offPlusOne * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if gt(offPlusOne, mload(bufptr)) {\\n                mstore(bufptr, offPlusOne)\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return append(buf, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return append(buf, data, 32);\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + newCapacity\\n            let dest := add(bufptr, newCapacity)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(newCapacity, mload(bufptr)) {\\n                mstore(bufptr, newCapacity)\\n            }\\n        }\\n        return buf;\\n    }\\n}\",\"keccak256\":\"0x0d86b367813922094e02594a406ba89f5e97d3d74ec2ce3c4032566840e302b0\",\"license\":\"BSD-2-Clause\"},\"@chainlink/contracts/src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../../@ensdomains/buffer/v0.1.0/Buffer.sol\\\";\\n\\n/**\\n* @dev A library for populating CBOR encoded payload in Solidity.\\n*\\n* https://datatracker.ietf.org/doc/html/rfc7049\\n*\\n* The library offers various write* and start* methods to encode values of different types.\\n* The resulted buffer can be obtained with data() method.\\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\\n* in an invalid CBOR if start/write/end flow is violated.\\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\\n* except for nested start/end pairs.\\n*/\\n\\nlibrary CBOR {\\n    using Buffer for Buffer.buffer;\\n\\n    struct CBORBuffer {\\n        Buffer.buffer buf;\\n        uint256 depth;\\n    }\\n\\n    uint8 private constant MAJOR_TYPE_INT = 0;\\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\\n    uint8 private constant MAJOR_TYPE_STRING = 3;\\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n    uint8 private constant MAJOR_TYPE_MAP = 5;\\n    uint8 private constant MAJOR_TYPE_TAG = 6;\\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n    uint8 private constant CBOR_FALSE = 20;\\n    uint8 private constant CBOR_TRUE = 21;\\n    uint8 private constant CBOR_NULL = 22;\\n    uint8 private constant CBOR_UNDEFINED = 23;\\n\\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\\n        Buffer.init(cbor.buf, capacity);\\n        cbor.depth = 0;\\n        return cbor;\\n    }\\n\\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\\n        require(buf.depth == 0, \\\"Invalid CBOR\\\");\\n        return buf.buf.buf;\\n    }\\n\\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n        writeBytes(buf, abi.encode(value));\\n    }\\n\\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\\n        if (value < 0) {\\n            buf.buf.appendUint8(\\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\\n            );\\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\\n        } else {\\n            writeUInt256(buf, uint256(value));\\n        }\\n    }\\n\\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\\n    }\\n\\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\\n        if(value >= 0) {\\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\\n        } else{\\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\\n        }\\n    }\\n\\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\\n        buf.buf.append(value);\\n    }\\n\\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\\n        buf.buf.append(bytes(value));\\n    }\\n\\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\\n    }\\n\\n    function writeNull(CBORBuffer memory buf) internal pure {\\n        writeContentFree(buf, CBOR_NULL);\\n    }\\n\\n    function writeUndefined(CBORBuffer memory buf) internal pure {\\n        writeContentFree(buf, CBOR_UNDEFINED);\\n    }\\n\\n    function startArray(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n        buf.depth += 1;\\n    }\\n\\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\\n    }\\n\\n    function startMap(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n        buf.depth += 1;\\n    }\\n\\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\\n    }\\n\\n    function endSequence(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n        buf.depth -= 1;\\n    }\\n\\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\\n        writeString(buf, key);\\n        writeString(buf, value);\\n    }\\n\\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\\n        writeString(buf, key);\\n        writeBytes(buf, value);\\n    }\\n\\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\\n        writeString(buf, key);\\n        writeUInt256(buf, value);\\n    }\\n\\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\\n        writeString(buf, key);\\n        writeInt256(buf, value);\\n    }\\n\\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\\n        writeString(buf, key);\\n        writeUInt64(buf, value);\\n    }\\n\\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\\n        writeString(buf, key);\\n        writeInt64(buf, value);\\n    }\\n\\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\\n        writeString(buf, key);\\n        writeBool(buf, value);\\n    }\\n\\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        writeNull(buf);\\n    }\\n\\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        writeUndefined(buf);\\n    }\\n\\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        startMap(buf);\\n    }\\n\\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        startArray(buf);\\n    }\\n\\n    function writeFixedNumeric(\\n        CBORBuffer memory buf,\\n        uint8 major,\\n        uint64 value\\n    ) private pure {\\n        if (value <= 23) {\\n            buf.buf.appendUint8(uint8((major << 5) | value));\\n        } else if (value <= 0xFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 24));\\n            buf.buf.appendInt(value, 1);\\n        } else if (value <= 0xFFFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 25));\\n            buf.buf.appendInt(value, 2);\\n        } else if (value <= 0xFFFFFFFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 26));\\n            buf.buf.appendInt(value, 4);\\n        } else {\\n            buf.buf.appendUint8(uint8((major << 5) | 27));\\n            buf.buf.appendInt(value, 8);\\n        }\\n    }\\n\\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\\n        private\\n        pure\\n    {\\n        buf.buf.appendUint8(uint8((major << 5) | 31));\\n    }\\n\\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\\n        private\\n        pure\\n    {\\n        writeFixedNumeric(buf, major, length);\\n    }\\n\\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\\n    }\\n}\",\"keccak256\":\"0xdecf04203502670ac72ba466c75e4f87f4419907365005f0d73e7d07ee3e5715\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {ERC165Upgradeable} from \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\\n    struct AccessControlStorage {\\n        mapping(bytes32 role => RoleData) _roles;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.AccessControl\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\\n\\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\\n        assembly {\\n            $.slot := AccessControlStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    function __AccessControl_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        return $._roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        return $._roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        $._roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        if (!hasRole(role, account)) {\\n            $._roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        if (hasRole(role, account)) {\\n            $._roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0d4d7d19a052a2ef9d17b28450133631188b895e1755747fa8ad0280aadfb534\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (governance/TimelockController.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {AccessControlUpgradeable} from \\\"../access/AccessControlUpgradeable.sol\\\";\\nimport {ERC721HolderUpgradeable} from \\\"../token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\nimport {ERC1155HolderUpgradeable} from \\\"../token/ERC1155/utils/ERC1155HolderUpgradeable.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which acts as a timelocked controller. When set as the\\n * owner of an `Ownable` smart contract, it enforces a timelock on all\\n * `onlyOwner` maintenance operations. This gives time for users of the\\n * controlled contract to exit before a potentially dangerous maintenance\\n * operation is applied.\\n *\\n * By default, this contract is self administered, meaning administration tasks\\n * have to go through the timelock process. The proposer (resp executor) role\\n * is in charge of proposing (resp executing) operations. A common use case is\\n * to position this {TimelockController} as the owner of a smart contract, with\\n * a multisig or a DAO as the sole proposer.\\n */\\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\\n    bytes32 public constant PROPOSER_ROLE = keccak256(\\\"PROPOSER_ROLE\\\");\\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\\\"EXECUTOR_ROLE\\\");\\n    bytes32 public constant CANCELLER_ROLE = keccak256(\\\"CANCELLER_ROLE\\\");\\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.TimelockController\\n    struct TimelockControllerStorage {\\n        mapping(bytes32 id => uint256) _timestamps;\\n        uint256 _minDelay;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.TimelockController\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant TimelockControllerStorageLocation = 0x9a37c2aa9d186a0969ff8a8267bf4e07e864c2f2768f5040949e28a624fb3600;\\n\\n    function _getTimelockControllerStorage() private pure returns (TimelockControllerStorage storage $) {\\n        assembly {\\n            $.slot := TimelockControllerStorageLocation\\n        }\\n    }\\n\\n    enum OperationState {\\n        Unset,\\n        Waiting,\\n        Ready,\\n        Done\\n    }\\n\\n    /**\\n     * @dev Mismatch between the parameters length for an operation call.\\n     */\\n    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);\\n\\n    /**\\n     * @dev The schedule operation doesn't meet the minimum delay.\\n     */\\n    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);\\n\\n    /**\\n     * @dev The current state of an operation is not as required.\\n     * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position\\n     * counting from right to left.\\n     *\\n     * See {_encodeStateBitmap}.\\n     */\\n    error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);\\n\\n    /**\\n     * @dev The predecessor to an operation not yet done.\\n     */\\n    error TimelockUnexecutedPredecessor(bytes32 predecessorId);\\n\\n    /**\\n     * @dev The caller account is not authorized.\\n     */\\n    error TimelockUnauthorizedCaller(address caller);\\n\\n    /**\\n     * @dev Emitted when a call is scheduled as part of operation `id`.\\n     */\\n    event CallScheduled(\\n        bytes32 indexed id,\\n        uint256 indexed index,\\n        address target,\\n        uint256 value,\\n        bytes data,\\n        bytes32 predecessor,\\n        uint256 delay\\n    );\\n\\n    /**\\n     * @dev Emitted when a call is performed as part of operation `id`.\\n     */\\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\\n\\n    /**\\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\\n     */\\n    event CallSalt(bytes32 indexed id, bytes32 salt);\\n\\n    /**\\n     * @dev Emitted when operation `id` is cancelled.\\n     */\\n    event Cancelled(bytes32 indexed id);\\n\\n    /**\\n     * @dev Emitted when the minimum delay for future operations is modified.\\n     */\\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\\n\\n    function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) public virtual initializer {\\n        __TimelockController_init(minDelay, proposers, executors, admin);\\n    }\\n    /**\\n     * @dev Initializes the contract with the following parameters:\\n     *\\n     * - `minDelay`: initial minimum delay in seconds for operations\\n     * - `proposers`: accounts to be granted proposer and canceller roles\\n     * - `executors`: accounts to be granted executor role\\n     * - `admin`: optional account to be granted admin role; disable with zero address\\n     *\\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\\n     * without being subject to delay, but this role should be subsequently renounced in favor of\\n     * administration through timelocked proposals. Previous versions of this contract would assign\\n     * this admin to the deployer automatically and should be renounced as well.\\n     */\\n    function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\\n        __TimelockController_init_unchained(minDelay, proposers, executors, admin);\\n    }\\n\\n    function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        // self administration\\n        _grantRole(DEFAULT_ADMIN_ROLE, address(this));\\n\\n        // optional admin\\n        if (admin != address(0)) {\\n            _grantRole(DEFAULT_ADMIN_ROLE, admin);\\n        }\\n\\n        // register proposers and cancellers\\n        for (uint256 i = 0; i < proposers.length; ++i) {\\n            _grantRole(PROPOSER_ROLE, proposers[i]);\\n            _grantRole(CANCELLER_ROLE, proposers[i]);\\n        }\\n\\n        // register executors\\n        for (uint256 i = 0; i < executors.length; ++i) {\\n            _grantRole(EXECUTOR_ROLE, executors[i]);\\n        }\\n\\n        $._minDelay = minDelay;\\n        emit MinDelayChange(0, minDelay);\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only by a certain role. In\\n     * addition to checking the sender's role, `address(0)` 's role is also\\n     * considered. Granting a role to `address(0)` is equivalent to enabling\\n     * this role for everyone.\\n     */\\n    modifier onlyRoleOrOpenRole(bytes32 role) {\\n        if (!hasRole(role, address(0))) {\\n            _checkRole(role, _msgSender());\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\\n     */\\n    receive() external payable virtual {}\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(AccessControlUpgradeable, ERC1155HolderUpgradeable) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns whether an id corresponds to a registered operation. This\\n     * includes both Waiting, Ready, and Done operations.\\n     */\\n    function isOperation(bytes32 id) public view returns (bool) {\\n        return getOperationState(id) != OperationState.Unset;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is pending or not. Note that a \\\"pending\\\" operation may also be \\\"ready\\\".\\n     */\\n    function isOperationPending(bytes32 id) public view returns (bool) {\\n        OperationState state = getOperationState(id);\\n        return state == OperationState.Waiting || state == OperationState.Ready;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is ready for execution. Note that a \\\"ready\\\" operation is also \\\"pending\\\".\\n     */\\n    function isOperationReady(bytes32 id) public view returns (bool) {\\n        return getOperationState(id) == OperationState.Ready;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is done or not.\\n     */\\n    function isOperationDone(bytes32 id) public view returns (bool) {\\n        return getOperationState(id) == OperationState.Done;\\n    }\\n\\n    /**\\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\\n     * unset operations, 1 for done operations).\\n     */\\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        return $._timestamps[id];\\n    }\\n\\n    /**\\n     * @dev Returns operation state.\\n     */\\n    function getOperationState(bytes32 id) public view virtual returns (OperationState) {\\n        uint256 timestamp = getTimestamp(id);\\n        if (timestamp == 0) {\\n            return OperationState.Unset;\\n        } else if (timestamp == _DONE_TIMESTAMP) {\\n            return OperationState.Done;\\n        } else if (timestamp > block.timestamp) {\\n            return OperationState.Waiting;\\n        } else {\\n            return OperationState.Ready;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the minimum delay in seconds for an operation to become valid.\\n     *\\n     * This value can be changed by executing an operation that calls `updateDelay`.\\n     */\\n    function getMinDelay() public view virtual returns (uint256) {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        return $._minDelay;\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a single\\n     * transaction.\\n     */\\n    function hashOperation(\\n        address target,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public pure virtual returns (bytes32) {\\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a batch of\\n     * transactions.\\n     */\\n    function hashOperationBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public pure virtual returns (bytes32) {\\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a single transaction.\\n     *\\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function schedule(\\n        address target,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes32 predecessor,\\n        bytes32 salt,\\n        uint256 delay\\n    ) public virtual onlyRole(PROPOSER_ROLE) {\\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\\n        _schedule(id, delay);\\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\\n        if (salt != bytes32(0)) {\\n            emit CallSalt(id, salt);\\n        }\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a batch of transactions.\\n     *\\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function scheduleBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads,\\n        bytes32 predecessor,\\n        bytes32 salt,\\n        uint256 delay\\n    ) public virtual onlyRole(PROPOSER_ROLE) {\\n        if (targets.length != values.length || targets.length != payloads.length) {\\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\\n        }\\n\\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\\n        _schedule(id, delay);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\\n        }\\n        if (salt != bytes32(0)) {\\n            emit CallSalt(id, salt);\\n        }\\n    }\\n\\n    /**\\n     * @dev Schedule an operation that is to become valid after a given delay.\\n     */\\n    function _schedule(bytes32 id, uint256 delay) private {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        if (isOperation(id)) {\\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));\\n        }\\n        uint256 minDelay = getMinDelay();\\n        if (delay < minDelay) {\\n            revert TimelockInsufficientDelay(delay, minDelay);\\n        }\\n        $._timestamps[id] = block.timestamp + delay;\\n    }\\n\\n    /**\\n     * @dev Cancel an operation.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'canceller' role.\\n     */\\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        if (!isOperationPending(id)) {\\n            revert TimelockUnexpectedOperationState(\\n                id,\\n                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)\\n            );\\n        }\\n        delete $._timestamps[id];\\n\\n        emit Cancelled(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a single transaction.\\n     *\\n     * Emits a {CallExecuted} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\\n    // thus any modifications to the operation during reentrancy should be caught.\\n    // slither-disable-next-line reentrancy-eth\\n    function execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata payload,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\\n\\n        _beforeCall(id, predecessor);\\n        _execute(target, value, payload);\\n        emit CallExecuted(id, 0, target, value, payload);\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a batch of transactions.\\n     *\\n     * Emits one {CallExecuted} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\\n    // thus any modifications to the operation during reentrancy should be caught.\\n    // slither-disable-next-line reentrancy-eth\\n    function executeBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata payloads,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\\n        if (targets.length != values.length || targets.length != payloads.length) {\\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\\n        }\\n\\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\\n\\n        _beforeCall(id, predecessor);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            address target = targets[i];\\n            uint256 value = values[i];\\n            bytes calldata payload = payloads[i];\\n            _execute(target, value, payload);\\n            emit CallExecuted(id, i, target, value, payload);\\n        }\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Execute an operation's call.\\n     */\\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        Address.verifyCallResult(success, returndata);\\n    }\\n\\n    /**\\n     * @dev Checks before execution of an operation's calls.\\n     */\\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\\n        if (!isOperationReady(id)) {\\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\\n        }\\n        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {\\n            revert TimelockUnexecutedPredecessor(predecessor);\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks after execution of an operation's calls.\\n     */\\n    function _afterCall(bytes32 id) private {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        if (!isOperationReady(id)) {\\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\\n        }\\n        $._timestamps[id] = _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Changes the minimum timelock duration for future operations.\\n     *\\n     * Emits a {MinDelayChange} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\\n     */\\n    function updateDelay(uint256 newDelay) external virtual {\\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\\n        address sender = _msgSender();\\n        if (sender != address(this)) {\\n            revert TimelockUnauthorizedCaller(sender);\\n        }\\n        emit MinDelayChange($._minDelay, newDelay);\\n        $._minDelay = newDelay;\\n    }\\n\\n    /**\\n     * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to\\n     * the underlying position in the `OperationState` enum. For example:\\n     *\\n     * 0x000...1000\\n     *   ^^^^^^----- ...\\n     *         ^---- Done\\n     *          ^--- Ready\\n     *           ^-- Waiting\\n     *            ^- Unset\\n     */\\n    function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {\\n        return bytes32(1 << uint8(operationState));\\n    }\\n}\\n\",\"keccak256\":\"0x4efd1ce484a3d68bc54401d4e87271e8dbf2e073e174fa0d2c51645123042819\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\\n     *\\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\\n     */\\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\\n        return INITIALIZABLE_STORAGE;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        bytes32 slot = _initializableStorageSlot();\\n        assembly {\\n            $.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {ERC165Upgradeable} from \\\"../../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport {IERC1155Receiver} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport {Initializable} from \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n */\\nabstract contract ERC1155HolderUpgradeable is Initializable, ERC165Upgradeable, IERC1155Receiver {\\n    function __ERC1155Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x64c8658be9360779b99ef60db78d3172be7056e1d078fc1cabf6b693862c831c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {Initializable} from \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\\n * {IERC721-setApprovalForAll}.\\n */\\nabstract contract ERC721HolderUpgradeable is Initializable, IERC721Receiver {\\n    function __ERC721Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x9a4de3d90a92d682de7ec325eb3d032587fbe9782a4bbbf1b1fa72a82b2c06e3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xdbef5f0c787055227243a7318ef74c8a5a1108ca3a07f2b3a00ef67769e1e397\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xc8ed8d2056934b7675b695dec032f2920c2f5c6cf33a17ca85650940675323ab\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted to signal this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\",\"keccak256\":\"0x4d9a2b261b56a1e4a37bb038151dec98b952fed16de2bdfdda27e38e2b12b530\",\"license\":\"MIT\"},\"@openzeppelin/contracts/governance/utils/IVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/IVotes.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\\n */\\ninterface IVotes {\\n    /**\\n     * @dev The signature used has expired.\\n     */\\n    error VotesExpiredSignature(uint256 expiry);\\n\\n    /**\\n     * @dev Emitted when an account changes their delegate.\\n     */\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /**\\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.\\n     */\\n    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);\\n\\n    /**\\n     * @dev Returns the current amount of votes that `account` has.\\n     */\\n    function getVotes(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\\n     */\\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     */\\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the delegate that `account` has chosen.\\n     */\\n    function delegates(address account) external view returns (address);\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     */\\n    function delegate(address delegatee) external;\\n\\n    /**\\n     * @dev Delegates votes from signer to `delegatee`.\\n     */\\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\",\"keccak256\":\"0x5e2b397ae88fd5c68e4f6762eb9f65f65c36702eb57796495f471d024ce70947\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Create2} from \\\"../utils/Create2.sol\\\";\\nimport {Errors} from \\\"../utils/Errors.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    error CloneArgumentsTooLong();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        return clone(implementation, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\\n     * to the new contract.\\n     *\\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\\n     */\\n    function clone(address implementation, uint256 value) internal returns (address instance) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(value, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        return cloneDeterministic(implementation, salt, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\\n     * a `value` parameter to send native currency to the new contract.\\n     *\\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\\n     */\\n    function cloneDeterministic(\\n        address implementation,\\n        bytes32 salt,\\n        uint256 value\\n    ) internal returns (address instance) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(value, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\\n     * access the arguments within the implementation, use {fetchCloneArgs}.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\\n        return cloneWithImmutableArgs(implementation, args, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\\n     * parameter to send native currency to the new contract.\\n     *\\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\\n     */\\n    function cloneWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        uint256 value\\n    ) internal returns (address instance) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\\n        assembly (\\\"memory-safe\\\") {\\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\\n        }\\n        if (instance == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\\n     * access the arguments within the implementation, use {fetchCloneArgs}.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\\n     * at the same address.\\n     */\\n    function cloneDeterministicWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        bytes32 salt\\n    ) internal returns (address instance) {\\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\\n     * but with a `value` parameter to send native currency to the new contract.\\n     *\\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\\n     */\\n    function cloneDeterministicWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        bytes32 salt,\\n        uint256 value\\n    ) internal returns (address instance) {\\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\\n        return Create2.deploy(value, salt, bytecode);\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\\n     */\\n    function predictDeterministicAddressWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\\n     */\\n    function predictDeterministicAddressWithImmutableArgs(\\n        address implementation,\\n        bytes memory args,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\\n    }\\n\\n    /**\\n     * @dev Get the immutable args attached to a clone.\\n     *\\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\\n     *   function will return an empty array.\\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\\n     *   creation.\\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\\n     *   function should only be used to check addresses that are known to be clones.\\n     */\\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\\n        assembly (\\\"memory-safe\\\") {\\n            extcodecopy(instance, add(result, 32), 45, mload(result))\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\\n     *\\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\\n     * abi.encodePacked is more expensive but also more portable and easier to review.\\n     *\\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\\n     */\\n    function _cloneCodeWithImmutableArgs(\\n        address implementation,\\n        bytes memory args\\n    ) private pure returns (bytes memory) {\\n        if (args.length > 24531) revert CloneArgumentsTooLong();\\n        return\\n            abi.encodePacked(\\n                hex\\\"61\\\",\\n                uint16(args.length + 45),\\n                hex\\\"3d81600a3d39f3363d3d373d3d3d363d73\\\",\\n                implementation,\\n                hex\\\"5af43d82803e903d91602b57fd5bf3\\\",\\n                args\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x7162fa3c6971aa6f0a70160fed018edbb8b1db3af9b034ef3f7c224c3bdb7431\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x61a23d601c2ab69dd726ac55058604cbda98e1d728ba31a51c379a3f9eeea715\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC-721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC-721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xb5afb8e8eebc4d1c6404df2f5e1e6d2c3d24fd01e5dfc855314951ecfaae462d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            _revert(returndata);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {Errors.FailedCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\\n     * of an unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {Errors.FailedCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaa1d17c1129b127a4a401db2fbd72960e2671474be3d08cae71ccdc42f7624c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev There's no code to deploy.\\n     */\\n    error Create2EmptyBytecode();\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n        if (bytecode.length == 0) {\\n            revert Create2EmptyBytecode();\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n            // if no address was created, and returndata is not empty, bubble revert\\n            if and(iszero(addr), not(iszero(returndatasize()))) {\\n                let p := mload(0x40)\\n                returndatacopy(p, 0, returndatasize())\\n                revert(p, returndatasize())\\n            }\\n        }\\n        if (addr == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbb7e8401583d26268ea9103013bcdcd90866a7718bd91105ebd21c9bf11f4f06\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\",\"keccak256\":\"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"contracts/core/QueueProposalState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {AutomationCompatibleInterface} from '@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol';\\n\\nimport {IGovernor} from '../core/interfaces/IGovernor.sol';\\nimport {ConsumerUpgradable} from '../core/upgradable/ConsumerUpgradable.sol';\\n\\ncontract QueueProposalState is\\n\\tAutomationCompatibleInterface,\\n\\tConsumerUpgradable\\n{\\n\\t/// ======================\\n\\t/// ======= Events =======\\n\\t/// ======================\\n\\n\\tevent ProposalQueued(\\n\\t\\taddress indexed dao,\\n\\t\\tuint256 indexed daoId,\\n\\t\\tuint256 indexed proposalId,\\n\\t\\tuint256 snapshot,\\n\\t\\tuint256 proposalBlock,\\n\\t\\taddress voteToken\\n\\t);\\n\\n\\tevent ProposalDequeued(\\n\\t\\taddress indexed dao,\\n\\t\\tuint256 indexed daoId,\\n\\t\\tuint256 indexed proposalId,\\n\\t\\tuint256 snapshot,\\n\\t\\tuint256 proposalBlock,\\n\\t\\taddress voteToken,\\n\\t\\tstring[] args\\n\\t);\\n\\n\\t/// ==========================\\n\\t/// === External Functions ===\\n\\t/// ==========================\\n\\n\\tfunction checkUpkeep(\\n\\t\\tbytes calldata /* checkData */\\n\\t)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\toverride\\n\\t\\treturns (bool upkeepNeeded, bytes memory performData)\\n\\t{\\n\\t\\tuint256 count = 0;\\n\\n\\t\\tfor (uint256 i = 0; i < queue.length; ) {\\n\\t\\t\\t// Check if snapshot is in the past and hasn't been processed\\n\\t\\t\\tif (\\n\\t\\t\\t\\tqueue[i].snapshot <= block.timestamp &&\\n\\t\\t\\t\\t!proposals[queue[i].dao][queue[i].proposalId].queued\\n\\t\\t\\t) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (count == 0) {\\n\\t\\t\\treturn (false, bytes(''));\\n\\t\\t}\\n\\n\\t\\tProposal[] memory proposalsToProcess = new Proposal[](count);\\n\\t\\tuint256 index = 0;\\n\\n\\t\\tfor (uint256 i = 0; i < queue.length; ) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\tqueue[i].snapshot <= block.timestamp &&\\n\\t\\t\\t\\t!proposals[queue[i].dao][queue[i].proposalId].queued\\n\\t\\t\\t) {\\n\\t\\t\\t\\tproposalsToProcess[index] = queue[i];\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tperformData = abi.encode(proposalsToProcess);\\n\\t\\tupkeepNeeded = true;\\n\\t}\\n\\n\\tfunction performUpkeep(bytes calldata performData) external override {\\n\\t\\tProposal[] memory proposalsToProcess = abi.decode(\\n\\t\\t\\tperformData,\\n\\t\\t\\t(Proposal[])\\n\\t\\t);\\n\\n\\t\\tuint256 validCount = 0;\\n\\t\\tfor (uint256 i = 0; i < proposalsToProcess.length; ) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t!proposals[proposalsToProcess[i].dao][proposalsToProcess[i].proposalId]\\n\\t\\t\\t\\t\\t.queued\\n\\t\\t\\t) {\\n\\t\\t\\t\\tvalidCount++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring[] memory args = new string[](validCount);\\n\\t\\tProposal[] memory validProposals = new Proposal[](validCount);\\n\\n\\t\\tuint256 index = 0;\\n\\n\\t\\tfor (uint256 i = 0; i < proposalsToProcess.length; ) {\\n\\t\\t\\tProposal memory p = proposalsToProcess[i];\\n\\n\\t\\t\\tif (!proposals[p.dao][p.proposalId].queued) {\\n\\t\\t\\t\\tproposals[p.dao][p.proposalId].queued = true;\\n\\n\\t\\t\\t\\tstring memory serialized = string(\\n\\t\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\t'dao=',\\n\\t\\t\\t\\t\\t\\t_toAsciiString(address(p.dao)),\\n\\t\\t\\t\\t\\t\\t';daoId=',\\n\\t\\t\\t\\t\\t\\t_uintToString(p.daoId),\\n\\t\\t\\t\\t\\t\\t';proposalId=',\\n\\t\\t\\t\\t\\t\\t_uintToString(p.proposalId),\\n\\t\\t\\t\\t\\t\\t';snapshot=',\\n\\t\\t\\t\\t\\t\\t_uintToString(p.snapshot),\\n\\t\\t\\t\\t\\t\\t';proposalBlock=',\\n\\t\\t\\t\\t\\t\\t_uintToString(p.proposalBlock),\\n\\t\\t\\t\\t\\t\\t';voteToken=',\\n\\t\\t\\t\\t\\t\\t_toAsciiString(p.voteToken)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\targs[index] = serialized;\\n\\t\\t\\t\\tvalidProposals[index] = p;\\n\\n\\t\\t\\t\\temit ProposalDequeued(\\n\\t\\t\\t\\t\\taddress(p.dao),\\n\\t\\t\\t\\t\\tp.daoId,\\n\\t\\t\\t\\t\\tp.proposalId,\\n\\t\\t\\t\\t\\tp.snapshot,\\n\\t\\t\\t\\t\\tp.proposalBlock,\\n\\t\\t\\t\\t\\tp.voteToken,\\n\\t\\t\\t\\t\\targs\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (validCount > 0) {\\n\\t\\t\\tsendRequest(\\n\\t\\t\\t\\tSendRequestParams({\\n\\t\\t\\t\\t\\tsource: source,\\n\\t\\t\\t\\t\\tencryptedSecretsUrls: '',\\n\\t\\t\\t\\t\\tdonHostedSecretsSlotID: 0,\\n\\t\\t\\t\\t\\tdonHostedSecretsVersion: 0,\\n\\t\\t\\t\\t\\targs: args,\\n\\t\\t\\t\\t\\tbytesArgs: new bytes[](0),\\n\\t\\t\\t\\t\\tsubscriptionId: subscriptionId,\\n\\t\\t\\t\\t\\tgasLimit: gasLimit,\\n\\t\\t\\t\\t\\tdonID: donID\\n\\t\\t\\t\\t}),\\n\\t\\t\\t\\tvalidProposals\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/// ==========================\\n\\t/// === Internal Functions ===\\n\\t/// ==========================\\n\\n\\tfunction _queueProposal(\\n\\t\\tuint256 _daoId,\\n\\t\\tuint256 _proposalId,\\n\\t\\tuint256 _snapshot,\\n\\t\\tuint256 _proposalBlock,\\n\\t\\taddress voteToken\\n\\t) internal virtual {\\n\\t\\tqueue.push(\\n\\t\\t\\tProposal({\\n\\t\\t\\t\\tdao: IGovernor(msg.sender),\\n\\t\\t\\t\\tdaoId: _daoId,\\n\\t\\t\\t\\tproposalId: _proposalId,\\n\\t\\t\\t\\tsnapshot: _snapshot,\\n\\t\\t\\t\\tproposalBlock: _proposalBlock,\\n\\t\\t\\t\\tvoteToken: voteToken,\\n\\t\\t\\t\\tqueued: false,\\n\\t\\t\\t\\texecuted: false\\n\\t\\t\\t})\\n\\t\\t);\\n\\n\\t\\temit ProposalQueued(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\t_daoId,\\n\\t\\t\\t_proposalId,\\n\\t\\t\\t_snapshot,\\n\\t\\t\\t_proposalBlock,\\n\\t\\t\\tvoteToken\\n\\t\\t);\\n\\t}\\n\\n\\t/// ==========================\\n\\t/// === Private Functions ====\\n\\t/// ==========================\\n\\n\\tfunction _uintToString(uint256 v) private pure returns (string memory) {\\n\\t\\tif (v == 0) return '0';\\n\\t\\tuint256 digits;\\n\\t\\tuint256 temp = v;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\t\\twhile (v != 0) {\\n\\t\\t\\tdigits -= 1;\\n\\t\\t\\tbuffer[digits] = bytes1(uint8(48 + uint256(v % 10)));\\n\\t\\t\\tv /= 10;\\n\\t\\t}\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\tfunction _toAsciiString(address x) private pure returns (string memory) {\\n\\t\\tbytes memory s = new bytes(42);\\n\\t\\ts[0] = '0';\\n\\t\\ts[1] = 'x';\\n\\t\\tfor (uint256 i = 0; i < 20; i++) {\\n\\t\\t\\tbytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n\\t\\t\\tbytes1 hi = bytes1(uint8(b) / 16);\\n\\t\\t\\tbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n\\t\\t\\ts[2 * i + 2] = char(hi);\\n\\t\\t\\ts[2 * i + 3] = char(lo);\\n\\t\\t}\\n\\t\\treturn string(s);\\n\\t}\\n\\n\\tfunction char(bytes1 b) internal pure returns (bytes1 c) {\\n\\t\\tif (uint8(b) < 10) return bytes1(uint8(b) + 48);\\n\\t\\telse return bytes1(uint8(b) + 87);\\n\\t}\\n}\\n\",\"keccak256\":\"0x787a0182fc847624cc99502152a267d859947f3742d21b2acfb2affe11cec516\",\"license\":\"MIT\"},\"contracts/core/Verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.21;\\n\\nuint256 constant N = 32768;\\nuint256 constant LOG_N = 15;\\nuint256 constant NUMBER_OF_PUBLIC_INPUTS = 5;\\nlibrary HonkVerificationKey {\\n    function loadVerificationKey() internal pure returns (Honk.VerificationKey memory) {\\n        Honk.VerificationKey memory vk = Honk.VerificationKey({\\n            circuitSize: uint256(32768),\\n            logCircuitSize: uint256(15),\\n            publicInputsSize: uint256(5),\\n            ql: Honk.G1Point({ \\n               x: uint256(0x1b1092bfed678627bca6b5a99b59c9ed5fd36f7b2b94638535d516425520d2f2),\\n               y: uint256(0x0875649701394e7ff747aebfe9995b6277c41239102307d3ed5ae3efa635ff60)\\n            }),\\n            qr: Honk.G1Point({ \\n               x: uint256(0x2db4c0f63283b12104d836618e596e9955e985145dfb65afb3c9a5a2d0f941c0),\\n               y: uint256(0x0ccea7773e23b76dfa4bdbf1913d63afd180d7a681ef0b92a6a11fd1114f53d0)\\n            }),\\n            qo: Honk.G1Point({ \\n               x: uint256(0x212475f0e5df3e081336acb4662ae12a94ceb3745fdb74bf71c07bd5befff9ca),\\n               y: uint256(0x28d3429ca78c158bc155a25c17e77f97240034300045c1d9ad44394a33360aae)\\n            }),\\n            q4: Honk.G1Point({ \\n               x: uint256(0x16af7cb31da36b7dff154123eae8dca035f87e9ea6714210f951ff5b521bd283),\\n               y: uint256(0x0dafd73d3b7814e213bd91c8e4818ebeb7c666ba096f55d85583abcb48c9ab87)\\n            }),\\n            qm: Honk.G1Point({ \\n               x: uint256(0x21c550b1438dc8ebf5f9438329c27618816b2c7e9be26f61d1e7d2694746885d),\\n               y: uint256(0x1ec48a96d3af92361a0fe36ae346a66cec238ce38c1cef88a4d78603c4260c76)\\n            }),\\n            qc: Honk.G1Point({ \\n               x: uint256(0x036338794bc2e83abbda87c36617321e22505c6bc0676f05f1c031e568a85cbb),\\n               y: uint256(0x231b7ee64eaaececcf97e8870455356283644d0103e0df2e9d245cefbf9dc352)\\n            }),\\n            qArith: Honk.G1Point({ \\n               x: uint256(0x116de5b81a5aede5009ac50504cc96c09294bb6fbe5def4b3ad188d54f79d180),\\n               y: uint256(0x1a34e2a2a6a760b403436c589aeaf52763391e112cd5e904345f31e8a43c1ee8)\\n            }),\\n            qDeltaRange: Honk.G1Point({ \\n               x: uint256(0x05e2b2f1955f1adcb4cb10cb5d3456e6ae27cca4a63b80c9ada0b7438c78731a),\\n               y: uint256(0x189bbff856b447150480dcdb46433ef04cdc876932c6b279bd3c834e69474d1f)\\n            }),\\n            qElliptic: Honk.G1Point({ \\n               x: uint256(0x0e1fe04bfd9ad6c98620a71c94a21e9ae34e3186408269d382320ecdcc05f71d),\\n               y: uint256(0x19a1658d0bec3d05105e47174451a1446b9c9518272290f7e4df1df36788bb6c)\\n            }),\\n            qAux: Honk.G1Point({ \\n               x: uint256(0x17538e283d556aeef5673a93baef0b804bcffa6c0058a388f95316999a5a12b2),\\n               y: uint256(0x231373bf0a19b80ad59b3da467140a8a5c478ca52b349be55fccd8923be14db8)\\n            }),\\n            qLookup: Honk.G1Point({ \\n               x: uint256(0x027dc243c05f23b486f9eddc248b1502cd25d3fe70199576d12356fc34eb831e),\\n               y: uint256(0x2669855d180b3d2c7677536f6d50a01fb3a6f44b5d443582e317db8f9d8dd380)\\n            }),\\n            qPoseidon2External: Honk.G1Point({ \\n               x: uint256(0x0b56d6bc6e5f978b95dd7e5ed06c70bb9ef89ee0b9b1f6d6a6e6fe7bc7fb1cee),\\n               y: uint256(0x03fba156c032a430dbc1cacd26a4072bd08a66e1026bb789122cfc4c103cdc60)\\n            }),\\n            qPoseidon2Internal: Honk.G1Point({ \\n               x: uint256(0x0801455a876c4270411c837cbeb379fc9fd12c9e01d5aba455995debbf0470a0),\\n               y: uint256(0x191ab369271555acecba302d5d55823db826986dc9469c0c6939b1bce23f5920)\\n            }),\\n            s1: Honk.G1Point({ \\n               x: uint256(0x119759bfe9b61d27e14ab8c4ebf525f944041414f0ca1fb16e7871966f0f25ab),\\n               y: uint256(0x0fa2a98d7de50338ecf094557777e66950c71db125af27f498755c741241bc50)\\n            }),\\n            s2: Honk.G1Point({ \\n               x: uint256(0x08632a9f81ce23086c2300fcaba6ebd6383514e0d6dfbbeb41f750a5bad8f3cc),\\n               y: uint256(0x012ad0b2e84e362d7b3006337ea54b6e913f8005765e94bfce71a9121a99ed27)\\n            }),\\n            s3: Honk.G1Point({ \\n               x: uint256(0x10300b6250541ff656ce3d17fce4414e068d8ea8453eb463fc00166877e66335),\\n               y: uint256(0x1fc730854625e8897b70e5b3cda42db6077caedb73e32d2fe5e183ce361cebd6)\\n            }),\\n            s4: Honk.G1Point({ \\n               x: uint256(0x228bdcd463340ca888acad29309d10c0cbf2d0eb1693b4343094c8f3e271845c),\\n               y: uint256(0x06fa9848b3528e73aaa70bf5d00ada429a03d9b35165f1ecfa614484a195eb7f)\\n            }),\\n            t1: Honk.G1Point({ \\n               x: uint256(0x05ad93e0fe6cf03567818848f653efbeee650b46b0d5f2202f0db8ee947d7072),\\n               y: uint256(0x03bd3ca762932d873c5d25b87f90863f6b947d117ff5838a8d05b65855851ad0)\\n            }),\\n            t2: Honk.G1Point({ \\n               x: uint256(0x0881565dfaaf132c953c6e460cc8fbdf0bb7cf36fcfbf05ebccaf19c8e2a909c),\\n               y: uint256(0x204841f77b1d2ad6ca17f1541fcf6dacb1fb3669eb96642d1216232f2af35fa0)\\n            }),\\n            t3: Honk.G1Point({ \\n               x: uint256(0x2d755645e77ad802d8f528b276d99daee804bd57ed6c868264cafa1edef61e2e),\\n               y: uint256(0x0049b63f4c8b8560b3b780e5789f446b2e41de12e4518051f3cf2ad67470f38f)\\n            }),\\n            t4: Honk.G1Point({ \\n               x: uint256(0x22fc466c501266a499f94edac355eb757e4e218feb442c864acef0c0134f36d5),\\n               y: uint256(0x21535849fd42cd6f1f52800e55249888ca81684e332c640686309bad09b1a94c)\\n            }),\\n            id1: Honk.G1Point({ \\n               x: uint256(0x025fbda737380b401a4da92433644e80ce2177a5f9369689c3e1e8517c1922fe),\\n               y: uint256(0x0b668d47c870c3c350859737408695f8f10ca6c60f45469f98441fac8142d1f7)\\n            }),\\n            id2: Honk.G1Point({ \\n               x: uint256(0x2ea775f9bb3204487df29d1719c5eca067ac7329010121259571f7000cdf5ab4),\\n               y: uint256(0x19df1692fe7b1626f0316327113c853905730e9151364e24cd258f6133402911)\\n            }),\\n            id3: Honk.G1Point({ \\n               x: uint256(0x2a98104cba05d493b08483a1cf0d03a7d02350fde55f58f38a6e1f37980819cc),\\n               y: uint256(0x2afe213e7be609b7e0b4dc7415828998a316fb8e6c9ecbc91544d3ec76717cb4)\\n            }),\\n            id4: Honk.G1Point({ \\n               x: uint256(0x25bfc35e0017fd04d8144ee8eff19a7014892a108c37fa0c50c77a2932344b24),\\n               y: uint256(0x2959f14438e433acb2c23cd56cf3f5410eda8fb36f8064310dc71a44c08ee072)\\n            }),\\n            lagrangeFirst: Honk.G1Point({ \\n               x: uint256(0x0000000000000000000000000000000000000000000000000000000000000001),\\n               y: uint256(0x0000000000000000000000000000000000000000000000000000000000000002)\\n            }),\\n            lagrangeLast: Honk.G1Point({ \\n               x: uint256(0x13baf8ffa7bed9be034c147165999d94297328cbc1f54b8d8e6d0d60983d2cdc),\\n               y: uint256(0x0f35e40238b49695cbdb41c437de2bc05dbda0ff9bb1f35481e9738bcf912ca7)\\n            })\\n        });\\n        return vk;\\n    }\\n}\\n\\npragma solidity ^0.8.27;\\n\\ntype Fr is uint256;\\n\\nusing { add as + } for Fr global;\\nusing { sub as - } for Fr global;\\nusing { mul as * } for Fr global;\\nusing { exp as ^ } for Fr global;\\nusing { notEqual as != } for Fr global;\\nusing { equal as == } for Fr global;\\n\\nuint256 constant MODULUS =\\n    21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order\\n\\nFr constant MINUS_ONE = Fr.wrap(MODULUS - 1);\\n\\n// Instantiation\\nlibrary FrLib\\n{\\n    function from(uint256 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(value % MODULUS);\\n    }\\n\\n    function fromBytes32(bytes32 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(uint256(value) % MODULUS);\\n    }\\n\\n    function toBytes32(Fr value) internal pure returns(bytes32)\\n    {\\n        return bytes32(Fr.unwrap(value));\\n    }\\n\\n    function invert(Fr value) internal view returns(Fr)\\n    {\\n        uint256 v = Fr.unwrap(value);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), v)\\n            mstore(add(free, 0x80), sub(MODULUS, 2))\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function pow(Fr base, uint256 v) internal view returns(Fr)\\n    {\\n        uint256 b = Fr.unwrap(base);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), b)\\n            mstore(add(free, 0x80), v)\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function div(Fr numerator, Fr denominator) internal view returns(Fr)\\n    {\\n        return numerator * invert(denominator);\\n    }\\n\\n    function sqr(Fr value) internal pure returns (Fr) {\\n        return value * value;\\n    }\\n\\n    function unwrap(Fr value) internal pure returns (uint256) {\\n        return Fr.unwrap(value);\\n    }\\n\\n    function neg(Fr value) internal pure returns (Fr) {\\n        return Fr.wrap(MODULUS - Fr.unwrap(value));\\n    }\\n}\\n\\n// Free functions\\nfunction add(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction mul(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(mulmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction sub(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), MODULUS - Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction exp(Fr base, Fr exponent) pure returns(Fr)\\n{\\n    if (Fr.unwrap(exponent) == 0) return Fr.wrap(1);\\n\\n    for (uint256 i = 1; i < Fr.unwrap(exponent); i += i) {\\n        base = base * base;\\n    }\\n    return base;\\n}\\n\\nfunction notEqual(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) != Fr.unwrap(b);\\n}\\n\\nfunction equal(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) == Fr.unwrap(b);\\n}\\n\\nuint256 constant CONST_PROOF_SIZE_LOG_N = 28;\\n\\nuint256 constant NUMBER_OF_SUBRELATIONS = 26;\\nuint256 constant BATCHED_RELATION_PARTIAL_LENGTH = 8;\\nuint256 constant NUMBER_OF_ENTITIES = 40;\\nuint256 constant NUMBER_UNSHIFTED = 35;\\nuint256 constant NUMBER_TO_BE_SHIFTED = 5;\\n\\n// Alphas are used as relation separators so there should be NUMBER_OF_SUBRELATIONS - 1\\nuint256 constant NUMBER_OF_ALPHAS = 25;\\n\\n// Prime field order\\nuint256 constant Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583; // EC group order. F_q\\nuint256 constant P = 21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order, F_r\\n\\n// ENUM FOR WIRES\\nenum WIRE {\\n    Q_M,\\n    Q_C,\\n    Q_L,\\n    Q_R,\\n    Q_O,\\n    Q_4,\\n    Q_LOOKUP,\\n    Q_ARITH,\\n    Q_RANGE,\\n    Q_ELLIPTIC,\\n    Q_AUX,\\n    Q_POSEIDON2_EXTERNAL,\\n    Q_POSEIDON2_INTERNAL,\\n    SIGMA_1,\\n    SIGMA_2,\\n    SIGMA_3,\\n    SIGMA_4,\\n    ID_1,\\n    ID_2,\\n    ID_3,\\n    ID_4,\\n    TABLE_1,\\n    TABLE_2,\\n    TABLE_3,\\n    TABLE_4,\\n    LAGRANGE_FIRST,\\n    LAGRANGE_LAST,\\n    W_L,\\n    W_R,\\n    W_O,\\n    W_4,\\n    Z_PERM,\\n    LOOKUP_INVERSES,\\n    LOOKUP_READ_COUNTS,\\n    LOOKUP_READ_TAGS,\\n    W_L_SHIFT,\\n    W_R_SHIFT,\\n    W_O_SHIFT,\\n    W_4_SHIFT,\\n    Z_PERM_SHIFT\\n}\\n\\nlibrary Honk {\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    struct G1ProofPoint {\\n        uint256 x_0;\\n        uint256 x_1;\\n        uint256 y_0;\\n        uint256 y_1;\\n    }\\n\\n    struct VerificationKey {\\n        // Misc Params\\n        uint256 circuitSize;\\n        uint256 logCircuitSize;\\n        uint256 publicInputsSize;\\n        // Selectors\\n        G1Point qm;\\n        G1Point qc;\\n        G1Point ql;\\n        G1Point qr;\\n        G1Point qo;\\n        G1Point q4;\\n        G1Point qLookup; // Lookup\\n        G1Point qArith; // Arithmetic widget\\n        G1Point qDeltaRange; // Delta Range sort\\n        G1Point qAux; // Auxillary\\n        G1Point qElliptic; // Auxillary\\n        G1Point qPoseidon2External;\\n        G1Point qPoseidon2Internal;\\n        // Copy cnstraints\\n        G1Point s1;\\n        G1Point s2;\\n        G1Point s3;\\n        G1Point s4;\\n        // Copy identity\\n        G1Point id1;\\n        G1Point id2;\\n        G1Point id3;\\n        G1Point id4;\\n        // Precomputed lookup table\\n        G1Point t1;\\n        G1Point t2;\\n        G1Point t3;\\n        G1Point t4;\\n        // Fixed first and last\\n        G1Point lagrangeFirst;\\n        G1Point lagrangeLast;\\n    }\\n\\n    struct RelationParameters {\\n        // challenges\\n        Fr eta;\\n        Fr etaTwo;\\n        Fr etaThree;\\n        Fr beta;\\n        Fr gamma;\\n        // derived\\n        Fr publicInputsDelta;\\n    }\\n\\n\\n    struct Proof {\\n        // Free wires\\n        Honk.G1ProofPoint w1;\\n        Honk.G1ProofPoint w2;\\n        Honk.G1ProofPoint w3;\\n        Honk.G1ProofPoint w4;\\n        // Lookup helpers - Permutations\\n        Honk.G1ProofPoint zPerm;\\n        // Lookup helpers - logup\\n        Honk.G1ProofPoint lookupReadCounts;\\n        Honk.G1ProofPoint lookupReadTags;\\n        Honk.G1ProofPoint lookupInverses;\\n        // Sumcheck\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\\n        // Shplemini\\n        Honk.G1ProofPoint[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\\n        Honk.G1ProofPoint shplonkQ;\\n        Honk.G1ProofPoint kzgQuotient;\\n    }\\n}\\n\\n// Transcript library to generate fiat shamir challenges\\nstruct Transcript {\\n    // Oink\\n    Honk.RelationParameters relationParameters;\\n    Fr[NUMBER_OF_ALPHAS] alphas;\\n    Fr[CONST_PROOF_SIZE_LOG_N] gateChallenges;\\n    // Sumcheck\\n    Fr[CONST_PROOF_SIZE_LOG_N] sumCheckUChallenges;\\n    // Gemini\\n    Fr rho;\\n    Fr geminiR;\\n    // Shplonk\\n    Fr shplonkNu;\\n    Fr shplonkZ;\\n}\\n\\nlibrary TranscriptLib {\\n    function generateTranscript(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Transcript memory t)\\n    {\\n        Fr previousChallenge;\\n        (t.relationParameters, previousChallenge) =\\n            generateRelationParametersChallenges(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset, previousChallenge);\\n\\n        (t.alphas, previousChallenge) = generateAlphaChallenges(previousChallenge, proof);\\n\\n        (t.gateChallenges, previousChallenge) = generateGateChallenges(previousChallenge);\\n\\n        (t.sumCheckUChallenges, previousChallenge) = generateSumcheckChallenges(proof, previousChallenge);\\n\\n        (t.rho, previousChallenge) = generateRhoChallenge(proof, previousChallenge);\\n\\n        (t.geminiR, previousChallenge) = generateGeminiRChallenge(proof, previousChallenge);\\n\\n        (t.shplonkNu, previousChallenge) = generateShplonkNuChallenge(proof, previousChallenge);\\n\\n        (t.shplonkZ, previousChallenge) = generateShplonkZChallenge(proof, previousChallenge);\\n\\n        return t;\\n    }\\n\\n    function splitChallenge(Fr challenge) internal pure returns (Fr first, Fr second) {\\n        uint256 challengeU256 = uint256(Fr.unwrap(challenge));\\n        uint256 lo = challengeU256 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        uint256 hi = challengeU256 >> 128;\\n        first = FrLib.fromBytes32(bytes32(lo));\\n        second = FrLib.fromBytes32(bytes32(hi));\\n    }\\n\\n    function generateRelationParametersChallenges(\\n        Honk.Proof memory proof,\\n        bytes32[] calldata publicInputs,\\n        uint256 circuitSize,\\n        uint256 publicInputsSize,\\n        uint256 pubInputsOffset,\\n        Fr previousChallenge\\n    ) internal pure returns (Honk.RelationParameters memory rp, Fr nextPreviousChallenge) {\\n        (rp.eta, rp.etaTwo, rp.etaThree, previousChallenge) =\\n            generateEtaChallenge(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset);\\n\\n        (rp.beta, rp.gamma, nextPreviousChallenge) = generateBetaAndGammaChallenges(previousChallenge, proof);\\n\\n    }\\n\\n    function generateEtaChallenge(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Fr eta, Fr etaTwo, Fr etaThree, Fr previousChallenge)\\n    {\\n        bytes32[] memory round0 = new bytes32[](3 + publicInputsSize + 12);\\n        round0[0] = bytes32(circuitSize);\\n        round0[1] = bytes32(publicInputsSize);\\n        round0[2] = bytes32(pubInputsOffset);\\n        for (uint256 i = 0; i < publicInputsSize; i++) {\\n            round0[3 + i] = bytes32(publicInputs[i]);\\n        }\\n\\n        // Create the first challenge\\n        // Note: w4 is added to the challenge later on\\n        round0[3 + publicInputsSize] = bytes32(proof.w1.x_0);\\n        round0[3 + publicInputsSize + 1] = bytes32(proof.w1.x_1);\\n        round0[3 + publicInputsSize + 2] = bytes32(proof.w1.y_0);\\n        round0[3 + publicInputsSize + 3] = bytes32(proof.w1.y_1);\\n        round0[3 + publicInputsSize + 4] = bytes32(proof.w2.x_0);\\n        round0[3 + publicInputsSize + 5] = bytes32(proof.w2.x_1);\\n        round0[3 + publicInputsSize + 6] = bytes32(proof.w2.y_0);\\n        round0[3 + publicInputsSize + 7] = bytes32(proof.w2.y_1);\\n        round0[3 + publicInputsSize + 8] = bytes32(proof.w3.x_0);\\n        round0[3 + publicInputsSize + 9] = bytes32(proof.w3.x_1);\\n        round0[3 + publicInputsSize + 10] = bytes32(proof.w3.y_0);\\n        round0[3 + publicInputsSize + 11] = bytes32(proof.w3.y_1);\\n\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round0)));\\n        (eta, etaTwo) = splitChallenge(previousChallenge);\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n        Fr unused;\\n        (etaThree, unused) = splitChallenge(previousChallenge);\\n    }\\n\\n    function generateBetaAndGammaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr beta, Fr gamma, Fr nextPreviousChallenge)\\n    {\\n        bytes32[13] memory round1;\\n        round1[0] = FrLib.toBytes32(previousChallenge);\\n        round1[1] = bytes32(proof.lookupReadCounts.x_0);\\n        round1[2] = bytes32(proof.lookupReadCounts.x_1);\\n        round1[3] = bytes32(proof.lookupReadCounts.y_0);\\n        round1[4] = bytes32(proof.lookupReadCounts.y_1);\\n        round1[5] = bytes32(proof.lookupReadTags.x_0);\\n        round1[6] = bytes32(proof.lookupReadTags.x_1);\\n        round1[7] = bytes32(proof.lookupReadTags.y_0);\\n        round1[8] = bytes32(proof.lookupReadTags.y_1);\\n        round1[9] = bytes32(proof.w4.x_0);\\n        round1[10] = bytes32(proof.w4.x_1);\\n        round1[11] = bytes32(proof.w4.y_0);\\n        round1[12] = bytes32(proof.w4.y_1);\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round1)));\\n        (beta, gamma) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    // Alpha challenges non-linearise the gate contributions\\n    function generateAlphaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr[NUMBER_OF_ALPHAS] memory alphas, Fr nextPreviousChallenge)\\n    {\\n        // Generate the original sumcheck alpha 0 by hashing zPerm and zLookup\\n        uint256[9] memory alpha0;\\n        alpha0[0] = Fr.unwrap(previousChallenge);\\n        alpha0[1] = proof.lookupInverses.x_0;\\n        alpha0[2] = proof.lookupInverses.x_1;\\n        alpha0[3] = proof.lookupInverses.y_0;\\n        alpha0[4] = proof.lookupInverses.y_1;\\n        alpha0[5] = proof.zPerm.x_0;\\n        alpha0[6] = proof.zPerm.x_1;\\n        alpha0[7] = proof.zPerm.y_0;\\n        alpha0[8] = proof.zPerm.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(alpha0)));\\n        (alphas[0], alphas[1]) = splitChallenge(nextPreviousChallenge);\\n\\n        for (uint256 i = 1; i < NUMBER_OF_ALPHAS / 2; i++) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            (alphas[2 * i], alphas[2 * i + 1]) = splitChallenge(nextPreviousChallenge);\\n        }\\n        if (((NUMBER_OF_ALPHAS & 1) == 1) && (NUMBER_OF_ALPHAS > 2)) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            Fr unused;\\n            (alphas[NUMBER_OF_ALPHAS - 1], unused) = splitChallenge(nextPreviousChallenge);\\n        }\\n    }\\n\\n    function generateGateChallenges(Fr previousChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory gateChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n            Fr unused;\\n            (gateChallenges[i], unused) = splitChallenge(previousChallenge);\\n        }\\n        nextPreviousChallenge = previousChallenge;\\n    }\\n\\n    function generateSumcheckChallenges(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH + 1] memory univariateChal;\\n            univariateChal[0] = prevChallenge;\\n\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                univariateChal[j + 1] = proof.sumcheckUnivariates[i][j];\\n            }\\n            prevChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(univariateChal)));\\n            Fr unused;\\n            (sumcheckChallenges[i], unused) = splitChallenge(prevChallenge);\\n        }\\n        nextPreviousChallenge = prevChallenge;\\n    }\\n\\n    function generateRhoChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr rho, Fr nextPreviousChallenge)\\n    {\\n        Fr[NUMBER_OF_ENTITIES + 1] memory rhoChallengeElements;\\n        rhoChallengeElements[0] = prevChallenge;\\n\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            rhoChallengeElements[i + 1] = proof.sumcheckEvaluations[i];\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(rhoChallengeElements)));\\n        Fr unused;\\n        (rho, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateGeminiRChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr geminiR, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N - 1) * 4 + 1] memory gR;\\n        gR[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            gR[1 + i * 4] = proof.geminiFoldComms[i].x_0;\\n            gR[2 + i * 4] = proof.geminiFoldComms[i].x_1;\\n            gR[3 + i * 4] = proof.geminiFoldComms[i].y_0;\\n            gR[4 + i * 4] = proof.geminiFoldComms[i].y_1;\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(gR)));\\n        Fr unused;\\n        (geminiR, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkNuChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkNu, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N) + 1] memory shplonkNuChallengeElements;\\n        shplonkNuChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            shplonkNuChallengeElements[i + 1] = Fr.unwrap(proof.geminiAEvaluations[i]);\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkNuChallengeElements)));\\n        Fr unused;\\n        (shplonkNu, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkZChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkZ, Fr nextPreviousChallenge)\\n    {\\n        uint256[5] memory shplonkZChallengeElements;\\n        shplonkZChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        shplonkZChallengeElements[1] = proof.shplonkQ.x_0;\\n        shplonkZChallengeElements[2] = proof.shplonkQ.x_1;\\n        shplonkZChallengeElements[3] = proof.shplonkQ.y_0;\\n        shplonkZChallengeElements[4] = proof.shplonkQ.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkZChallengeElements)));\\n        Fr unused;\\n        (shplonkZ, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function loadProof(bytes calldata proof) internal pure returns (Honk.Proof memory p) {\\n        // Commitments\\n        p.w1 = bytesToG1ProofPoint(proof[0x0:0x80]);\\n\\n        p.w2 = bytesToG1ProofPoint(proof[0x80:0x100]);\\n        p.w3 = bytesToG1ProofPoint(proof[0x100:0x180]);\\n\\n        // Lookup / Permutation Helper Commitments\\n        p.lookupReadCounts = bytesToG1ProofPoint(proof[0x180:0x200]);\\n        p.lookupReadTags = bytesToG1ProofPoint(proof[0x200:0x280]);\\n        p.w4 = bytesToG1ProofPoint(proof[0x280:0x300]);\\n        p.lookupInverses = bytesToG1ProofPoint(proof[0x300:0x380]);\\n        p.zPerm = bytesToG1ProofPoint(proof[0x380:0x400]);\\n        uint256 boundary = 0x400;\\n\\n        // Sumcheck univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                p.sumcheckUnivariates[i][j] = bytesToFr(proof[boundary:boundary + 0x20]);\\n                boundary += 0x20;\\n            }\\n        }\\n        // Sumcheck evaluations\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            p.sumcheckEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Gemini\\n        // Read gemini fold univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            p.geminiFoldComms[i] = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n            boundary += 0x80;\\n        }\\n\\n        // Read gemini a evaluations\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            p.geminiAEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Shplonk\\n        p.shplonkQ = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n        boundary = boundary + 0x80;\\n        // KZG\\n        p.kzgQuotient = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n    }\\n}\\n\\n\\n// Fr utility\\n\\nfunction bytesToFr(bytes calldata proofSection) pure returns (Fr scalar) {\\n    require(proofSection.length == 0x20, \\\"invalid bytes scalar\\\");\\n    scalar = FrLib.fromBytes32(bytes32(proofSection));\\n}\\n\\n// EC Point utilities\\nfunction convertProofPoint(Honk.G1ProofPoint memory input) pure returns (Honk.G1Point memory) {\\n    return Honk.G1Point({x: input.x_0 | (input.x_1 << 136), y: input.y_0 | (input.y_1 << 136)});\\n}\\n\\nfunction bytesToG1ProofPoint(bytes calldata proofSection) pure returns (Honk.G1ProofPoint memory point) {\\n    require(proofSection.length == 0x80, \\\"invalid bytes point\\\");\\n    point = Honk.G1ProofPoint({\\n        x_0: uint256(bytes32(proofSection[0x00:0x20])),\\n        x_1: uint256(bytes32(proofSection[0x20:0x40])),\\n        y_0: uint256(bytes32(proofSection[0x40:0x60])),\\n        y_1: uint256(bytes32(proofSection[0x60:0x80]))\\n    });\\n}\\n\\nfunction negateInplace(Honk.G1Point memory point) pure returns (Honk.G1Point memory) {\\n    point.y = (Q - point.y) % Q;\\n    return point;\\n}\\n\\n function pairing(Honk.G1Point memory rhs, Honk.G1Point memory lhs) view returns (bool) {\\n        bytes memory input = abi.encodePacked(\\n            rhs.x,\\n            rhs.y,\\n            // Fixed G1 point\\n            uint256(0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2),\\n            uint256(0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed),\\n            uint256(0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b),\\n            uint256(0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa),\\n            lhs.x,\\n            lhs.y,\\n            // G1 point from VK\\n            uint256(0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1),\\n            uint256(0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0),\\n            uint256(0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4),\\n            uint256(0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\\n        );\\n\\n        (bool success, bytes memory result) = address(0x08).staticcall(input);\\n        bool decodedResult = abi.decode(result, (bool));\\n        return success && decodedResult;\\n    }\\n\\n\\nlibrary RelationsLib {\\n    Fr internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = Fr.wrap(17); // -(-17)\\n\\n    function accumulateRelationEvaluations(\\n         Fr[NUMBER_OF_ENTITIES] memory purportedEvaluations,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_ALPHAS] memory alphas,\\n        Fr powPartialEval\\n    ) internal pure returns (Fr accumulator) {\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations;\\n\\n        // Accumulate all relations in Ultra Honk - each with varying number of subrelations\\n        accumulateArithmeticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePermutationRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateLogDerivativeLookupRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateDeltaRangeRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateEllipticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateAuxillaryRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulatePoseidonExternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePoseidonInternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        // batch the subrelations with the alpha challenges to obtain the full honk relation\\n        accumulator = scaleAndBatchSubrelations(evaluations, alphas);\\n    }\\n\\n    /**\\n     * Aesthetic helper function that is used to index by enum into proof.sumcheckEvaluations, it avoids\\n     * the relation checking code being cluttered with uint256 type casting, which is often a different colour in code\\n     * editors, and thus is noisy.\\n     */\\n    function wire(Fr[NUMBER_OF_ENTITIES] memory p, WIRE _wire) internal pure returns (Fr) {\\n        return p[uint256(_wire)];\\n    }\\n\\n    uint256 internal constant NEG_HALF_MODULO_P = 0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    /**\\n     * Ultra Arithmetic Relation\\n     *\\n     */\\n    function accumulateArithmeticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        // Relation 0\\n        Fr q_arith = wire(p, WIRE.Q_ARITH);\\n        {\\n            Fr neg_half = Fr.wrap(NEG_HALF_MODULO_P);\\n\\n            Fr accum = (q_arith - Fr.wrap(3)) * (wire(p, WIRE.Q_M) * wire(p, WIRE.W_R) * wire(p, WIRE.W_L)) * neg_half;\\n            accum = accum + (wire(p, WIRE.Q_L) * wire(p, WIRE.W_L)) + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_R))\\n                + (wire(p, WIRE.Q_O) * wire(p, WIRE.W_O)) + (wire(p, WIRE.Q_4) * wire(p, WIRE.W_4)) + wire(p, WIRE.Q_C);\\n            accum = accum + (q_arith - Fr.wrap(1)) * wire(p, WIRE.W_4_SHIFT);\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[0] = accum;\\n        }\\n\\n        // Relation 1\\n        {\\n            Fr accum = wire(p, WIRE.W_L) + wire(p, WIRE.W_4) - wire(p, WIRE.W_L_SHIFT) + wire(p, WIRE.Q_M);\\n            accum = accum * (q_arith - Fr.wrap(2));\\n            accum = accum * (q_arith - Fr.wrap(1));\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[1] = accum;\\n        }\\n    }\\n\\n    function accumulatePermutationRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr grand_product_numerator;\\n        Fr grand_product_denominator;\\n\\n        {\\n            Fr num = wire(p, WIRE.W_L) + wire(p, WIRE.ID_1) * rp.beta + rp.gamma;\\n            num = num * (wire(p, WIRE.W_R) + wire(p, WIRE.ID_2) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_O) + wire(p, WIRE.ID_3) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_4) + wire(p, WIRE.ID_4) * rp.beta + rp.gamma);\\n\\n            grand_product_numerator = num;\\n        }\\n        {\\n            Fr den = wire(p, WIRE.W_L) + wire(p, WIRE.SIGMA_1) * rp.beta + rp.gamma;\\n            den = den * (wire(p, WIRE.W_R) + wire(p, WIRE.SIGMA_2) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_O) + wire(p, WIRE.SIGMA_3) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_4) + wire(p, WIRE.SIGMA_4) * rp.beta + rp.gamma);\\n\\n            grand_product_denominator = den;\\n        }\\n\\n        // Contribution 2\\n        {\\n            Fr acc = (wire(p, WIRE.Z_PERM) + wire(p, WIRE.LAGRANGE_FIRST)) * grand_product_numerator;\\n\\n            acc = acc\\n                - (\\n                    (wire(p, WIRE.Z_PERM_SHIFT) + (wire(p, WIRE.LAGRANGE_LAST) * rp.publicInputsDelta))\\n                        * grand_product_denominator\\n                );\\n            acc = acc * domainSep;\\n            evals[2] = acc;\\n        }\\n\\n        // Contribution 3\\n        {\\n            Fr acc = (wire(p, WIRE.LAGRANGE_LAST) * wire(p, WIRE.Z_PERM_SHIFT)) * domainSep;\\n            evals[3] = acc;\\n        }\\n    }\\n\\n    function accumulateLogDerivativeLookupRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr write_term;\\n        Fr read_term;\\n\\n        // Calculate the write term (the table accumulation)\\n        {\\n            write_term = wire(p, WIRE.TABLE_1) + rp.gamma + (wire(p, WIRE.TABLE_2) * rp.eta)\\n                + (wire(p, WIRE.TABLE_3) * rp.etaTwo) + (wire(p, WIRE.TABLE_4) * rp.etaThree);\\n        }\\n\\n        // Calculate the write term\\n        {\\n            Fr derived_entry_1 = wire(p, WIRE.W_L) + rp.gamma + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_L_SHIFT));\\n            Fr derived_entry_2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_M) * wire(p, WIRE.W_R_SHIFT);\\n            Fr derived_entry_3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_C) * wire(p, WIRE.W_O_SHIFT);\\n\\n            read_term = derived_entry_1 + (derived_entry_2 * rp.eta) + (derived_entry_3 * rp.etaTwo)\\n                + (wire(p, WIRE.Q_O) * rp.etaThree);\\n        }\\n\\n        Fr read_inverse = wire(p, WIRE.LOOKUP_INVERSES) * write_term;\\n        Fr write_inverse = wire(p, WIRE.LOOKUP_INVERSES) * read_term;\\n\\n        Fr inverse_exists_xor = wire(p, WIRE.LOOKUP_READ_TAGS) + wire(p, WIRE.Q_LOOKUP)\\n            - (wire(p, WIRE.LOOKUP_READ_TAGS) * wire(p, WIRE.Q_LOOKUP));\\n\\n        // Inverse calculated correctly relation\\n        Fr accumulatorNone = read_term * write_term * wire(p, WIRE.LOOKUP_INVERSES) - inverse_exists_xor;\\n        accumulatorNone = accumulatorNone * domainSep;\\n\\n        // Inverse\\n        Fr accumulatorOne = wire(p, WIRE.Q_LOOKUP) * read_inverse - wire(p, WIRE.LOOKUP_READ_COUNTS) * write_inverse;\\n\\n        evals[4] = accumulatorNone;\\n        evals[5] = accumulatorOne;\\n    }\\n\\n    function accumulateDeltaRangeRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr minus_one = Fr.wrap(0) - Fr.wrap(1);\\n        Fr minus_two = Fr.wrap(0) - Fr.wrap(2);\\n        Fr minus_three = Fr.wrap(0) - Fr.wrap(3);\\n\\n        // Compute wire differences\\n        Fr delta_1 = wire(p, WIRE.W_R) - wire(p, WIRE.W_L);\\n        Fr delta_2 = wire(p, WIRE.W_O) - wire(p, WIRE.W_R);\\n        Fr delta_3 = wire(p, WIRE.W_4) - wire(p, WIRE.W_O);\\n        Fr delta_4 = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_4);\\n\\n        // Contribution 6\\n        {\\n            Fr acc = delta_1;\\n            acc = acc * (delta_1 + minus_one);\\n            acc = acc * (delta_1 + minus_two);\\n            acc = acc * (delta_1 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[6] = acc;\\n        }\\n\\n        // Contribution 7\\n        {\\n            Fr acc = delta_2;\\n            acc = acc * (delta_2 + minus_one);\\n            acc = acc * (delta_2 + minus_two);\\n            acc = acc * (delta_2 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[7] = acc;\\n        }\\n\\n        // Contribution 8\\n        {\\n            Fr acc = delta_3;\\n            acc = acc * (delta_3 + minus_one);\\n            acc = acc * (delta_3 + minus_two);\\n            acc = acc * (delta_3 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[8] = acc;\\n        }\\n\\n        // Contribution 9\\n        {\\n            Fr acc = delta_4;\\n            acc = acc * (delta_4 + minus_one);\\n            acc = acc * (delta_4 + minus_two);\\n            acc = acc * (delta_4 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[9] = acc;\\n        }\\n    }\\n\\n    struct EllipticParams {\\n        // Points\\n        Fr x_1;\\n        Fr y_1;\\n        Fr x_2;\\n        Fr y_2;\\n        Fr y_3;\\n        Fr x_3;\\n        // push accumulators into memory\\n        Fr x_double_identity;\\n    }\\n\\n    function accumulateEllipticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        EllipticParams memory ep;\\n        ep.x_1 = wire(p, WIRE.W_R);\\n        ep.y_1 = wire(p, WIRE.W_O);\\n\\n        ep.x_2 = wire(p, WIRE.W_L_SHIFT);\\n        ep.y_2 = wire(p, WIRE.W_4_SHIFT);\\n        ep.y_3 = wire(p, WIRE.W_O_SHIFT);\\n        ep.x_3 = wire(p, WIRE.W_R_SHIFT);\\n\\n        Fr q_sign = wire(p, WIRE.Q_L);\\n        Fr q_is_double = wire(p, WIRE.Q_M);\\n\\n        // Contribution 10 point addition, x-coordinate check\\n        // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n        Fr x_diff = (ep.x_2 - ep.x_1);\\n        Fr y1_sqr = (ep.y_1 * ep.y_1);\\n        {\\n            // Move to top\\n            Fr partialEval = domainSep;\\n\\n            Fr y2_sqr = (ep.y_2 * ep.y_2);\\n            Fr y1y2 = ep.y_1 * ep.y_2 * q_sign;\\n            Fr x_add_identity = (ep.x_3 + ep.x_2 + ep.x_1);\\n            x_add_identity = x_add_identity * x_diff * x_diff;\\n            x_add_identity = x_add_identity - y2_sqr - y1_sqr + y1y2 + y1y2;\\n\\n            evals[10] = x_add_identity * partialEval * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 11 point addition, x-coordinate check\\n        // q_elliptic * (q_sign * y1 + y3)(x2 - x1) + (x3 - x1)(y2 - q_sign * y1) = 0\\n        {\\n            Fr y1_plus_y3 = ep.y_1 + ep.y_3;\\n            Fr y_diff = ep.y_2 * q_sign - ep.y_1;\\n            Fr y_add_identity = y1_plus_y3 * x_diff + (ep.x_3 - ep.x_1) * y_diff;\\n            evals[11] = y_add_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 10 point doubling, x-coordinate check\\n        // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n        // N.B. we're using the equivalence x1*x1*x1 === y1*y1 - curve_b to reduce degree by 1\\n        {\\n            Fr x_pow_4 = (y1_sqr + GRUMPKIN_CURVE_B_PARAMETER_NEGATED) * ep.x_1;\\n            Fr y1_sqr_mul_4 = y1_sqr + y1_sqr;\\n            y1_sqr_mul_4 = y1_sqr_mul_4 + y1_sqr_mul_4;\\n            Fr x1_pow_4_mul_9 = x_pow_4 * Fr.wrap(9);\\n\\n            // NOTE: pushed into memory (stack >:'( )\\n            ep.x_double_identity = (ep.x_3 + ep.x_1 + ep.x_1) * y1_sqr_mul_4 - x1_pow_4_mul_9;\\n\\n            Fr acc = ep.x_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n            evals[10] = evals[10] + acc;\\n        }\\n\\n        // Contribution 11 point doubling, y-coordinate check\\n        // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n        {\\n            Fr x1_sqr_mul_3 = (ep.x_1 + ep.x_1 + ep.x_1) * ep.x_1;\\n            Fr y_double_identity = x1_sqr_mul_3 * (ep.x_1 - ep.x_3) - (ep.y_1 + ep.y_1) * (ep.y_1 + ep.y_3);\\n            evals[11] = evals[11] + y_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n        }\\n    }\\n\\n    // Constants for the auxiliary relation\\n    Fr constant LIMB_SIZE = Fr.wrap(uint256(1) << 68);\\n    Fr constant SUBLIMB_SHIFT = Fr.wrap(uint256(1) << 14);\\n\\n    // Parameters used within the Auxiliary Relation\\n    // A struct is used to work around stack too deep. This relation has alot of variables\\n    struct AuxParams {\\n        Fr limb_subproduct;\\n        Fr non_native_field_gate_1;\\n        Fr non_native_field_gate_2;\\n        Fr non_native_field_gate_3;\\n        Fr limb_accumulator_1;\\n        Fr limb_accumulator_2;\\n        Fr memory_record_check;\\n        Fr partial_record_check;\\n        Fr next_gate_access_type;\\n        Fr record_delta;\\n        Fr index_delta;\\n        Fr adjacent_values_match_if_adjacent_indices_match;\\n        Fr adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n        Fr access_check;\\n        Fr next_gate_access_type_is_boolean;\\n        Fr ROM_consistency_check_identity;\\n        Fr RAM_consistency_check_identity;\\n        Fr timestamp_delta;\\n        Fr RAM_timestamp_check_identity;\\n        Fr memory_identity;\\n        Fr index_is_monotonically_increasing;\\n        Fr auxiliary_identity;\\n    }\\n\\n    function accumulateAuxillaryRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        AuxParams memory ap;\\n\\n        /**\\n         * Contribution 12\\n         * Non native field arithmetic gate 2\\n         * deg 4\\n         *\\n         *             _                                                                               _\\n         *            /   _                   _                               _       14                \\\\\\n         * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n         *            \\\\_                                                                               _/\\n         *\\n         *\\n         */\\n        ap.limb_subproduct = wire(p, WIRE.W_L) * wire(p, WIRE.W_R_SHIFT) + wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R);\\n        ap.non_native_field_gate_2 =\\n            (wire(p, WIRE.W_L) * wire(p, WIRE.W_4) + wire(p, WIRE.W_R) * wire(p, WIRE.W_O) - wire(p, WIRE.W_O_SHIFT));\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * LIMB_SIZE;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 + ap.limb_subproduct;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * wire(p, WIRE.Q_4);\\n\\n        ap.limb_subproduct = ap.limb_subproduct * LIMB_SIZE;\\n        ap.limb_subproduct = ap.limb_subproduct + (wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R_SHIFT));\\n        ap.non_native_field_gate_1 = ap.limb_subproduct;\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 - (wire(p, WIRE.W_O) + wire(p, WIRE.W_4));\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 * wire(p, WIRE.Q_O);\\n\\n        ap.non_native_field_gate_3 = ap.limb_subproduct;\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 + wire(p, WIRE.W_4);\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 - (wire(p, WIRE.W_O_SHIFT) + wire(p, WIRE.W_4_SHIFT));\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 * wire(p, WIRE.Q_M);\\n\\n        Fr non_native_field_identity =\\n            ap.non_native_field_gate_1 + ap.non_native_field_gate_2 + ap.non_native_field_gate_3;\\n        non_native_field_identity = non_native_field_identity * wire(p, WIRE.Q_R);\\n\\n        // ((((w2' * 2^14 + w1') * 2^14 + w3) * 2^14 + w2) * 2^14 + w1 - w4) * qm\\n        // deg 2\\n        ap.limb_accumulator_1 = wire(p, WIRE.W_R_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_R);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 - wire(p, WIRE.W_4);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * wire(p, WIRE.Q_4);\\n\\n        // ((((w3' * 2^14 + w2') * 2^14 + w1') * 2^14 + w4) * 2^14 + w3 - w4') * qm\\n        // deg 2\\n        ap.limb_accumulator_2 = wire(p, WIRE.W_O_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_R_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_4);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * wire(p, WIRE.Q_M);\\n\\n        Fr limb_accumulator_identity = ap.limb_accumulator_1 + ap.limb_accumulator_2;\\n        limb_accumulator_identity = limb_accumulator_identity * wire(p, WIRE.Q_O); //  deg 3\\n\\n        /**\\n         * MEMORY\\n         *\\n         * A RAM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * t: `timestamp` of memory cell being accessed (used for RAM, set to 0 for ROM)\\n         *  * v: `value` of memory cell being accessed\\n         *  * a: `access` type of record. read: 0 = read, 1 = write\\n         *  * r: `record` of memory cell. record = access + index * eta + timestamp * eta_two + value * eta_three\\n         *\\n         * A ROM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * v: `value1` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * v2:`value2` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * r: `record` of memory cell. record = index * eta + value2 * eta_two + value1 * eta_three\\n         *\\n         *  When performing a read/write access, the values of i, t, v, v2, a, r are stored in the following wires +\\n         * selectors, depending on whether the gate is a RAM read/write or a ROM read\\n         *\\n         *  | gate type | i  | v2/t  |  v | a  | r  |\\n         *  | --------- | -- | ----- | -- | -- | -- |\\n         *  | ROM       | w1 | w2    | w3 | -- | w4 |\\n         *  | RAM       | w1 | w2    | w3 | qc | w4 |\\n         *\\n         * (for accesses where `index` is a circuit constant, it is assumed the circuit will apply a copy constraint on\\n         * `w2` to fix its value)\\n         *\\n         *\\n         */\\n\\n        /**\\n         * Memory Record Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * A ROM/ROM access gate can be evaluated with the identity:\\n         *\\n         * qc + w1 \\\\eta + w2 \\\\eta_two + w3 \\\\eta_three - w4 = 0\\n         *\\n         * For ROM gates, qc = 0\\n         */\\n        ap.memory_record_check = wire(p, WIRE.W_O) * rp.etaThree;\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_R) * rp.etaTwo);\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_L) * rp.eta);\\n        ap.memory_record_check = ap.memory_record_check + wire(p, WIRE.Q_C);\\n        ap.partial_record_check = ap.memory_record_check; // used in RAM consistency check; deg 1 or 4\\n        ap.memory_record_check = ap.memory_record_check - wire(p, WIRE.W_4);\\n\\n        /**\\n         * Contribution 13 & 14\\n         * ROM Consistency Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * For every ROM read, a set equivalence check is applied between the record witnesses, and a second set of\\n         * records that are sorted.\\n         *\\n         * We apply the following checks for the sorted records:\\n         *\\n         * 1. w1, w2, w3 correctly map to 'index', 'v1, 'v2' for a given record value at w4\\n         * 2. index values for adjacent records are monotonically increasing\\n         * 3. if, at gate i, index_i == index_{i + 1}, then value1_i == value1_{i + 1} and value2_i == value2_{i + 1}\\n         *\\n         */\\n        ap.index_delta = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_L);\\n        ap.record_delta = wire(p, WIRE.W_4_SHIFT) - wire(p, WIRE.W_4);\\n\\n        ap.index_is_monotonically_increasing = ap.index_delta * ap.index_delta - ap.index_delta; // deg 2\\n\\n        ap.adjacent_values_match_if_adjacent_indices_match = (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.record_delta; // deg 2\\n\\n        evals[13] = ap.adjacent_values_match_if_adjacent_indices_match * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n        evals[14] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n\\n        ap.ROM_consistency_check_identity = ap.memory_record_check * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R)); // deg 3 or 7\\n\\n        /**\\n         * Contributions 15,16,17\\n         * RAM Consistency Check\\n         *\\n         * The 'access' type of the record is extracted with the expression `w_4 - ap.partial_record_check`\\n         * (i.e. for an honest Prover `w1 * eta + w2 * eta^2 + w3 * eta^3 - w4 = access`.\\n         * This is validated by requiring `access` to be boolean\\n         *\\n         * For two adjacent entries in the sorted list if _both_\\n         *  A) index values match\\n         *  B) adjacent access value is 0 (i.e. next gate is a READ)\\n         * then\\n         *  C) both values must match.\\n         * The gate boolean check is\\n         * (A && B) => C  === !(A && B) || C ===  !A || !B || C\\n         *\\n         * N.B. it is the responsibility of the circuit writer to ensure that every RAM cell is initialized\\n         * with a WRITE operation.\\n         */\\n        Fr access_type = (wire(p, WIRE.W_4) - ap.partial_record_check); // will be 0 or 1 for honest Prover; deg 1 or 4\\n        ap.access_check = access_type * access_type - access_type; // check value is 0 or 1; deg 2 or 8\\n\\n        ap.next_gate_access_type = wire(p, WIRE.W_O_SHIFT) * rp.etaThree;\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_R_SHIFT) * rp.etaTwo);\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_L_SHIFT) * rp.eta);\\n        ap.next_gate_access_type = wire(p, WIRE.W_4_SHIFT) - ap.next_gate_access_type;\\n\\n        Fr value_delta = wire(p, WIRE.W_O_SHIFT) - wire(p, WIRE.W_O);\\n        ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (\\n            ap.index_delta * MINUS_ONE + Fr.wrap(1)\\n        ) * value_delta * (ap.next_gate_access_type * MINUS_ONE + Fr.wrap(1)); // deg 3 or 6\\n\\n        // We can't apply the RAM consistency check identity on the final entry in the sorted list (the wires in the\\n        // next gate would make the identity fail).  We need to validate that its 'access type' bool is correct. Can't\\n        // do  with an arithmetic gate because of the  `eta` factors. We need to check that the *next* gate's access\\n        // type is  correct, to cover this edge case\\n        // deg 2 or 4\\n        ap.next_gate_access_type_is_boolean =\\n            ap.next_gate_access_type * ap.next_gate_access_type - ap.next_gate_access_type;\\n\\n        // Putting it all together...\\n        evals[15] = ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation\\n            * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5 or 8\\n        evals[16] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4\\n        evals[17] = ap.next_gate_access_type_is_boolean * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 6\\n\\n        ap.RAM_consistency_check_identity = ap.access_check * (wire(p, WIRE.Q_ARITH)); // deg 3 or 9\\n\\n        /**\\n         * RAM Timestamp Consistency Check\\n         *\\n         * | w1 | w2 | w3 | w4 |\\n         * | index | timestamp | timestamp_check | -- |\\n         *\\n         * Let delta_index = index_{i + 1} - index_{i}\\n         *\\n         * Iff delta_index == 0, timestamp_check = timestamp_{i + 1} - timestamp_i\\n         * Else timestamp_check = 0\\n         */\\n        ap.timestamp_delta = wire(p, WIRE.W_R_SHIFT) - wire(p, WIRE.W_R);\\n        ap.RAM_timestamp_check_identity =\\n            (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.timestamp_delta - wire(p, WIRE.W_O); // deg 3\\n\\n        /**\\n         * Complete Contribution 12\\n         * The complete RAM/ROM memory identity\\n         * Partial degree:\\n         */\\n        ap.memory_identity = ap.ROM_consistency_check_identity; // deg 3 or 6\\n        ap.memory_identity =\\n            ap.memory_identity + ap.RAM_timestamp_check_identity * (wire(p, WIRE.Q_4) * wire(p, WIRE.Q_L)); // deg 4\\n        ap.memory_identity = ap.memory_identity + ap.memory_record_check * (wire(p, WIRE.Q_M) * wire(p, WIRE.Q_L)); // deg 3 or 6\\n        ap.memory_identity = ap.memory_identity + ap.RAM_consistency_check_identity; // deg 3 or 9\\n\\n        // (deg 3 or 9) + (deg 4) + (deg 3)\\n        ap.auxiliary_identity = ap.memory_identity + non_native_field_identity + limb_accumulator_identity;\\n        ap.auxiliary_identity = ap.auxiliary_identity * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 10\\n        evals[12] = ap.auxiliary_identity;\\n    }\\n\\n    struct PoseidonExternalParams {\\n        Fr s1;\\n        Fr s2;\\n        Fr s3;\\n        Fr s4;\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr t0;\\n        Fr t1;\\n        Fr t2;\\n        Fr t3;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonExternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonExternalParams memory ep;\\n\\n        ep.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n        ep.s2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_R);\\n        ep.s3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_O);\\n        ep.s4 = wire(p, WIRE.W_4) + wire(p, WIRE.Q_4);\\n\\n        ep.u1 = ep.s1 * ep.s1 * ep.s1 * ep.s1 * ep.s1;\\n        ep.u2 = ep.s2 * ep.s2 * ep.s2 * ep.s2 * ep.s2;\\n        ep.u3 = ep.s3 * ep.s3 * ep.s3 * ep.s3 * ep.s3;\\n        ep.u4 = ep.s4 * ep.s4 * ep.s4 * ep.s4 * ep.s4;\\n        // matrix mul v = M_E * u with 14 additions\\n        ep.t0 = ep.u1 + ep.u2; // u_1 + u_2\\n        ep.t1 = ep.u3 + ep.u4; // u_3 + u_4\\n        ep.t2 = ep.u2 + ep.u2 + ep.t1; // 2u_2\\n        // ep.t2 += ep.t1; // 2u_2 + u_3 + u_4\\n        ep.t3 = ep.u4 + ep.u4 + ep.t0; // 2u_4\\n        // ep.t3 += ep.t0; // u_1 + u_2 + 2u_4\\n        ep.v4 = ep.t1 + ep.t1;\\n        ep.v4 = ep.v4 + ep.v4 + ep.t3;\\n        // ep.v4 += ep.t3; // u_1 + u_2 + 4u_3 + 6u_4\\n        ep.v2 = ep.t0 + ep.t0;\\n        ep.v2 = ep.v2 + ep.v2 + ep.t2;\\n        // ep.v2 += ep.t2; // 4u_1 + 6u_2 + u_3 + u_4\\n        ep.v1 = ep.t3 + ep.v2; // 5u_1 + 7u_2 + u_3 + 3u_4\\n        ep.v3 = ep.t2 + ep.v4; // u_1 + 3u_2 + 5u_3 + 7u_4\\n\\n        ep.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_EXTERNAL) * domainSep;\\n        evals[18] = evals[18] + ep.q_pos_by_scaling * (ep.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        evals[19] = evals[19] + ep.q_pos_by_scaling * (ep.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        evals[20] = evals[20] + ep.q_pos_by_scaling * (ep.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        evals[21] = evals[21] + ep.q_pos_by_scaling * (ep.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    struct PoseidonInternalParams {\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr u_sum;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr s1;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonInternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonInternalParams memory ip;\\n\\n        Fr[4] memory INTERNAL_MATRIX_DIAGONAL = [\\n            FrLib.from(0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7),\\n            FrLib.from(0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b),\\n            FrLib.from(0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15),\\n            FrLib.from(0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b)\\n        ];\\n\\n        // add round constants\\n        ip.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n\\n        // apply s-box round\\n        ip.u1 = ip.s1 * ip.s1 * ip.s1 * ip.s1 * ip.s1;\\n        ip.u2 = wire(p, WIRE.W_R);\\n        ip.u3 = wire(p, WIRE.W_O);\\n        ip.u4 = wire(p, WIRE.W_4);\\n\\n        // matrix mul with v = M_I * u 4 muls and 7 additions\\n        ip.u_sum = ip.u1 + ip.u2 + ip.u3 + ip.u4;\\n\\n        ip.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_INTERNAL) * domainSep;\\n\\n        ip.v1 = ip.u1 * INTERNAL_MATRIX_DIAGONAL[0] + ip.u_sum;\\n        evals[22] = evals[22] + ip.q_pos_by_scaling * (ip.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        ip.v2 = ip.u2 * INTERNAL_MATRIX_DIAGONAL[1] + ip.u_sum;\\n        evals[23] = evals[23] + ip.q_pos_by_scaling * (ip.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        ip.v3 = ip.u3 * INTERNAL_MATRIX_DIAGONAL[2] + ip.u_sum;\\n        evals[24] = evals[24] + ip.q_pos_by_scaling * (ip.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        ip.v4 = ip.u4 * INTERNAL_MATRIX_DIAGONAL[3] + ip.u_sum;\\n        evals[25] = evals[25] + ip.q_pos_by_scaling * (ip.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    function scaleAndBatchSubrelations(\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations,\\n        Fr[NUMBER_OF_ALPHAS] memory subrelationChallenges\\n    ) internal pure returns (Fr accumulator) {\\n        accumulator = accumulator + evaluations[0];\\n\\n        for (uint256 i = 1; i < NUMBER_OF_SUBRELATIONS; ++i) {\\n            accumulator = accumulator + evaluations[i] * subrelationChallenges[i - 1];\\n        }\\n    }\\n}\\n\\nstruct ShpleminiIntermediates {\\n    Fr unshiftedScalar;\\n    Fr shiftedScalar;\\n    // Scalar to be multiplied by [1]\\u2081\\n    Fr constantTermAccumulator;\\n    // Accumulator for powers of rho\\n    Fr batchingChallenge;\\n    // Linear combination of multilinear (sumcheck) evaluations and powers of rho\\n    Fr batchedEvaluation;\\n    // 1/(z - r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr posInvertedDenominator;\\n    // 1/(z + r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr negInvertedDenominator;\\n    // v^{2i} * 1/(z - r^{2^i})\\n    Fr scalingFactorPos;\\n    // v^{2i+1} * 1/(z + r^{2^i})\\n    Fr scalingFactorNeg;\\n    // // Fold_i(r^{2^i}) reconstructed by Verifier\\n    // Fr[CONST_PROOF_SIZE_LOG_N] foldPosEvaluations;\\n}\\n\\nlibrary CommitmentSchemeLib {\\n    using FrLib for Fr;\\n\\n    function computeSquares(Fr r) internal pure returns (Fr[CONST_PROOF_SIZE_LOG_N] memory squares) {\\n        squares[0] = r;\\n        for (uint256 i = 1; i < CONST_PROOF_SIZE_LOG_N; ++i) {\\n            squares[i] = squares[i - 1].sqr();\\n        }\\n    }\\n\\n    // Compute the evaluations  A_l(r^{2^l}) for l = 0, ..., m-1\\n    function computeFoldPosEvaluations(\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckUChallenges,\\n        Fr batchedEvalAccumulator,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvaluations,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvalChallengePowers,\\n        uint256 logSize\\n    ) internal view returns (Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations) {\\n        for (uint256 i = CONST_PROOF_SIZE_LOG_N; i > 0; --i) {\\n            Fr challengePower = geminiEvalChallengePowers[i - 1];\\n            Fr u = sumcheckUChallenges[i - 1];\\n\\n            Fr batchedEvalRoundAcc = (\\n                (challengePower * batchedEvalAccumulator * Fr.wrap(2))\\n                    - geminiEvaluations[i - 1] * (challengePower * (Fr.wrap(1) - u) - u)\\n            );\\n            // Divide by the denominator\\n            batchedEvalRoundAcc = batchedEvalRoundAcc * (challengePower * (Fr.wrap(1) - u) + u).invert();\\n\\n            if (i <= logSize) {\\n                batchedEvalAccumulator = batchedEvalRoundAcc;\\n                foldPosEvaluations[i - 1] = batchedEvalRoundAcc;\\n            }\\n        }\\n\\n    }\\n}\\n\\ninterface IVerifier {\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool);\\n}\\n\\n\\nabstract contract BaseHonkVerifier is IVerifier {\\n    using FrLib for Fr;\\n\\n    uint256 immutable n;\\n    uint256 immutable logN;\\n    uint256 immutable numPublicInputs;\\n\\n    constructor(uint256 _n, uint256 _logN, uint256 _numPublicInputs) {\\n        n = _n;\\n        logN = _logN;\\n        numPublicInputs = _numPublicInputs;\\n    }\\n\\n    error ProofLengthWrong();\\n    error PublicInputsLengthWrong();\\n    error SumcheckFailed();\\n    error ShpleminiFailed();\\n\\n    // Number of field elements in a ultra honk zero knowledge proof\\n    uint256 constant PROOF_SIZE = 456;\\n\\n    function loadVerificationKey() internal pure virtual returns (Honk.VerificationKey memory);\\n\\n    function verify(bytes calldata proof, bytes32[] calldata publicInputs) public view override returns (bool) {\\n         // Check the received proof is the expected size where each field element is 32 bytes\\n        if (proof.length != PROOF_SIZE * 32) {\\n            revert ProofLengthWrong();\\n        }\\n\\n        Honk.VerificationKey memory vk = loadVerificationKey();\\n        Honk.Proof memory p = TranscriptLib.loadProof(proof);\\n\\n        if (publicInputs.length != vk.publicInputsSize) {\\n            revert PublicInputsLengthWrong();\\n        }\\n\\n        // Generate the fiat shamir challenges for the whole protocol\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        Transcript memory t = TranscriptLib.generateTranscript(p, publicInputs, vk.circuitSize, vk.publicInputsSize, /*pubInputsOffset=*/1);\\n\\n        // Derive public input delta\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        t.relationParameters.publicInputsDelta = computePublicInputDelta(\\n            publicInputs, t.relationParameters.beta, t.relationParameters.gamma, /*pubInputsOffset=*/1\\n        );\\n\\n        // Sumcheck\\n        bool sumcheckVerified = verifySumcheck(p, t);\\n\\n        return !sumcheckVerified; // Boolean condition not required - nice for vanity :)\\n    }\\n\\n    function computePublicInputDelta(bytes32[] memory publicInputs, Fr beta, Fr gamma, uint256 offset)\\n        internal\\n        view\\n        returns (Fr publicInputDelta)\\n    {\\n        Fr numerator = Fr.wrap(1);\\n        Fr denominator = Fr.wrap(1);\\n\\n        Fr numeratorAcc = gamma + (beta * FrLib.from(n + offset));\\n        Fr denominatorAcc = gamma - (beta * FrLib.from(offset + 1));\\n\\n        {\\n            for (uint256 i = 0; i < numPublicInputs; i++) {\\n                Fr pubInput = FrLib.fromBytes32(publicInputs[i]);\\n\\n                numerator = numerator * (numeratorAcc + pubInput);\\n                denominator = denominator * (denominatorAcc + pubInput);\\n\\n                numeratorAcc = numeratorAcc + beta;\\n                denominatorAcc = denominatorAcc - beta;\\n            }\\n        }\\n\\n        // Fr delta = numerator / denominator; // TOOO: batch invert later?\\n        publicInputDelta = FrLib.div(numerator, denominator);\\n    }\\n\\n    function verifySumcheck(Honk.Proof memory proof, Transcript memory tp) internal view returns (bool verified) {\\n        Fr roundTarget;\\n        Fr powPartialEvaluation = Fr.wrap(1);\\n\\n        // We perform sumcheck reductions over log n rounds ( the multivariate degree )\\n        for (uint256 round; round < logN; ++round) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate = proof.sumcheckUnivariates[round];\\n            Fr roundChallenge = tp.sumCheckUChallenges[round];\\n\\n            // Update the round target for the next rounf\\n            roundTarget = computeNextTargetSum(roundUnivariate, roundChallenge);\\n            powPartialEvaluation = partiallyEvaluatePOW(tp.gateChallenges[round], powPartialEvaluation, roundChallenge);\\n        }\\n\\n        // Last round\\n        Fr grandHonkRelationSum =\\n            RelationsLib.accumulateRelationEvaluations(proof.sumcheckEvaluations, tp.relationParameters, tp.alphas, powPartialEvaluation);\\n        verified = (grandHonkRelationSum == roundTarget);\\n    }\\n\\n    function checkSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate, Fr roundTarget)\\n        internal\\n        pure\\n        returns (bool checked)\\n    {\\n        Fr totalSum = roundUnivariate[0] + roundUnivariate[1];\\n        checked = totalSum == roundTarget;\\n    }\\n\\n    // Return the new target sum for the next sumcheck round\\n    function computeNextTargetSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariates, Fr roundChallenge)\\n        internal\\n        view\\n        returns (Fr targetSum)\\n    {\\n        // TODO: inline\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory BARYCENTRIC_LAGRANGE_DENOMINATORS = [\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000002d0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff11),\\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000000090),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff71),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000000f0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000013b0)\\n        ];\\n\\n        // To compute the next target sum, we evaluate the given univariate at a point u (challenge).\\n\\n        // Performing Barycentric evaluations\\n        // Compute B(x)\\n        Fr numeratorValue = Fr.wrap(1);\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            numeratorValue = numeratorValue * (roundChallenge - Fr.wrap(i));\\n        }\\n\\n        // Calculate domain size N of inverses\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory denominatorInverses;\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr inv = BARYCENTRIC_LAGRANGE_DENOMINATORS[i];\\n            inv = inv * (roundChallenge - Fr.wrap(i));\\n            inv = FrLib.invert(inv);\\n            denominatorInverses[i] = inv;\\n        }\\n\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr term = roundUnivariates[i];\\n            term = term * denominatorInverses[i];\\n            targetSum = targetSum + term;\\n        }\\n\\n        // Scale the sum by the value of B(x)\\n        targetSum = targetSum * numeratorValue;\\n    }\\n\\n    // Univariate evaluation of the monomial ((1-X_l) + X_l.B_l) at the challenge point X_l=u_l\\n    function partiallyEvaluatePOW(Fr gateChallenge, Fr currentEvaluation, Fr roundChallenge)\\n        internal\\n        pure\\n        returns (Fr newEvaluation)\\n    {\\n        Fr univariateEval = Fr.wrap(1) + (roundChallenge * (gateChallenge - Fr.wrap(1)));\\n        newEvaluation = currentEvaluation * univariateEval;\\n    }\\n\\n    function verifyShplemini(Honk.Proof memory proof, Honk.VerificationKey memory vk, Transcript memory tp)\\n        internal\\n        view\\n        returns (bool verified)\\n    {\\n        ShpleminiIntermediates memory mem; // stack\\n\\n        // - Compute vector (r, r\\u00b2, ... , r\\u00b2\\u207d\\u207f\\u207b\\u00b9\\u207e), where n = log_circuit_size\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory powers_of_evaluation_challenge = CommitmentSchemeLib.computeSquares(tp.geminiR);\\n\\n        // Arrays hold values that will be linearly combined for the gemini and shplonk batch openings\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars;\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory commitments;\\n\\n        mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[0]).invert();\\n        mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[0]).invert();\\n\\n        mem.unshiftedScalar = mem.posInvertedDenominator + (tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.shiftedScalar =\\n            tp.geminiR.invert() * (mem.posInvertedDenominator - (tp.shplonkNu * mem.negInvertedDenominator));\\n\\n        scalars[0] = Fr.wrap(1);\\n        commitments[0] = convertProofPoint(proof.shplonkQ);\\n\\n        mem.batchingChallenge = Fr.wrap(1);\\n        mem.batchedEvaluation = Fr.wrap(0);\\n\\n        for (uint256 i = 1; i <= NUMBER_UNSHIFTED; ++i) {\\n            scalars[i] = mem.unshiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n        // g commitments are accumulated at r\\n        for (uint256 i = NUMBER_UNSHIFTED + 1; i <= NUMBER_OF_ENTITIES; ++i) {\\n            scalars[i] = mem.shiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n\\n        commitments[1] = vk.qm;\\n        commitments[2] = vk.qc;\\n        commitments[3] = vk.ql;\\n        commitments[4] = vk.qr;\\n        commitments[5] = vk.qo;\\n        commitments[6] = vk.q4;\\n        commitments[7] = vk.qLookup;\\n        commitments[8] = vk.qArith;\\n        commitments[9] = vk.qDeltaRange;\\n        commitments[10] = vk.qElliptic;\\n        commitments[11] = vk.qAux;\\n        commitments[12] = vk.qPoseidon2External;\\n        commitments[13] = vk.qPoseidon2Internal;\\n        commitments[14] = vk.s1;\\n        commitments[15] = vk.s2;\\n        commitments[16] = vk.s3;\\n        commitments[17] = vk.s4;\\n        commitments[18] = vk.id1;\\n        commitments[19] = vk.id2;\\n        commitments[20] = vk.id3;\\n        commitments[21] = vk.id4;\\n        commitments[22] = vk.t1;\\n        commitments[23] = vk.t2;\\n        commitments[24] = vk.t3;\\n        commitments[25] = vk.t4;\\n        commitments[26] = vk.lagrangeFirst;\\n        commitments[27] = vk.lagrangeLast;\\n\\n        // Accumulate proof points\\n        commitments[28] = convertProofPoint(proof.w1);\\n        commitments[29] = convertProofPoint(proof.w2);\\n        commitments[30] = convertProofPoint(proof.w3);\\n        commitments[31] = convertProofPoint(proof.w4);\\n        commitments[32] = convertProofPoint(proof.zPerm);\\n        commitments[33] = convertProofPoint(proof.lookupInverses);\\n        commitments[34] = convertProofPoint(proof.lookupReadCounts);\\n        commitments[35] = convertProofPoint(proof.lookupReadTags);\\n\\n        // to be Shifted\\n        commitments[36] = convertProofPoint(proof.w1);\\n        commitments[37] = convertProofPoint(proof.w2);\\n        commitments[38] = convertProofPoint(proof.w3);\\n        commitments[39] = convertProofPoint(proof.w4);\\n        commitments[40] = convertProofPoint(proof.zPerm);\\n\\n        // Add contributions from A\\u2080(r) and A\\u2080(-r) to constant_term_accumulator:\\n        // Compute the evaluations A_l(r^{2^l}) for l = 0, ..., logN - 1\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations = CommitmentSchemeLib.computeFoldPosEvaluations(\\n            tp.sumCheckUChallenges,\\n            mem.batchedEvaluation,\\n            proof.geminiAEvaluations,\\n            powers_of_evaluation_challenge,\\n            logN\\n        );\\n\\n        // Compute the Shplonk constant term contributions from A\\u2080(\\u00b1r)\\n        mem.constantTermAccumulator = foldPosEvaluations[0] * mem.posInvertedDenominator;\\n        mem.constantTermAccumulator =\\n            mem.constantTermAccumulator + (proof.geminiAEvaluations[0] * tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.batchingChallenge = tp.shplonkNu.sqr();\\n\\n        // Compute Shplonk constant term contributions from A\\u2097(\\u00b1r^{2\\u02e1}) for l = 1, ..., m-1;\\n        // Compute scalar multipliers for each fold commitment\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {\\n            bool dummy_round = i >= (logN - 1);\\n\\n            if (!dummy_round) {\\n                // Update inverted denominators\\n                mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[i + 1]).invert();\\n                mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[i + 1]).invert();\\n\\n                // Compute the scalar multipliers for A\\u2097(\\u00b1 r^{2\\u02e1}) and [A\\u2097]\\n                mem.scalingFactorPos = mem.batchingChallenge * mem.posInvertedDenominator;\\n                mem.scalingFactorNeg = mem.batchingChallenge * tp.shplonkNu * mem.negInvertedDenominator;\\n                // [A\\u2097] is multiplied by -v^{2l}/(z-r^{2^l}) - v^{2l+1} /(z+ r^{2^l})\\n                scalars[NUMBER_OF_ENTITIES + 1 + i] = mem.scalingFactorNeg.neg() + mem.scalingFactorPos.neg();\\n\\n                // Accumulate the const term contribution given by\\n                // v^{2l} * A\\u2097(r^{2\\u02e1}) /(z-r^{2^l}) + v^{2l+1} * A\\u2097(-r^{2\\u02e1}) /(z+ r^{2^l})\\n                Fr accumContribution = mem.scalingFactorNeg * proof.geminiAEvaluations[i + 1];\\n                accumContribution = accumContribution + mem.scalingFactorPos * foldPosEvaluations[i + 1];\\n                mem.constantTermAccumulator = mem.constantTermAccumulator + accumContribution;\\n                // Update the running power of v\\n                mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\\n            }\\n\\n            commitments[NUMBER_OF_ENTITIES + 1 + i] = convertProofPoint(proof.geminiFoldComms[i]);\\n        }\\n\\n        // Finalise the batch opening claim\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = Honk.G1Point({x: 1, y: 2});\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = mem.constantTermAccumulator;\\n\\n        Honk.G1Point memory quotient_commitment = convertProofPoint(proof.kzgQuotient);\\n\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = quotient_commitment;\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = tp.shplonkZ; // evaluation challenge\\n\\n        Honk.G1Point memory P_0 = batchMul(commitments, scalars);\\n        Honk.G1Point memory P_1 = negateInplace(quotient_commitment);\\n\\n        return pairing(P_0, P_1);\\n    }\\n\\n    // This implementation is the same as above with different constants\\n    function batchMul(\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory base,\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars\\n    ) internal view returns (Honk.G1Point memory result) {\\n        uint256 limit = NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2;\\n        assembly {\\n            let success := 0x01\\n            let free := mload(0x40)\\n\\n            // Write the original into the accumulator\\n            // Load into memory for ecMUL, leave offset for eccAdd result\\n            // base is an array of pointers, so we have to dereference them\\n            mstore(add(free, 0x40), mload(mload(base)))\\n            mstore(add(free, 0x60), mload(add(0x20, mload(base))))\\n            // Add scalar\\n            mstore(add(free, 0x80), mload(scalars))\\n            success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, free, 0x40))\\n\\n            let count := 0x01\\n            for {} lt(count, limit) { count := add(count, 1) } {\\n                // Get loop offsets\\n                let base_base := add(base, mul(count, 0x20))\\n                let scalar_base := add(scalars, mul(count, 0x20))\\n\\n                mstore(add(free, 0x40), mload(mload(base_base)))\\n                mstore(add(free, 0x60), mload(add(0x20, mload(base_base))))\\n                // Add scalar\\n                mstore(add(free, 0x80), mload(scalar_base))\\n\\n                success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, add(free, 0x40), 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, free, 0x80, free, 0x40))\\n            }\\n\\n            // Return the result - i hate this\\n            mstore(result, mload(free))\\n            mstore(add(result, 0x20), mload(add(free, 0x20)))\\n        }\\n    }\\n}\\n\\ncontract HonkVerifier is BaseHonkVerifier(N, LOG_N, NUMBER_OF_PUBLIC_INPUTS) {\\n     function loadVerificationKey() internal pure override returns (Honk.VerificationKey memory) {\\n       return HonkVerificationKey.loadVerificationKey();\\n    }\\n}\\n\",\"keccak256\":\"0xd86738bec5c515500af68ef54e49a2062b060ede28f53f54f7c326fcc5faadda\",\"license\":\"Apache-2.0\"},\"contracts/core/ZKDAO.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {ERC20} from 'solady/src/tokens/ERC20.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IVotes} from '@openzeppelin/contracts/governance/utils/IVotes.sol';\\nimport {TimelockControllerUpgradeable} from '@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol';\\n\\nimport {IRouterClient} from '@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol';\\nimport {OwnerIsCreator} from '@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol';\\nimport {Client} from '@chainlink/contracts-ccip/contracts/libraries/Client.sol';\\n\\nimport {IGovernor} from './interfaces/IGovernor.sol';\\nimport {IGovernorToken} from './interfaces/IGovernorToken.sol';\\nimport {ITimeLock} from './interfaces/ITimeLock.sol';\\nimport {IVerifier} from './Verifier.sol';\\nimport {QueueProposalState} from './QueueProposalState.sol';\\nimport {Transfer} from './libraries/Transfer.sol';\\nimport {Errors} from './libraries/Errors.sol';\\nimport {Clone} from './libraries/Clone.sol';\\n\\ncontract ZKDAO is QueueProposalState, Transfer {\\n\\t/// ======================\\n\\t/// ======= Errors =======\\n\\t/// ======================\\n\\n\\terror NotEnoughBalance(uint256 currentBalance, uint256 calculatedfee);\\n\\terror NothingToWithdraw();\\n\\terror FailedToWithdrawEth(address owner, address target, uint256 value);\\n\\terror DestinationChainNotAllowlisted(uint64 destinationChainSelector);\\n\\terror InvalidReceiverAddress();\\n\\n\\t/// ======================\\n\\t/// ======= Events =======\\n\\t/// ======================\\n\\n\\tevent DaoCreated(\\n\\t\\tuint256 indexed id,\\n\\t\\taddress indexed deployer,\\n\\t\\taddress token,\\n\\t\\taddress timelock,\\n\\t\\taddress governor\\n\\t);\\n\\n\\tevent PaidForDaoCreation(\\n\\t\\tGovernorTokenParams tokenParams,\\n\\t\\tuint256 minDelay,\\n\\t\\tGovernorParams governorParams,\\n\\t\\taddress[] to,\\n\\t\\tuint256[] amounts,\\n\\t\\tuint256 value,\\n\\t\\taddress creator\\n\\t);\\n\\n\\tevent TokensTransferred(\\n\\t\\tbytes32 indexed messageId,\\n\\t\\tuint64 indexed destinationChainSelector,\\n\\t\\taddress receiver,\\n\\t\\taddress token,\\n\\t\\tuint256 tokenAmount,\\n\\t\\taddress feeToken,\\n\\t\\tuint256 fee\\n\\t);\\n\\n\\t/// ======================\\n\\t/// ======= Structs ======\\n\\t/// ======================\\n\\n\\tstruct Implementations {\\n\\t\\taddress governorToken;\\n\\t\\taddress timelock;\\n\\t\\taddress governor;\\n\\t\\taddress verifier;\\n\\t}\\n\\n\\tstruct CcipParams {\\n\\t\\taddress linkToken;\\n\\t\\taddress ccipRouter;\\n\\t\\taddress ccipBnmToken;\\n\\t\\taddress ccipLnmToken;\\n\\t\\taddress usdcToken;\\n\\t\\tuint64 destinationChainSelector;\\n\\t}\\n\\n\\tstruct GovernorTokenParams {\\n\\t\\tstring name;\\n\\t\\tstring symbol;\\n\\t}\\n\\n\\tstruct GovernorParams {\\n\\t\\tstring name;\\n\\t\\tuint48 votingDelay;\\n\\t\\tuint32 votingPeriod;\\n\\t\\tuint256 proposalThreshold;\\n\\t\\tuint256 quorumFraction;\\n\\t\\tstring description;\\n\\t\\tstring logo;\\n\\t}\\n\\n\\tstruct Dao {\\n\\t\\tuint256 id;\\n\\t\\tuint256 createdAt;\\n\\t\\taddress creator;\\n\\t\\tIGovernorToken token;\\n\\t\\tITimeLock timelock;\\n\\t\\tIGovernor governor;\\n\\t\\tstring name;\\n\\t\\tstring description;\\n\\t\\tstring logo;\\n\\t}\\n\\n\\t/// =========================\\n\\t/// === Storage Variables ===\\n\\t/// =========================\\n\\n\\tuint256 private price = 1 ether; // Price to create a DAO in LINK tokens\\n\\tuint256 private daoCounter;\\n\\n\\tIGovernorToken private governorToken;\\n\\tITimeLock private timelock;\\n\\tIVerifier private verifier;\\n\\tIGovernor private governor;\\n\\tIERC20 private linkToken;\\n\\tIRouterClient private ccipRouter;\\n\\taddress private factory;\\n\\tuint64 private destinationChainSelector;\\n\\n\\tmapping(uint256 => Dao) private daos;\\n\\tmapping(uint256 => uint256) private daoIdByProposalId;\\n\\tmapping(address => uint256) private daoIdByAddress;\\n\\tmapping(address => uint256) private daoIdByTimelock;\\n\\n\\tmapping(address => uint256) private nonces;\\n\\tmapping(uint64 => bool) public allowlistedChains;\\n\\n\\treceive() external payable {}\\n\\n\\t/// =========================\\n\\t/// ====== Initializer ======\\n\\t/// =========================\\n\\n\\tfunction initialize(\\n\\t\\tImplementations memory _implementations,\\n\\t\\tCcipParams memory _ccipParams,\\n\\t\\taddress _factory,\\n\\t\\taddress _functionsRouter,\\n\\t\\tuint64 _subscriptionId,\\n\\t\\tuint32 _gasLimit,\\n\\t\\tbytes32 _donID,\\n\\t\\tstring memory _source\\n\\t) external {\\n\\t\\tgovernorToken = IGovernorToken(_implementations.governorToken);\\n\\t\\ttimelock = ITimeLock(_implementations.timelock);\\n\\t\\tgovernor = IGovernor(_implementations.governor);\\n\\t\\tverifier = IVerifier(_implementations.verifier);\\n\\t\\tlinkToken = IERC20(_ccipParams.linkToken);\\n\\t\\tccipRouter = IRouterClient(_ccipParams.ccipRouter);\\n\\t\\tdestinationChainSelector = _ccipParams.destinationChainSelector;\\n\\t\\tfactory = _factory;\\n\\n\\t\\t__ConsumerUpgradable_init(\\n\\t\\t\\t_functionsRouter,\\n\\t\\t\\t_subscriptionId,\\n\\t\\t\\t_gasLimit,\\n\\t\\t\\t_donID,\\n\\t\\t\\t_source\\n\\t\\t);\\n\\t}\\n\\n\\t/// =========================\\n\\t/// ====== Modifiers ========\\n\\t/// =========================\\n\\n\\tmodifier onlyFactory() {\\n\\t\\tif (msg.sender != factory) revert UNAUTHORIZED();\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyZkDaos() {\\n\\t\\tuint256 daoId = daoIdByAddress[msg.sender];\\n\\t\\tif (daoId == 0) {\\n\\t\\t\\trevert DAO_NOT_FOUND(daoId);\\n\\t\\t}\\n\\n\\t\\tif (daos[daoId].governor != IGovernor(msg.sender)) {\\n\\t\\t\\trevert UNAUTHORIZED();\\n\\t\\t}\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyTimelock() {\\n\\t\\tuint256 daoId = daoIdByTimelock[msg.sender];\\n\\t\\tif (daoId == 0) {\\n\\t\\t\\trevert DAO_NOT_FOUND(daoId);\\n\\t\\t}\\n\\n\\t\\tif (daos[daoId].timelock != ITimeLock(msg.sender)) {\\n\\t\\t\\trevert UNAUTHORIZED();\\n\\t\\t}\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier validateReceiver(address _receiver) {\\n\\t\\tif (_receiver == address(0)) revert InvalidReceiverAddress();\\n\\t\\t_;\\n\\t}\\n\\n\\t/// ==========================\\n\\t/// === External Functions ===\\n\\t/// ==========================\\n\\n\\tfunction getPrice() external view returns (uint256) {\\n\\t\\treturn price;\\n\\t}\\n\\n\\tfunction getDaoCounter() external view returns (uint256) {\\n\\t\\treturn daoCounter;\\n\\t}\\n\\n\\tfunction getImplementations()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\taddress _factory,\\n\\t\\t\\taddress _linkToken,\\n\\t\\t\\taddress _governorToken,\\n\\t\\t\\taddress _timelock,\\n\\t\\t\\taddress _governor,\\n\\t\\t\\taddress _verifier\\n\\t\\t)\\n\\t{\\n\\t\\treturn (\\n\\t\\t\\tfactory,\\n\\t\\t\\taddress(linkToken),\\n\\t\\t\\taddress(governorToken),\\n\\t\\t\\taddress(timelock),\\n\\t\\t\\taddress(governor),\\n\\t\\t\\taddress(verifier)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction getLinkToken() external view returns (IERC20) {\\n\\t\\treturn linkToken;\\n\\t}\\n\\n\\tfunction getCcipRouter() external view returns (IRouterClient) {\\n\\t\\treturn ccipRouter;\\n\\t}\\n\\n\\tfunction getFactory() external view returns (address) {\\n\\t\\treturn factory;\\n\\t}\\n\\n\\tfunction getDestinationChainSelector() external view returns (uint64) {\\n\\t\\treturn destinationChainSelector;\\n\\t}\\n\\n\\tfunction getNonce() external view returns (uint256) {\\n\\t\\treturn nonces[msg.sender];\\n\\t}\\n\\n\\tfunction getDaoId(address account) external view returns (uint256) {\\n\\t\\treturn daoIdByAddress[account];\\n\\t}\\n\\n\\tfunction getDao(uint256 id) external view returns (Dao memory) {\\n\\t\\tif (id == 0 || id > daoCounter) {\\n\\t\\t\\treturn\\n\\t\\t\\t\\tDao({\\n\\t\\t\\t\\t\\tid: 0,\\n\\t\\t\\t\\t\\tcreatedAt: 0,\\n\\t\\t\\t\\t\\tcreator: address(0),\\n\\t\\t\\t\\t\\ttoken: IGovernorToken(address(0)),\\n\\t\\t\\t\\t\\ttimelock: ITimeLock(address(0)),\\n\\t\\t\\t\\t\\tgovernor: IGovernor(address(0)),\\n\\t\\t\\t\\t\\tname: '',\\n\\t\\t\\t\\t\\tdescription: '',\\n\\t\\t\\t\\t\\tlogo: ''\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn daos[id];\\n\\t}\\n\\n\\tfunction getCcipFee(\\n\\t\\taddress _receiver,\\n\\t\\taddress _token,\\n\\t\\tuint256 _amount\\n\\t) external view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tccipRouter.getFee(\\n\\t\\t\\t\\tdestinationChainSelector,\\n\\t\\t\\t\\t_buildCCIPMessage(_receiver, _token, _amount, address(linkToken))\\n\\t\\t\\t);\\n\\t}\\n\\n\\tfunction getTreasury() external view returns (uint256) {\\n\\t\\treturn address(this).balance;\\n\\t}\\n\\n\\tfunction getBalance(address _token, address _account) external view {\\n\\t\\t_getBalance(_token, _account);\\n\\t}\\n\\n\\tfunction payForDaoCreation(\\n\\t\\tGovernorTokenParams calldata _tokenParams,\\n\\t\\tuint256 _minDelay,\\n\\t\\tGovernorParams calldata _governorParams,\\n\\t\\taddress[] calldata _to,\\n\\t\\tuint256[] calldata _amounts,\\n\\t\\tuint256 _value\\n\\t) external payable {\\n\\t\\tif (linkToken.balanceOf(msg.sender) < price) revert INSUFFICIENT_FUNDS();\\n\\n\\t\\tif (linkToken.allowance(msg.sender, address(this)) < price)\\n\\t\\t\\trevert INSUFFICIENT_ALLOWANCE();\\n\\n\\t\\t_transferAmountFrom(\\n\\t\\t\\taddress(linkToken),\\n\\t\\t\\tTransferData({from: msg.sender, to: address(this), amount: price})\\n\\t\\t);\\n\\n\\t\\temit PaidForDaoCreation(\\n\\t\\t\\t_tokenParams,\\n\\t\\t\\t_minDelay,\\n\\t\\t\\t_governorParams,\\n\\t\\t\\t_to,\\n\\t\\t\\t_amounts,\\n\\t\\t\\t_value,\\n\\t\\t\\tmsg.sender\\n\\t\\t);\\n\\t}\\n\\n\\tfunction createDao(\\n\\t\\tGovernorTokenParams calldata _tokenParams,\\n\\t\\tuint256 _minDelay,\\n\\t\\tGovernorParams calldata _governorParams,\\n\\t\\taddress[] calldata _to,\\n\\t\\tuint256[] calldata _amounts,\\n\\t\\taddress creator\\n\\t) external onlyFactory {\\n\\t\\tif (_to.length != _amounts.length) revert MISMATCH();\\n\\n\\t\\tuint256 baseNonce = ++nonces[msg.sender];\\n\\t\\tuint256 id = ++daoCounter;\\n\\n\\t\\taddress tokenClone = Clone.createClone(\\n\\t\\t\\taddress(governorToken),\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tbaseNonce\\n\\t\\t);\\n\\n\\t\\taddress timelockClone = Clone.createClone(\\n\\t\\t\\taddress(timelock),\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tbaseNonce + 1\\n\\t\\t);\\n\\n\\t\\taddress governorClone = Clone.createClone(\\n\\t\\t\\taddress(governor),\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tbaseNonce + 2\\n\\t\\t);\\n\\n\\t\\tnonces[msg.sender] = baseNonce + 2;\\n\\n\\t\\t_initializeToken(tokenClone, _tokenParams);\\n\\t\\t_initializeTimelock(timelockClone, _minDelay);\\n\\t\\t_initializeGovernor(\\n\\t\\t\\tgovernorClone,\\n\\t\\t\\tIVotes(tokenClone),\\n\\t\\t\\tTimelockControllerUpgradeable(payable(timelockClone)),\\n\\t\\t\\tverifier,\\n\\t\\t\\t_governorParams,\\n\\t\\t\\tid\\n\\t\\t);\\n\\n\\t\\t// Setup DAO\\n\\t\\tITimeLock(timelockClone).grantRole(\\n\\t\\t\\tITimeLock(timelockClone).PROPOSER_ROLE(),\\n\\t\\t\\tgovernorClone\\n\\t\\t);\\n\\t\\tITimeLock(timelockClone).grantRole(\\n\\t\\t\\tITimeLock(timelockClone).EXECUTOR_ROLE(),\\n\\t\\t\\taddress(0)\\n\\t\\t);\\n\\t\\tITimeLock(timelockClone).renounceRole(\\n\\t\\t\\tITimeLock(timelockClone).DEFAULT_ADMIN_ROLE(),\\n\\t\\t\\taddress(this)\\n\\t\\t);\\n\\n\\t\\tIGovernorToken(tokenClone).mintBatch(_to, _amounts);\\n\\t\\tIGovernorToken(tokenClone).transferOwnership(timelockClone);\\n\\n\\t\\tIERC20(linkToken).transfer(governorClone, price);\\n\\n\\t\\tdaoIdByTimelock[timelockClone] = id;\\n\\t\\tdaoIdByAddress[governorClone] = id;\\n\\t\\tdaos[id] = Dao({\\n\\t\\t\\tid: id,\\n\\t\\t\\tcreatedAt: block.timestamp,\\n\\t\\t\\tcreator: creator,\\n\\t\\t\\ttoken: IGovernorToken(tokenClone),\\n\\t\\t\\ttimelock: ITimeLock(timelockClone),\\n\\t\\t\\tgovernor: IGovernor(governorClone),\\n\\t\\t\\tname: _governorParams.name,\\n\\t\\t\\tdescription: _governorParams.description,\\n\\t\\t\\tlogo: _governorParams.logo\\n\\t\\t});\\n\\n\\t\\temit DaoCreated(id, msg.sender, tokenClone, timelockClone, governorClone);\\n\\t}\\n\\n\\tfunction queueProposal(\\n\\t\\tuint256 daoId,\\n\\t\\tuint256 proposalId,\\n\\t\\tuint256 snapshot,\\n\\t\\tuint256 proposalBlock,\\n\\t\\taddress voteToken\\n\\t) external onlyZkDaos {\\n\\t\\t_queueProposal(daoId, proposalId, snapshot, proposalBlock, voteToken);\\n\\t}\\n\\n\\tfunction setFactory(address _factory) external {\\n\\t\\tfactory = _factory;\\n\\t}\\n\\n\\tfunction setGovernorToken(address _governorToken) external {\\n\\t\\tgovernorToken = IGovernorToken(_governorToken);\\n\\t}\\n\\n\\tfunction setTimelock(address _timelock) external {\\n\\t\\ttimelock = ITimeLock(_timelock);\\n\\t}\\n\\n\\tfunction setGovernor(address _governor) external {\\n\\t\\tgovernor = IGovernor(_governor);\\n\\t}\\n\\n\\tfunction setPrice(uint256 _price) external {\\n\\t\\tprice = _price;\\n\\t}\\n\\n\\tfunction allowlistDestinationChain(\\n\\t\\tuint64 _destinationChainSelector,\\n\\t\\tbool allowed\\n\\t) external {\\n\\t\\tallowlistedChains[_destinationChainSelector] = allowed;\\n\\t}\\n\\n\\tfunction transferCrosschain(\\n\\t\\taddress _receiver,\\n\\t\\taddress _token,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _fee\\n\\t)\\n\\t\\texternal\\n\\t\\tonlyZkDaos\\n\\t\\tvalidateReceiver(_receiver)\\n\\t\\treturns (bytes32 messageId)\\n\\t{\\n\\t\\tClient.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\\n\\t\\t\\t_receiver,\\n\\t\\t\\t_token,\\n\\t\\t\\t_amount,\\n\\t\\t\\taddress(linkToken)\\n\\t\\t);\\n\\n\\t\\tlinkToken.approve(address(ccipRouter), _fee);\\n\\n\\t\\tIERC20(_token).approve(address(ccipRouter), _amount);\\n\\n\\t\\tmessageId = ccipRouter.ccipSend(destinationChainSelector, evm2AnyMessage);\\n\\n\\t\\temit TokensTransferred(\\n\\t\\t\\tmessageId,\\n\\t\\t\\tdestinationChainSelector,\\n\\t\\t\\t_receiver,\\n\\t\\t\\t_token,\\n\\t\\t\\t_amount,\\n\\t\\t\\taddress(linkToken),\\n\\t\\t\\t_fee\\n\\t\\t);\\n\\n\\t\\treturn messageId;\\n\\t}\\n\\n\\tfunction recoverFunds(address _token, address _to) external {\\n\\t\\tuint256 amount = _token == NATIVE\\n\\t\\t\\t? address(this).balance\\n\\t\\t\\t: ERC20(_token).balanceOf(address(this));\\n\\n\\t\\t_transferAmount(_token, _to, amount);\\n\\t}\\n\\n\\t/// =========================\\n\\t/// == Private Functions ====\\n\\t/// =========================\\n\\n\\tfunction _initializeToken(\\n\\t\\taddress tokenClone,\\n\\t\\tGovernorTokenParams calldata tokenParams\\n\\t) private {\\n\\t\\tIGovernorToken(tokenClone).initialize(\\n\\t\\t\\ttokenParams.name,\\n\\t\\t\\ttokenParams.symbol,\\n\\t\\t\\taddress(this)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _initializeTimelock(\\n\\t\\taddress timelockClone,\\n\\t\\tuint256 minDelay\\n\\t) private {\\n\\t\\tITimeLock(timelockClone).initialize(\\n\\t\\t\\tminDelay,\\n\\t\\t\\tnew address[](0),\\n\\t\\t\\tnew address[](0),\\n\\t\\t\\taddress(this)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _initializeGovernor(\\n\\t\\taddress _governorClone,\\n\\t\\tIVotes _token,\\n\\t\\tTimelockControllerUpgradeable _timelock,\\n\\t\\tIVerifier _verifier,\\n\\t\\tGovernorParams calldata governorParams,\\n\\t\\tuint256 id\\n\\t) private {\\n\\t\\t// Convert calldata struct to memory struct for compatibility\\n\\t\\tIGovernor.GovernorInitParams memory memoryParams = IGovernor\\n\\t\\t\\t.GovernorInitParams({\\n\\t\\t\\t\\tname: governorParams.name,\\n\\t\\t\\t\\ttoken: _token,\\n\\t\\t\\t\\ttimelock: _timelock,\\n\\t\\t\\t\\tvotingDelay: governorParams.votingDelay,\\n\\t\\t\\t\\tvotingPeriod: governorParams.votingPeriod,\\n\\t\\t\\t\\tproposalThreshold: governorParams.proposalThreshold,\\n\\t\\t\\t\\tvotesQuorumFraction: governorParams.quorumFraction,\\n\\t\\t\\t\\tid: id,\\n\\t\\t\\t\\tdescription: governorParams.description,\\n\\t\\t\\t\\tlogo: governorParams.logo\\n\\t\\t\\t});\\n\\n\\t\\tIGovernor(_governorClone).initialize(\\n\\t\\t\\tmemoryParams,\\n\\t\\t\\t_verifier,\\n\\t\\t\\taddress(linkToken)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _buildCCIPMessage(\\n\\t\\taddress _receiver,\\n\\t\\taddress _token,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _feeTokenAddress\\n\\t) private pure returns (Client.EVM2AnyMessage memory) {\\n\\t\\t// Set the token amounts\\n\\t\\tClient.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](\\n\\t\\t\\t1\\n\\t\\t);\\n\\t\\ttokenAmounts[0] = Client.EVMTokenAmount({token: _token, amount: _amount});\\n\\n\\t\\treturn\\n\\t\\t\\tClient.EVM2AnyMessage({\\n\\t\\t\\t\\treceiver: abi.encode(_receiver),\\n\\t\\t\\t\\tdata: '',\\n\\t\\t\\t\\ttokenAmounts: tokenAmounts,\\n\\t\\t\\t\\textraArgs: Client._argsToBytes(\\n\\t\\t\\t\\t\\tClient.GenericExtraArgsV2({\\n\\t\\t\\t\\t\\t\\tgasLimit: 0,\\n\\t\\t\\t\\t\\t\\tallowOutOfOrderExecution: true\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\tfeeToken: _feeTokenAddress\\n\\t\\t\\t});\\n\\t}\\n}\\n\",\"keccak256\":\"0x046140152f6157e7e1aca6910d25bcfa3215bccae33477df5c97cd573c6f18fd\",\"license\":\"MIT\"},\"contracts/core/interfaces/IGovernor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IVotes} from '@openzeppelin/contracts/governance/utils/IVotes.sol';\\nimport {TimelockControllerUpgradeable} from '@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol';\\nimport {IVerifier} from '../Verifier.sol';\\n\\ninterface IGovernor {\\n\\t/// ======================\\n\\t/// ======= Structs ======\\n\\t/// ======================\\n\\n\\tstruct GovernorInitParams {\\n\\t\\tstring name;\\n\\t\\tIVotes token;\\n\\t\\tTimelockControllerUpgradeable timelock;\\n\\t\\tuint48 votingDelay;\\n\\t\\tuint32 votingPeriod;\\n\\t\\tuint256 proposalThreshold;\\n\\t\\tuint256 votesQuorumFraction;\\n\\t\\tuint256 id;\\n\\t\\tstring description;\\n\\t\\tstring logo;\\n\\t}\\n\\n\\tstruct PublicInputs {\\n\\t\\tuint256 proposalId;\\n\\t\\tuint256 weight;\\n\\t\\tuint8 choice;\\n\\t\\tbytes32 root;\\n\\t\\tuint256 nullifier;\\n\\t}\\n\\n\\tstruct ZKProposalVote {\\n\\t\\tuint256 againstVotes;\\n\\t\\tuint256 forVotes;\\n\\t\\tuint256 abstainVotes;\\n\\t\\t// NOTE: the mapping is not necessary for the current implementation\\n\\t\\t// mapping(uint256 => bool) hasNullified;\\n\\t}\\n\\n\\tstruct ProposalStorage {\\n\\t\\tuint256 id;\\n\\t\\tuint256 proposalNumber;\\n\\t\\tuint256 createdAt;\\n\\t\\taddress proposer;\\n\\t\\tstring description;\\n\\t}\\n\\n\\t/// ======================\\n\\t/// ======= Events =======\\n\\t/// ======================\\n\\n\\tevent ZKVoteCast(\\n\\t\\tuint256 indexed proposalId,\\n\\t\\tuint8 choice,\\n\\t\\tuint256 weight,\\n\\t\\tbytes32 nullifier\\n\\t);\\n\\n\\tevent TokensTransferred(\\n\\t\\tbytes32 indexed messageId,\\n\\t\\tuint64 indexed destinationChainSelector,\\n\\t\\taddress receiver,\\n\\t\\taddress token,\\n\\t\\tuint256 tokenAmount,\\n\\t\\taddress feeToken,\\n\\t\\tuint256 fees\\n\\t);\\n\\n\\t/// =========================\\n\\t/// ====== Initializer ======\\n\\t/// =========================\\n\\n\\t/**\\n\\t * @notice Initializes the Governor contract\\n\\t * @param params Struct containing all initialization parameters\\n\\t * @param _verifier ZK-proof verifier contract\\n\\t */\\n\\tfunction initialize(\\n\\t\\tGovernorInitParams calldata params,\\n\\t\\tIVerifier _verifier,\\n\\t\\taddress _linkToken\\n\\t) external;\\n\\n\\t/// ==========================\\n\\t/// ===== View Functions =====\\n\\t/// ==========================\\n\\n\\t/**\\n\\t * @notice Check if a nullifier has been used for a proposal\\n\\t * @param proposalId The proposal ID\\n\\t * @param nullifier The nullifier to check\\n\\t * @return True if nullifier has been used\\n\\t */\\n\\tfunction getNullifierUsed(\\n\\t\\tuint256 proposalId,\\n\\t\\tuint256 nullifier\\n\\t) external view returns (bool);\\n\\n\\t/**\\n\\t * @notice Get the merkle root for a proposal\\n\\t * @param proposalId The proposal ID\\n\\t * @return The merkle root\\n\\t */\\n\\tfunction getCid(uint256 proposalId) external view returns (string memory);\\n\\n\\t/**\\n\\t * @notice Get ZK voting results for a proposal\\n\\t * @param proposalId The proposal ID\\n\\t * @return againstVotes Number of votes against\\n\\t * @return forVotes Number of votes for\\n\\t * @return abstainVotes Number of abstain votes\\n\\t */\\n\\tfunction getZKVote(\\n\\t\\tuint256 proposalId\\n\\t)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes);\\n\\n\\tfunction isWaitingMerkle(uint256 proposalId) external view returns (bool);\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\t/**\\n\\t * @notice Cast a ZK vote on a proposal\\n\\t * @param _proposalId The proposal ID\\n\\t * @param _proof The ZK proof\\n\\t * @param _inputs The public inputs for verification\\n\\t */\\n\\tfunction castZKVote(\\n\\t\\tuint256 _proposalId,\\n\\t\\tbytes calldata _proof,\\n\\t\\tbytes32[] calldata _inputs\\n\\t) external;\\n\\n\\t/**\\n\\t * @notice Set the merkle root for a proposal (only callable by ZKDAO)\\n\\t * @param _proposalId The proposal ID\\n\\t * @param _cid The merkle root\\n\\t */\\n\\tfunction setRoot(uint256 _proposalId, string memory _cid) external;\\n\\n\\t/**\\n\\t * @notice Create a new proposal\\n\\t * @param targets Array of target addresses for proposal calls\\n\\t * @param values Array of values (in wei) for proposal calls\\n\\t * @param calldatas Array of call data for proposal calls\\n\\t * @param description String description of the proposal\\n\\t * @return proposalId The ID of the created proposal\\n\\t */\\n\\tfunction propose(\\n\\t\\taddress[] memory targets,\\n\\t\\tuint256[] memory values,\\n\\t\\tbytes[] memory calldatas,\\n\\t\\tstring memory description\\n\\t) external returns (uint256 proposalId);\\n}\\n\",\"keccak256\":\"0xbdc0e3b2b85e3bc8e9f3ee1b9f7185506f9464848eec1aeccdd08372edeb27cf\",\"license\":\"MIT\"},\"contracts/core/interfaces/IGovernorToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ninterface IGovernorToken {\\n\\t/// =========================\\n\\t/// ====== Initializer ======\\n\\t/// =========================\\n\\n\\tfunction initialize(\\n\\t\\tstring memory _name,\\n\\t\\tstring memory _symbol,\\n\\t\\taddress _owner\\n\\t) external;\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\tfunction mint(address to, uint256 amount) external;\\n\\n\\tfunction mintBatch(address[] memory to, uint256[] memory amounts) external;\\n\\n\\tfunction transferOwnership(address newOwner) external;\\n}\\n\",\"keccak256\":\"0xa1063b863df330cc0e63222d20e9f75216071add1c0a29571d32067e312dc3b4\",\"license\":\"MIT\"},\"contracts/core/interfaces/ITimeLock.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ninterface ITimeLock {\\n\\t/// =========================\\n\\t/// ====== Role Constants ===\\n\\t/// =========================\\n\\n\\tfunction PROPOSER_ROLE() external view returns (bytes32);\\n\\n\\tfunction EXECUTOR_ROLE() external view returns (bytes32);\\n\\n\\tfunction DEFAULT_ADMIN_ROLE() external view returns (bytes32);\\n\\n\\t/// =========================\\n\\t/// ====== Initializer ======\\n\\t/// =========================\\n\\n\\t/// @notice Initializes the TimelockController\\n\\t/// @param _minDelay How long we have to wait to execute a proposal after it is queued\\n\\t/// @param _proposers Addresses allowed to propose\\n\\t/// @param _executors Addresses allowed to execute\\n\\t/// @param _admin Address allowed to manage roles\\n\\tfunction initialize(\\n\\t\\tuint256 _minDelay,\\n\\t\\taddress[] memory _proposers,\\n\\t\\taddress[] memory _executors,\\n\\t\\taddress _admin\\n\\t) external;\\n\\n\\t/// =================================\\n\\t/// == External / Public Functions ==\\n\\t/// =================================\\n\\n\\tfunction grantRole(bytes32 role, address account) external;\\n\\n\\tfunction renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0xdb213263d11896dbabd52d74439e6a966aa02998983190ea3f94c7542ab9ca3b\",\"license\":\"MIT\"},\"contracts/core/libraries/Clone.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport '@openzeppelin/contracts/proxy/Clones.sol';\\n\\nlibrary Clone {\\n\\tfunction createClone(\\n\\t\\taddress _contract,\\n\\t\\taddress _deployer,\\n\\t\\tuint256 _nonce\\n\\t) internal returns (address) {\\n\\t\\tbytes32 salt = keccak256(abi.encodePacked(_deployer, _nonce));\\n\\n\\t\\treturn Clones.cloneDeterministic(_contract, salt);\\n\\t}\\n}\\n\",\"keccak256\":\"0x8b0884713c27666b2be4bea1d4ef96c6ab5ce2734eaf4501fcd0d28b4eb7f798\",\"license\":\"MIT\"},\"contracts/core/libraries/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ncontract Errors {\\n\\t/// ======================\\n\\t/// ====== Generic =======\\n\\t/// ======================\\n\\n\\terror INSUFFICIENT_ALLOWANCE();\\n\\terror INSUFFICIENT_FUNDS();\\n\\terror MISMATCH();\\n\\terror UNAUTHORIZED();\\n\\n\\t/// ======================\\n\\t/// ======= ZK DAO =======\\n\\t/// ======================\\n\\n\\terror DAO_NOT_FOUND(uint256 daoId);\\n\\terror DOUBLE_VOTE();\\n\\terror UNEXPECTED_REQUEST_ID(bytes32 requestId);\\n\\terror VOTING_CLOSED();\\n\\n\\t/// ======================\\n\\t/// ====== Governor ======\\n\\t/// ======================\\n\\n\\terror INVALID_VOTE_TYPE();\\n\\terror INVALID_PROPOSAL_ID();\\n\\terror INVALID_NULLIFIER();\\n\\terror ZK_PROOF_FAILED();\\n\\n\\terror InvalidArrayLength();\\n\\terror UnauthorizedCaller();\\n\\terror DAONotFound(uint256 daoId);\\n\\terror InvalidParameters();\\n}\\n\",\"keccak256\":\"0x19d39f270a99b3fd2e85d2999d6d683fa711ffede0acdcdd30e36b2771fbdccb\",\"license\":\"MIT\"},\"contracts/core/libraries/Native.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ncontract Native {\\n\\taddress public constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n}\\n\",\"keccak256\":\"0x3d2756eaaa5cac994af1a34bf40645a0f860ebeaae28bfd2c14b66bc9f15dd5b\",\"license\":\"MIT\"},\"contracts/core/libraries/Transfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport 'solady/src/utils/SafeTransferLib.sol';\\nimport {Native} from './Native.sol';\\n\\ncontract Transfer is Native {\\n\\terror AMOUNT_MISMATCH();\\n\\n\\tstruct TransferData {\\n\\t\\taddress from;\\n\\t\\taddress to;\\n\\t\\tuint256 amount;\\n\\t}\\n\\n\\tfunction _transferAmountsFrom(\\n\\t\\taddress _token,\\n\\t\\tTransferData[] memory _transferData\\n\\t) internal virtual returns (bool) {\\n\\t\\tuint256 msgValue = msg.value;\\n\\n\\t\\tfor (uint256 i; i < _transferData.length; ) {\\n\\t\\t\\tTransferData memory transferData = _transferData[i];\\n\\n\\t\\t\\tif (_token == NATIVE) {\\n\\t\\t\\t\\tmsgValue -= transferData.amount;\\n\\t\\t\\t\\tSafeTransferLib.safeTransferETH(transferData.to, transferData.amount);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tSafeTransferLib.safeTransferFrom(\\n\\t\\t\\t\\t\\t_token,\\n\\t\\t\\t\\t\\ttransferData.from,\\n\\t\\t\\t\\t\\ttransferData.to,\\n\\t\\t\\t\\t\\ttransferData.amount\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (msgValue != 0) revert AMOUNT_MISMATCH();\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _transferAmountFrom(\\n\\t\\taddress _token,\\n\\t\\tTransferData memory _transferData\\n\\t) internal virtual returns (bool) {\\n\\t\\tuint256 amount = _transferData.amount;\\n\\t\\tif (_token == NATIVE) {\\n\\t\\t\\tif (msg.value < amount) revert AMOUNT_MISMATCH();\\n\\n\\t\\t\\tSafeTransferLib.safeTransferETH(_transferData.to, amount);\\n\\t\\t} else {\\n\\t\\t\\tSafeTransferLib.safeTransferFrom(\\n\\t\\t\\t\\t_token,\\n\\t\\t\\t\\t_transferData.from,\\n\\t\\t\\t\\t_transferData.to,\\n\\t\\t\\t\\tamount\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _transferAmount(\\n\\t\\taddress _token,\\n\\t\\taddress _to,\\n\\t\\tuint256 _amount\\n\\t) internal virtual {\\n\\t\\tif (_token == NATIVE) {\\n\\t\\t\\tSafeTransferLib.safeTransferETH(_to, _amount);\\n\\t\\t} else {\\n\\t\\t\\tSafeTransferLib.safeTransfer(_token, _to, _amount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _getBalance(\\n\\t\\taddress _token,\\n\\t\\taddress _account\\n\\t) internal view returns (uint256) {\\n\\t\\tif (_token == NATIVE) {\\n\\t\\t\\treturn payable(_account).balance;\\n\\t\\t} else {\\n\\t\\t\\treturn SafeTransferLib.balanceOf(_token, _account);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x2dd02367fe4dc157a15b72534d364463d64596ccfba3610a9bda38862550bf55\",\"license\":\"MIT\"},\"contracts/core/upgradable/ConsumerUpgradable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\n\\nimport {FunctionsClient} from '@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol';\\nimport {FunctionsRequest} from '@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol';\\n\\nimport {FunctionsClientUpgradeable} from '../upgradable/FunctionClientUpgradable.sol';\\nimport {IGovernor} from '../interfaces/IGovernor.sol';\\nimport {Errors} from '../libraries/Errors.sol';\\n\\ncontract ConsumerUpgradable is FunctionsClientUpgradeable, Errors {\\n\\tusing FunctionsRequest for FunctionsRequest.Request;\\n\\n\\t/// ======================\\n\\t/// ======= Events =======\\n\\t/// ======================\\n\\n\\tevent Response(bytes32 indexed requestId, bytes response, bytes err);\\n\\n\\t/// ======================\\n\\t/// ======= Structs ======\\n\\t/// ======================\\n\\n\\tstruct Proposal {\\n\\t\\tIGovernor dao;\\n\\t\\taddress voteToken;\\n\\t\\tuint256 daoId;\\n\\t\\tuint256 proposalId;\\n\\t\\tuint256 snapshot;\\n\\t\\tuint256 proposalBlock;\\n\\t\\tbool queued;\\n\\t\\tbool executed;\\n\\t\\t// 30 bytes free for future use\\n\\t}\\n\\n\\tstruct ProposalWithTimeLeft {\\n\\t\\tIGovernor dao;\\n\\t\\taddress voteToken;\\n\\t\\tuint256 daoId;\\n\\t\\tuint256 proposalId;\\n\\t\\tuint256 snapshot;\\n\\t\\tuint256 proposalBlock;\\n\\t\\tuint256 timeLeft;\\n\\t\\tbool queued;\\n\\t\\tbool executed;\\n\\t\\t// 30 bytes free for future use\\n\\t}\\n\\n\\tstruct SendRequestParams {\\n\\t\\tstring source;\\n\\t\\tbytes encryptedSecretsUrls;\\n\\t\\tuint8 donHostedSecretsSlotID;\\n\\t\\tuint64 donHostedSecretsVersion;\\n\\t\\tstring[] args;\\n\\t\\tbytes[] bytesArgs;\\n\\t\\tuint64 subscriptionId;\\n\\t\\tuint32 gasLimit;\\n\\t\\tbytes32 donID;\\n\\t}\\n\\n\\t/// =========================\\n\\t/// === Storage Variables ===\\n\\t/// =========================\\n\\n\\tuint64 internal subscriptionId; // 8 bytes\\n\\tuint32 internal gasLimit; // 4 bytes\\n\\t// 20 bytes free for future use\\n\\n\\tbytes32 internal donID; // 32 bytes\\n\\tbytes32 public s_lastRequestId; // 32 bytes\\n\\tuint256 private requestCounter; // 32 bytes\\n\\n\\tProposal[] internal queue; // 32 bytes + 20 bytes free for future use\\n\\tbytes public s_lastResponse;\\n\\tbytes public s_lastError;\\n\\n\\tstring public source;\\n\\n\\t// daoId => proposalId => Proposal\\n\\tmapping(IGovernor => mapping(uint256 => Proposal)) internal proposals;\\n\\tmapping(bytes32 => Proposal[]) private pendingProposals;\\n\\tmapping(bytes32 => bool) private pendingRequests;\\n\\n\\t/// =========================\\n\\t/// ====== Constructor ======\\n\\t/// =========================\\n\\n\\tconstructor() {}\\n\\n\\t/// =========================\\n\\t/// ====== Initializer ======\\n\\t/// =========================\\n\\n\\tfunction __ConsumerUpgradable_init(\\n\\t\\taddress _router,\\n\\t\\tuint64 _subscriptionId,\\n\\t\\tuint32 _gasLimit,\\n\\t\\tbytes32 _donID,\\n\\t\\tstring memory _source\\n\\t) internal {\\n\\t\\t__FunctionsClient_init(_router);\\n\\n\\t\\tsubscriptionId = _subscriptionId;\\n\\t\\tgasLimit = _gasLimit;\\n\\t\\tdonID = _donID;\\n\\t\\tsource = _source;\\n\\t}\\n\\n\\t/// ==========================\\n\\t/// === External Functions ===\\n\\t/// ==========================\\n\\n\\tfunction getSubscriptionId() external view returns (uint64) {\\n\\t\\treturn subscriptionId;\\n\\t}\\n\\n\\tfunction getGasLimit() external view returns (uint32) {\\n\\t\\treturn gasLimit;\\n\\t}\\n\\n\\tfunction getDonID() external view returns (bytes32) {\\n\\t\\treturn donID;\\n\\t}\\n\\n\\tfunction getRequestCounter() external view returns (uint256) {\\n\\t\\treturn requestCounter;\\n\\t}\\n\\n\\tfunction getQueue() external view returns (Proposal[] memory) {\\n\\t\\treturn queue;\\n\\t}\\n\\n\\tfunction getQueueWithTimeLeft()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (ProposalWithTimeLeft[] memory _allProposals)\\n\\t{\\n\\t\\tuint256 len = queue.length;\\n\\t\\t_allProposals = new ProposalWithTimeLeft[](len);\\n\\n\\t\\tfor (uint256 i; i < len; ) {\\n\\t\\t\\tProposal memory proposal = queue[i];\\n\\t\\t\\t// Calcula timeLeft: 0 si ya pas\\u00f3, o tiempo restante si est\\u00e1 pendiente\\n\\t\\t\\tuint256 timeRemaining = block.timestamp >= proposal.snapshot\\n\\t\\t\\t\\t? 0\\n\\t\\t\\t\\t: proposal.snapshot - block.timestamp;\\n\\n\\t\\t\\t_allProposals[i] = ProposalWithTimeLeft({\\n\\t\\t\\t\\tdao: proposal.dao,\\n\\t\\t\\t\\tvoteToken: proposal.voteToken,\\n\\t\\t\\t\\tdaoId: proposal.daoId,\\n\\t\\t\\t\\tproposalId: proposal.proposalId,\\n\\t\\t\\t\\tsnapshot: proposal.snapshot,\\n\\t\\t\\t\\tproposalBlock: proposal.proposalBlock,\\n\\t\\t\\t\\tqueued: proposal.queued,\\n\\t\\t\\t\\texecuted: proposal.executed,\\n\\t\\t\\t\\ttimeLeft: timeRemaining\\n\\t\\t\\t});\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Send a pre-encoded CBOR request\\n\\t * @param _request CBOR-encoded request data\\n\\t * @param _subscriptionId Billing ID\\n\\t * @param _gasLimit The maximum amount of gas the request can consume\\n\\t * @param _donID ID of the job to be invoked\\n\\t * @return requestId The ID of the sent request\\n\\t */\\n\\n\\tfunction sendRequestCBOR(\\n\\t\\tbytes memory _request,\\n\\t\\tuint64 _subscriptionId,\\n\\t\\tuint32 _gasLimit,\\n\\t\\tbytes32 _donID\\n\\t) external returns (bytes32 requestId) {\\n\\t\\trequestId = _sendRequest(_request, _subscriptionId, _gasLimit, _donID);\\n\\n\\t\\ts_lastRequestId = requestId;\\n\\t\\tpendingRequests[requestId] = true;\\n\\n\\t\\treturn requestId;\\n\\t}\\n\\n\\t/// =========================\\n\\t/// == Internal Functions ===\\n\\t/// =========================\\n\\n\\t/**\\n\\t * @notice Send a request to the Chainlink Functions node\\n\\t * @param _params Parameters for the request\\n\\t * @param _proposals Proposals to be processed in the request\\n\\t * @return requestId The ID of the sent request\\n\\t */\\n\\n\\tfunction sendRequest(\\n\\t\\tSendRequestParams memory _params,\\n\\t\\tProposal[] memory _proposals\\n\\t) internal returns (bytes32 requestId) {\\n\\t\\tFunctionsRequest.Request memory req;\\n\\n\\t\\t// 1. Build the Functions request\\n\\t\\treq.initializeRequestForInlineJavaScript(_params.source);\\n\\t\\tif (_params.encryptedSecretsUrls.length > 0)\\n\\t\\t\\treq.addSecretsReference(_params.encryptedSecretsUrls);\\n\\t\\telse if (_params.donHostedSecretsVersion > 0) {\\n\\t\\t\\treq.addDONHostedSecrets(\\n\\t\\t\\t\\t_params.donHostedSecretsSlotID,\\n\\t\\t\\t\\t_params.donHostedSecretsVersion\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tif (_params.args.length > 0) req.setArgs(_params.args);\\n\\t\\tif (_params.bytesArgs.length > 0) req.setBytesArgs(_params.bytesArgs);\\n\\n\\t\\t// 2. Set the request parameters\\n\\t\\trequestId = _sendRequest(\\n\\t\\t\\treq.encodeCBOR(),\\n\\t\\t\\t_params.subscriptionId,\\n\\t\\t\\t_params.gasLimit,\\n\\t\\t\\t_params.donID\\n\\t\\t);\\n\\n\\t\\ts_lastRequestId = requestId;\\n\\t\\tpendingRequests[requestId] = true;\\n\\n\\t\\t// 3. Store the proposals in the pendingProposals mapping\\n\\t\\tfor (uint256 i = 0; i < _proposals.length; ) {\\n\\t\\t\\tpendingProposals[requestId].push(_proposals[i]);\\n\\n\\t\\t\\tfor (uint256 j = 0; j < queue.length; ) {\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\tqueue[j].dao == _proposals[i].dao &&\\n\\t\\t\\t\\t\\tqueue[j].proposalId == _proposals[i].proposalId\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tqueue[j] = queue[queue.length - 1];\\n\\t\\t\\t\\t\\tqueue.pop();\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn requestId;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Store latest result/error\\n\\t * @param requestId The request ID, returned by sendRequest()\\n\\t * @param response Aggregated response from the user code\\n\\t * @param err Aggregated error from the user code or from the execution pipeline\\n\\t */\\n\\n\\tfunction fulfillRequest(\\n\\t\\tbytes32 requestId,\\n\\t\\tbytes memory response,\\n\\t\\tbytes memory err\\n\\t) internal override {\\n\\t\\tif (s_lastRequestId != requestId) {\\n\\t\\t\\trevert UNEXPECTED_REQUEST_ID(requestId);\\n\\t\\t}\\n\\n\\t\\tpendingRequests[requestId] = false;\\n\\n\\t\\ts_lastResponse = response;\\n\\t\\ts_lastError = err;\\n\\n\\t\\tif (response.length > 0) {\\n\\t\\t\\tstring memory concatCIDs = string(response);\\n\\t\\t\\tstring[] memory cids = _splitByPipe(concatCIDs);\\n\\n\\t\\t\\tProposal[] memory lastProposals = pendingProposals[s_lastRequestId];\\n\\n\\t\\t\\tfor (uint256 i = 0; i < lastProposals.length; ) {\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t!proposals[lastProposals[i].dao][lastProposals[i].proposalId].executed\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tIGovernor(lastProposals[i].dao).setRoot(\\n\\t\\t\\t\\t\\t\\tlastProposals[i].proposalId,\\n\\t\\t\\t\\t\\t\\tcids[i]\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tproposals[lastProposals[i].dao][lastProposals[i].proposalId]\\n\\t\\t\\t\\t\\t\\t.executed = true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\temit Response(requestId, s_lastResponse, s_lastError);\\n\\t}\\n\\n\\tfunction setSubscriptionId(uint64 _subscriptionId) external {\\n\\t\\tsubscriptionId = _subscriptionId;\\n\\t}\\n\\n\\tfunction setGasLimit(uint32 _gasLimit) external {\\n\\t\\tgasLimit = _gasLimit;\\n\\t}\\n\\n\\tfunction setDonID(bytes32 _donID) external {\\n\\t\\tdonID = _donID;\\n\\t}\\n\\n\\tfunction setSource(string memory _source) external {\\n\\t\\tsource = _source;\\n\\t}\\n\\n\\t/// ==========================\\n\\t/// === Private Functions ====\\n\\t/// ==========================\\n\\n\\t/**\\n\\t * @notice Split a string with \\\"|\\\" delimiter into an array of substrings\\n\\t * @param input The input string to split\\n\\t */\\n\\n\\tfunction _splitByPipe(\\n\\t\\tstring memory input\\n\\t) private pure returns (string[] memory) {\\n\\t\\tbytes memory strBytes = bytes(input);\\n\\t\\tuint256 count = 1;\\n\\n\\t\\tfor (uint256 i = 0; i < strBytes.length; ) {\\n\\t\\t\\tif (strBytes[i] == '|') count++;\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring[] memory parts = new string[](count);\\n\\t\\tuint256 lastIndex = 0;\\n\\t\\tuint256 partIndex = 0;\\n\\n\\t\\tfor (uint256 i = 0; i < strBytes.length; ) {\\n\\t\\t\\tif (strBytes[i] == '|') {\\n\\t\\t\\t\\tbytes memory part = new bytes(i - lastIndex);\\n\\t\\t\\t\\tfor (uint256 j = lastIndex; j < i; ) {\\n\\t\\t\\t\\t\\tpart[j - lastIndex] = strBytes[j];\\n\\n\\t\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparts[partIndex++] = string(part);\\n\\t\\t\\t\\tlastIndex = i + 1;\\n\\t\\t\\t}\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (lastIndex < strBytes.length) {\\n\\t\\t\\tbytes memory part = new bytes(strBytes.length - lastIndex);\\n\\t\\t\\tfor (uint256 j = lastIndex; j < strBytes.length; ) {\\n\\t\\t\\t\\tpart[j - lastIndex] = strBytes[j];\\n\\n\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tparts[partIndex] = string(part);\\n\\t\\t}\\n\\n\\t\\treturn parts;\\n\\t}\\n}\\n\",\"keccak256\":\"0x0a78b52ce758ba36c8f42e745d4de95658485ba77a172fe208e5eff5bab75d92\",\"license\":\"MIT\"},\"contracts/core/upgradable/FunctionClientUpgradable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IFunctionsRouter} from '@chainlink/contracts/src/v0.8/functions/dev/v1_X/interfaces/IFunctionsRouter.sol';\\nimport {IFunctionsClient} from '@chainlink/contracts/src/v0.8/functions/dev/v1_X/interfaces/IFunctionsClient.sol';\\nimport {FunctionsRequest} from '@chainlink/contracts/src/v0.8/functions/dev/v1_X/libraries/FunctionsRequest.sol';\\n\\n/// @title Upgradeable Chainlink Functions client contract\\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\\nabstract contract FunctionsClientUpgradeable is IFunctionsClient {\\n\\tusing FunctionsRequest for FunctionsRequest.Request;\\n\\n\\tIFunctionsRouter internal i_router;\\n\\n\\tevent RequestSent(bytes32 indexed id);\\n\\tevent RequestFulfilled(bytes32 indexed id);\\n\\n\\terror OnlyRouterCanFulfill();\\n\\n\\t/// @notice Initializer instead of constructor (for upgradeable pattern)\\n\\t/// @param router The address of the Chainlink Functions router\\n\\tfunction __FunctionsClient_init(address router) internal {\\n\\t\\ti_router = IFunctionsRouter(router);\\n\\t}\\n\\n\\t/// @notice Sends a Chainlink Functions request\\n\\t/// @param data The CBOR encoded bytes data for a Functions request\\n\\t/// @param subscriptionId The subscription ID that will be charged to service the request\\n\\t/// @param callbackGasLimit The gas available for the fulfillment callback\\n\\t/// @param donId The DON ID used for the request\\n\\t/// @return requestId The generated request ID for this request\\n\\tfunction _sendRequest(\\n\\t\\tbytes memory data,\\n\\t\\tuint64 subscriptionId,\\n\\t\\tuint32 callbackGasLimit,\\n\\t\\tbytes32 donId\\n\\t) internal returns (bytes32) {\\n\\t\\tbytes32 requestId = i_router.sendRequest(\\n\\t\\t\\tsubscriptionId,\\n\\t\\t\\tdata,\\n\\t\\t\\tFunctionsRequest.REQUEST_DATA_VERSION,\\n\\t\\t\\tcallbackGasLimit,\\n\\t\\t\\tdonId\\n\\t\\t);\\n\\t\\temit RequestSent(requestId);\\n\\t\\treturn requestId;\\n\\t}\\n\\n\\t/// @notice User defined function to handle a response from the DON\\n\\t/// @dev Must be implemented by inheriting contracts\\n\\tfunction fulfillRequest(\\n\\t\\tbytes32 requestId,\\n\\t\\tbytes memory response,\\n\\t\\tbytes memory err\\n\\t) internal virtual;\\n\\n\\t/// @inheritdoc IFunctionsClient\\n\\tfunction handleOracleFulfillment(\\n\\t\\tbytes32 requestId,\\n\\t\\tbytes memory response,\\n\\t\\tbytes memory err\\n\\t) external override {\\n\\t\\tif (msg.sender != address(i_router)) {\\n\\t\\t\\trevert OnlyRouterCanFulfill();\\n\\t\\t}\\n\\t\\tfulfillRequest(requestId, response, err);\\n\\t\\temit RequestFulfilled(requestId);\\n\\t}\\n}\\n\",\"keccak256\":\"0xa39df58d16b82047de1b8fbd6b19191ee9464736edc5119e6ff58f84c77ba9c3\",\"license\":\"MIT\"},\"solady/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n/// @dev Note:\\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\\n///   minting and transferring zero tokens, as well as self-approvals.\\n///   For performance, this implementation WILL NOT revert for such actions.\\n///   Please add any checks with overrides if desired.\\n/// - The `permit` function uses the ecrecover precompile (0x1).\\n///\\n/// If you are overriding:\\n/// - NEVER violate the ERC20 invariant:\\n///   the total sum of all balances must be equal to `totalSupply()`.\\n/// - Check that the overridden function is actually used in the function you want to\\n///   change the behavior of. Much of the code has been manually inlined for performance.\\nabstract contract ERC20 {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /// @dev The allowance of Permit2 is fixed at infinity.\\n    error Permit2AllowanceIsFixedAtInfinity();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 private constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev `keccak256(\\\"1\\\")`.\\n    /// If you need to use a different version, override `_versionHash`.\\n    bytes32 private constant _DEFAULT_VERSION_HASH =\\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @dev `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.\\n    /// Enabled by default. To disable, override `_givePermit2InfiniteAllowance()`.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the decimals places of the token.\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        if (_givePermit2InfiniteAllowance()) {\\n            if (spender == _PERMIT2) return type(uint256).max;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        // Code duplication is for zero-cost abstraction if possible.\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let from_ := shl(96, from)\\n                if iszero(eq(caller(), _PERMIT2)) {\\n                    // Compute the allowance slot and load its value.\\n                    mstore(0x20, caller())\\n                    mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n                    let allowanceSlot := keccak256(0x0c, 0x34)\\n                    let allowance_ := sload(allowanceSlot)\\n                    // If the allowance is not the maximum uint256 value.\\n                    if not(allowance_) {\\n                        // Revert if the amount to be transferred exceeds the allowance.\\n                        if gt(amount, allowance_) {\\n                            mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        // Subtract and store the updated allowance.\\n                        sstore(allowanceSlot, sub(allowance_, amount))\\n                    }\\n                }\\n                // Compute the balance slot and load its value.\\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\\n                let fromBalance := sload(fromBalanceSlot)\\n                // Revert if insufficient balance.\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated balance.\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                // Compute the balance slot of `to`.\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x20)\\n                // Add and store the updated balance of `to`.\\n                // Will not overflow because the sum of all user balances\\n                // cannot exceed the maximum uint256 value.\\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n                // Emit the {Transfer} event.\\n                mstore(0x20, amount)\\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let from_ := shl(96, from)\\n                // Compute the allowance slot and load its value.\\n                mstore(0x20, caller())\\n                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n                let allowanceSlot := keccak256(0x0c, 0x34)\\n                let allowance_ := sload(allowanceSlot)\\n                // If the allowance is not the maximum uint256 value.\\n                if not(allowance_) {\\n                    // Revert if the amount to be transferred exceeds the allowance.\\n                    if gt(amount, allowance_) {\\n                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    // Subtract and store the updated allowance.\\n                    sstore(allowanceSlot, sub(allowance_, amount))\\n                }\\n                // Compute the balance slot and load its value.\\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\\n                let fromBalance := sload(fromBalanceSlot)\\n                // Revert if insufficient balance.\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated balance.\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                // Compute the balance slot of `to`.\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x20)\\n                // Add and store the updated balance of `to`.\\n                // Will not overflow because the sum of all user balances\\n                // cannot exceed the maximum uint256 value.\\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n                // Emit the {Transfer} event.\\n                mstore(0x20, amount)\\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n            }\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          EIP-2612                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev For more performance, override to return the constant value\\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\\n\\n    /// @dev If you need a different value, override this function.\\n    function _versionHash() internal view virtual returns (bytes32 result) {\\n        result = _DEFAULT_VERSION_HASH;\\n    }\\n\\n    /// @dev For inheriting contracts to increment the nonce.\\n    function _incrementNonce(address owner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            sstore(nonceSlot, add(1, sload(nonceSlot)))\\n        }\\n    }\\n\\n    /// @dev Returns the current nonce for `owner`.\\n    /// This value is used to compute the signature for EIP-2612 permit.\\n    function nonces(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\\n    /// authorized by a signed approval by `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && value != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        bytes32 versionHash = _versionHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Revert if the block timestamp is greater than `deadline`.\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            // Clean the upper 96 bits.\\n            owner := shr(96, shl(96, owner))\\n            spender := shr(96, shl(96, spender))\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            let nonceValue := sload(nonceSlot)\\n            // Prepare the domain separator.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            mstore(0x2e, keccak256(m, 0xa0))\\n            // Prepare the struct hash.\\n            mstore(m, _PERMIT_TYPEHASH)\\n            mstore(add(m, 0x20), owner)\\n            mstore(add(m, 0x40), spender)\\n            mstore(add(m, 0x60), value)\\n            mstore(add(m, 0x80), nonceValue)\\n            mstore(add(m, 0xa0), deadline)\\n            mstore(0x4e, keccak256(m, 0xc0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0x00, keccak256(0x2c, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            let t := staticcall(gas(), 1, 0x00, 0x80, 0x20, 0x20)\\n            // If the ecrecover fails, the returndatasize will be 0x00,\\n            // `owner` will be checked if it equals the hash at 0x00,\\n            // which evaluates to false (i.e. 0), and we will revert.\\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\\n            // `owner` will be compared against the returned address at 0x20.\\n            if iszero(eq(mload(returndatasize()), owner)) {\\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Increment and store the updated nonce.\\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\\n            // Compute the allowance slot and store the value.\\n            // The `owner` is already at slot 0x20.\\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\\n            sstore(keccak256(0x2c, 0x34), value)\\n            // Emit the {Approval} event.\\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        bytes32 versionHash = _versionHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if not(allowance_) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          PERMIT2                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns whether to fix the Permit2 contract's allowance at infinity.\\n    ///\\n    /// This value should be kept constant after contract initialization,\\n    /// or else the actual allowance values may not match with the {Approval} events.\\n    /// For best performance, return a compile-time constant for zero-cost abstraction.\\n    function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x19826a737039994947e9971d996e80c658f3c380705e30e7d1b5c40d35f454ac\",\"license\":\"MIT\"},\"solady/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\nlibrary SafeTransferLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The ERC20 `totalSupply` query has failed.\\n    error TotalSupplyQueryFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /// @dev The Permit2 approve operation has failed.\\n    error Permit2ApproveFailed();\\n\\n    /// @dev The Permit2 lockdown operation has failed.\\n    error Permit2LockdownFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n            if iszero(and(eq(mload(0x00), 1), success)) {\\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                    mstore(0x34, 0) // Store 0 for the `amount`.\\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                    mstore(0x34, amount) // Store back the original `amount`.\\n                    // Retry the approval, reverting upon failure.\\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    if iszero(and(eq(mload(0x00), 1), success)) {\\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                    }\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Performs a `token.balanceOf(account)` check.\\n    /// `implemented` denotes whether the `token` does not implement `balanceOf`.\\n    /// `amount` is zero if the `token` does not implement `balanceOf`.\\n    function checkBalanceOf(address token, address account)\\n        internal\\n        view\\n        returns (bool implemented, uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            implemented :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                )\\n            amount := mul(mload(0x20), implemented)\\n        }\\n    }\\n\\n    /// @dev Returns the total supply of the `token`.\\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\\n    function totalSupply(address token) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(\\n                and(\\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(\\n                        add(m, 0x94),\\n                        lt(iszero(amount), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    )\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `amount != 0` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero( // Revert if token does not have code, or if the call fails.\\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Approves `spender` to spend `amount` of `token` for `address(this)`.\\n    function permit2Approve(address token, address spender, uint160 amount, uint48 expiration)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let addressMask := shr(96, not(0))\\n            let m := mload(0x40)\\n            mstore(m, 0x87517c45) // `approve(address,address,uint160,uint48)`.\\n            mstore(add(m, 0x20), and(addressMask, token))\\n            mstore(add(m, 0x40), and(addressMask, spender))\\n            mstore(add(m, 0x60), and(addressMask, amount))\\n            mstore(add(m, 0x80), and(0xffffffffffff, expiration))\\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\\n                mstore(0x00, 0x324f14ae) // `Permit2ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Revokes an approval for `token` and `spender` for `address(this)`.\\n    function permit2Lockdown(address token, address spender) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0xcc53287f) // `Permit2.lockdown`.\\n            mstore(add(m, 0x20), 0x20) // Offset of the `approvals`.\\n            mstore(add(m, 0x40), 1) // `approvals.length`.\\n            mstore(add(m, 0x60), shr(96, shl(96, token)))\\n            mstore(add(m, 0x80), shr(96, shl(96, spender)))\\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\\n                mstore(0x00, 0x96b3de23) // `Permit2LockdownFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x960d5b7ca568a090c4a7785ddfd88f6ce135ced94f5c79c34e5519a71772a817\",\"license\":\"MIT\"}},\"version\":1}",
	"bytecode": "0x6080604052670de0b6b3a7640000600b55348015601b57600080fd5b50615f0e8061002b6000396000f3fe6080604052600436106102365760003560e01c80639681096f1161012f578063c0cc3fcf116100b1578063c0cc3fcf14610735578063c42cf53514610753578063cfeaa3ec14610790578063d087d288146107b0578063d0a5e6ce146107d2578063d4fac45d1461080f578063d94c3bc91461082f578063da51c3ac14610865578063de3d9fb714610885578063e76d5168146108be578063ea7b4f77146108dc578063fb512c551461092457600080fd5b80639681096f1461059b57806396d3b83d146105bb578063976931071461060157806398d5fdca1461062357806399d25455146106385780639d3795e414610658578063a07b57f614610678578063a0cf0aea146106a5578063a2785f0b146106cd578063b1e21749146106e2578063bdacb303146106f857600080fd5b80634b0795a8116101b85780634b0795a8146103d557806352d84c62146103ea5780635bb478081461042a578063615f64fe1461046757806367e828bf146104c95780636a6339c1146104de5780636aac7002146104f35780636e04ff0d1461051357806388cc58e4146105415780638a8713641461056857806391b7f5ed1461057b57600080fd5b806301fce27e1461024257806309a16bd51461026d5780630bb106eb1461028c5780630ca76175146102cc5780631a3b149d146102ee5780631a93d1c31461030e5780631d41b5c41461034057806324ae6a27146103605780633944ea3a146103805780633b19e84a146103a25780634585e33b146103b557600080fd5b3661023d57005b600080fd5b34801561024e57600080fd5b50610257610949565b604051610264919061469f565b60405180910390f35b34801561027957600080fd5b50600c545b604051908152602001610264565b34801561029857600080fd5b506102bc6102a7366004614759565b60196020526000908152604090205460ff1681565b6040519015158152602001610264565b3480156102d857600080fd5b506102ec6102e736600461487b565b610a0c565b005b3480156102fa57600080fd5b5061027e61030936600461490e565b610a72565b34801561031a57600080fd5b50600054600160e01b900463ffffffff1660405163ffffffff9091168152602001610264565b34801561034c57600080fd5b506102ec61035b366004614a13565b610d27565b34801561036c57600080fd5b506102ec61037b366004614b19565b610df3565b34801561038c57600080fd5b50610395610e9f565b6040516102649190614ba2565b3480156103ae57600080fd5b504761027e565b3480156103c157600080fd5b506102ec6103d0366004614bb5565b610f2d565b3480156103e157600080fd5b506103956113b1565b3480156103f657600080fd5b506102ec610405366004614c27565b6000805463ffffffff909216600160e01b026001600160e01b03909216919091179055565b34801561043657600080fd5b506102ec610445366004614c42565b601380546001600160a01b0319166001600160a01b0392909216919091179055565b34801561047357600080fd5b50601354601154600d54600e54601054600f54604080516001600160a01b0397881681529587166020870152938616938501939093529084166060840152831660808301529190911660a082015260c001610264565b3480156104d557600080fd5b506103956113be565b3480156104ea57600080fd5b5060015461027e565b3480156104ff57600080fd5b5061027e61050e366004614c5f565b6113cb565b34801561051f57600080fd5b5061053361052e366004614bb5565b611473565b604051610264929190614ca0565b34801561054d57600080fd5b506013546001600160a01b03165b6040516102649190614cbb565b6102ec610576366004614d3d565b611797565b34801561058757600080fd5b506102ec610596366004614e16565b600b55565b3480156105a757600080fd5b5061027e6105b6366004614e2f565b611943565b3480156105c757600080fd5b506102ec6105d6366004614ead565b6001600160401b03919091166000908152601960205260409020805460ff1916911515919091179055565b34801561060d57600080fd5b5061061661197a565b6040516102649190614ed9565b34801561062f57600080fd5b50600b5461027e565b34801561064457600080fd5b506102ec610653366004614f93565b611b99565b34801561066457600080fd5b506102ec610673366004614fc7565b611ba9565b34801561068457600080fd5b50610698610693366004614e16565b6122ba565b60405161026491906150a9565b3480156106b157600080fd5b5061055b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee81565b3480156106d957600080fd5b5060035461027e565b3480156106ee57600080fd5b5061027e60025481565b34801561070457600080fd5b506102ec610713366004614c42565b600e80546001600160a01b0319166001600160a01b0392909216919091179055565b34801561074157600080fd5b506012546001600160a01b031661055b565b34801561075f57600080fd5b506102ec61076e366004614c42565b601080546001600160a01b0319166001600160a01b0392909216919091179055565b34801561079c57600080fd5b506102ec6107ab366004614e16565b600155565b3480156107bc57600080fd5b503360009081526018602052604090205461027e565b3480156107de57600080fd5b506102ec6107ed366004614c42565b600d80546001600160a01b0319166001600160a01b0392909216919091179055565b34801561081b57600080fd5b506102ec61082a366004614b19565b6125d5565b34801561083b57600080fd5b5061027e61084a366004614c42565b6001600160a01b031660009081526016602052604090205490565b34801561087157600080fd5b506102ec610880366004615165565b6125df565b34801561089157600080fd5b50600054600160a01b90046001600160401b03165b6040516001600160401b039091168152602001610264565b3480156108ca57600080fd5b506011546001600160a01b031661055b565b3480156108e857600080fd5b506102ec6108f7366004614759565b600080546001600160401b03909216600160a01b0267ffffffffffffffff60a01b19909216919091179055565b34801561093057600080fd5b50601354600160a01b90046001600160401b03166108a6565b60606004805480602002602001604051908101604052809291908181526020016000905b82821015610a035760008481526020908190206040805161010080820183526007870290930180546001600160a01b039081168352600180830154909116838701526002820154938301939093526003810154606083015260048101546080830152600581015460a08301526006015460ff808216151560c0840152939004909216151560e0830152908352909201910161096d565b50505050905090565b6000546001600160a01b03163314610a375760405163c6829f8360e01b815260040160405180910390fd5b610a42838383612662565b60405183907f85e1543bf2f84fe80c6badbce3648c8539ad1df4d2b3d822938ca0538be727e690600090a2505050565b33600090815260166020526040812054808203610aaa5760405163442d09d960e01b8152600481018290526024015b60405180910390fd5b6000818152601460205260409020600501546001600160a01b03163314610ae45760405163075fd2b160e01b815260040160405180910390fd5b856001600160a01b038116610b0c5760405163502ffa3f60e11b815260040160405180910390fd5b601154600090610b2a908990899089906001600160a01b03166129be565b60115460125460405163095ea7b360e01b81529293506001600160a01b039182169263095ea7b392610b6292169089906004016151b2565b6020604051808303816000875af1158015610b81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ba591906151cb565b5060125460405163095ea7b360e01b81526001600160a01b038981169263095ea7b392610bda92909116908a906004016151b2565b6020604051808303816000875af1158015610bf9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c1d91906151cb565b506012546013546040516396f4e9f960e01b81526001600160a01b03909216916396f4e9f991610c6391600160a01b9091046001600160401b03169085906004016151e8565b6020604051808303816000875af1158015610c82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ca691906152c9565b601354601154604080516001600160a01b03808e168252808d1660208301529181018b90529116606082015260808101889052919550600160a01b90046001600160401b03169085907fc15fb748c32ba4eb29c1c311e78533f93b4425eab49ea87c6fe4279ecadca0439060a00160405180910390a3505050949350505050565b8751600d80546001600160a01b03199081166001600160a01b03938416179091556020808b0151600e8054841691851691909117905560408b015160108054841691851691909117905560608b0151600f80548416918516919091179055895160118054841691851691909117905589015160128054831691841691909117905560a0890151601380546001600160e01b031916600160a01b6001600160401b039093169290920290921617918816919091179055610de98585858585612b41565b5050505050505050565b60006001600160a01b03831673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610e8b576040516370a0823160e01b81526001600160a01b038416906370a0823190610e45903090600401614cbb565b602060405180830381865afa158015610e62573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8691906152c9565b610e8d565b475b9050610e9a838383612b87565b505050565b60058054610eac906152e2565b80601f0160208091040260200160405190810160405280929190818152602001828054610ed8906152e2565b8015610f255780601f10610efa57610100808354040283529160200191610f25565b820191906000526020600020905b815481529060010190602001808311610f0857829003601f168201915b505050505081565b6000610f3b82840184615316565b90506000805b8251811015610fdf5760086000848381518110610f6057610f60615448565b6020026020010151600001516001600160a01b03166001600160a01b031681526020019081526020016000206000848381518110610fa057610fa0615448565b6020908102919091018101516060015182528101919091526040016000206006015460ff16610fd75781610fd381615474565b9250505b600101610f41565b506000816001600160401b03811115610ffa57610ffa614774565b60405190808252806020026020018201604052801561102d57816020015b60608152602001906001900390816110185790505b5090506000826001600160401b0381111561104a5761104a614774565b60405190808252806020026020018201604052801561108357816020015b6110706145fd565b8152602001906001900390816110685790505b5090506000805b85518110156112455760008682815181106110a7576110a7615448565b60209081029190910181015180516001600160a01b0316600090815260088352604080822060608401518352909352919091206006015490915060ff1661123c5780516001600160a01b03166000908152600860209081526040808320606085015184529091528120600601805460ff19166001179055815161112990612bc1565b6111368360400151612d6a565b6111438460600151612d6a565b6111508560800151612d6a565b61115d8660a00151612d6a565b61116a8760200151612bc1565b60405160200161117f969594939291906154a9565b6040516020818303038152906040529050808685815181106111a3576111a3615448565b6020026020010181905250818585815181106111c1576111c1615448565b60200260200101819052508160600151826040015183600001516001600160a01b03167f4faaacddef25e33933b6bb8be5852d80c222368e2f127653865bda8b517a440c85608001518660a0015187602001518c60405161122594939291906155ad565b60405180910390a48361123781615474565b945050505b5060010161108a565b5083156113a857610de960405180610120016040528060078054611268906152e2565b80601f0160208091040260200160405190810160405280929190818152602001828054611294906152e2565b80156112e15780601f106112b6576101008083540402835291602001916112e1565b820191906000526020600020905b8154815290600101906020018083116112c457829003601f168201915b50505050508152602001604051806020016040528060008152508152602001600060ff16815260200160006001600160401b0316815260200185815260200160006001600160401b0381111561133957611339614774565b60405190808252806020026020018201604052801561136c57816020015b60608152602001906001900390816113575790505b508152600054600160a01b81046001600160401b03166020830152600160e01b900463ffffffff16604082015260015460609091015283612e6a565b50505050505050565b60068054610eac906152e2565b60078054610eac906152e2565b6012546013546011546000926001600160a01b03908116926320487ded92600160a01b9091046001600160401b03169161140b91899189918991166129be565b6040518363ffffffff1660e01b81526004016114289291906151e8565b602060405180830381865afa158015611445573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061146991906152c9565b90505b9392505050565b600060606000805b60045481101561155957426004828154811061149957611499615448565b9060005260206000209060070201600401541115801561153e575060086000600483815481106114cb576114cb615448565b600091825260208083206007909202909101546001600160a01b031683528201929092526040018120600480549192918490811061150b5761150b615448565b906000526020600020906007020160030154815260200190815260200160002060060160009054906101000a900460ff16155b15611551578161154d81615474565b9250505b60010161147b565b508060000361157b575050604080516020810190915260008082529150611790565b6000816001600160401b0381111561159557611595614774565b6040519080825280602002602001820160405280156115ce57816020015b6115bb6145fd565b8152602001906001900390816115b35790505b5090506000805b6004548110156117655742600482815481106115f3576115f3615448565b906000526020600020906007020160040154111580156116985750600860006004838154811061162557611625615448565b600091825260208083206007909202909101546001600160a01b031683528201929092526040018120600480549192918490811061166557611665615448565b906000526020600020906007020160030154815260200190815260200160002060060160009054906101000a900460ff16155b1561175d57600481815481106116b0576116b0615448565b6000918252602091829020604080516101008082018352600790940290920180546001600160a01b039081168452600182015416948301949094526002840154908201526003830154606082015260048301546080820152600583015460a082015260069092015460ff808216151560c085015291900416151560e0820152835184908490811061174357611743615448565b6020026020010181905250818061175990615474565b9250505b6001016115d5565b5081604051602001611777919061469f565b6040516020818303038152906040529350600194505050505b9250929050565b600b546011546040516370a0823160e01b81526001600160a01b03909116906370a08231906117ca903390600401614cbb565b602060405180830381865afa1580156117e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061180b91906152c9565b101561182a57604051631cf2628760e31b815260040160405180910390fd5b600b54601154604051636eb1769f60e11b81523360048201523060248201526001600160a01b039091169063dd62ed3e90604401602060405180830381865afa15801561187b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061189f91906152c9565b10156118be57604051630fd3919360e01b815260040160405180910390fd5b60115460408051606081018252338152306020820152600b54918101919091526118f1916001600160a01b031690613282565b507f76dce1c3fdc4d27b2f00ebc0d6d819bda910678c5aa4b6c30bea2bff32f526ab88888888888888883360405161193199989796959493929190615725565b60405180910390a15050505050505050565b600061195185858585613301565b60028190556000818152600a60205260409020805460ff1916600117905590505b949350505050565b600454606090806001600160401b0381111561199857611998614774565b604051908082528060200260200182016040528015611a2e57816020015b611a1b60405180610120016040528060006001600160a01b0316815260200160006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581526020016000151581525090565b8152602001906001900390816119b65790505b50915060005b81811015611b9457600060048281548110611a5157611a51615448565b60009182526020808320604080516101008082018352600790950290920180546001600160a01b0390811684526001820154169383019390935260028301549082015260038201546060820152600482015460808201819052600583015460a083015260069092015460ff808216151560c0840152939004909216151560e0830152909250421015611af257428260800151611aed919061586f565b611af5565b60005b905060405180610120016040528083600001516001600160a01b0316815260200183602001516001600160a01b031681526020018360400151815260200183606001518152602001836080015181526020018360a0015181526020018281526020018360c00151151581526020018360e001511515815250858481518110611b7f57611b7f615448565b60209081029190910101525050600101611a34565b505090565b6007611ba582826158d0565b5050565b6013546001600160a01b03163314611bd45760405163075fd2b160e01b815260040160405180910390fd5b838214611bf45760405163636e39bb60e01b815260040160405180910390fd5b33600090815260186020526040812080548290611c1090615474565b91905081905590506000600c60008154611c2990615474565b9182905550600d54909150600090611c4b906001600160a01b031633856133b5565b600e54909150600090611c72906001600160a01b031633611c6d87600161598e565b6133b5565b601054909150600090611c94906001600160a01b031633611c6d88600261598e565b9050611ca185600261598e565b33600090815260186020526040902055611cbb838e613406565b611cc5828d61347b565b600f54611ce2908290859085906001600160a01b03168f896134bf565b816001600160a01b0316632f2ff15d836001600160a01b0316638f61f4f56040518163ffffffff1660e01b8152600401602060405180830381865afa158015611d2f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d5391906152c9565b836040518363ffffffff1660e01b8152600401611d719291906159a1565b600060405180830381600087803b158015611d8b57600080fd5b505af1158015611d9f573d6000803e3d6000fd5b50505050816001600160a01b0316632f2ff15d836001600160a01b03166307bd02656040518163ffffffff1660e01b8152600401602060405180830381865afa158015611df0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e1491906152c9565b60006040518363ffffffff1660e01b8152600401611e339291906159a1565b600060405180830381600087803b158015611e4d57600080fd5b505af1158015611e61573d6000803e3d6000fd5b50505050816001600160a01b03166336568abe836001600160a01b031663a217fddf6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611eb2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ed691906152c9565b306040518363ffffffff1660e01b8152600401611ef49291906159a1565b600060405180830381600087803b158015611f0e57600080fd5b505af1158015611f22573d6000803e3d6000fd5b5050604051637c88e3d960e01b81526001600160a01b0386169250637c88e3d99150611f58908d908d908d908d906004016159b8565b600060405180830381600087803b158015611f7257600080fd5b505af1158015611f86573d6000803e3d6000fd5b505060405163f2fde38b60e01b81526001600160a01b038616925063f2fde38b9150611fb6908590600401614cbb565b600060405180830381600087803b158015611fd057600080fd5b505af1158015611fe4573d6000803e3d6000fd5b5050601154600b5460405163a9059cbb60e01b81526001600160a01b03909216935063a9059cbb925061201c918591906004016151b2565b6020604051808303816000875af115801561203b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061205f91906151cb565b506001600160a01b038083166000818152601760209081526040808320899055858516808452601683529281902089905580516101208101825289815242928101929092528a8516908201529286166060840152608083019190915260a082015260c081016120ce8d806159df565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509082525060200161211560a08e018e6159df565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509082525060200161215c60c08e018e6159df565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052509390945250508681526014602090815260409182902084518155908401516001820155908301516002820180546001600160a01b039283166001600160a01b0319918216179091556060850151600384018054918416918316919091179055608085015160048401805491841691831691909117905560a085015160058401805491909316911617905560c0830151909150600682019061222d90826158d0565b5060e0820151600782019061224290826158d0565b50610100820151600882019061225890826158d0565b5050604080516001600160a01b0386811682528581166020830152841681830152905133925086917f3b785ea6f499a552d583841394f9e27727de143f34ed2585796814f93887d84f919081900360600190a350505050505050505050505050565b61232d604051806101200160405280600081526020016000815260200160006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b031681526020016060815260200160608152602001606081525090565b81158061233b5750600c5482115b156123a9575050604080516101208101825260008082526020808301829052828401829052606083018290526080830182905260a083018290528351808201855282815260c08401528351808201855282815260e08401528351908101909352825261010081019190915290565b6000828152601460209081526040918290208251610120810184528154815260018201549281019290925260028101546001600160a01b0390811693830193909352600381015483166060830152600481015483166080830152600581015490921660a082015260068201805491929160c084019190612428906152e2565b80601f0160208091040260200160405190810160405280929190818152602001828054612454906152e2565b80156124a15780601f10612476576101008083540402835291602001916124a1565b820191906000526020600020905b81548152906001019060200180831161248457829003601f168201915b505050505081526020016007820180546124ba906152e2565b80601f01602080910402602001604051908101604052809291908181526020018280546124e6906152e2565b80156125335780601f1061250857610100808354040283529160200191612533565b820191906000526020600020905b81548152906001019060200180831161251657829003601f168201915b5050505050815260200160088201805461254c906152e2565b80601f0160208091040260200160405190810160405280929190818152602001828054612578906152e2565b80156125c55780601f1061259a576101008083540402835291602001916125c5565b820191906000526020600020905b8154815290600101906020018083116125a857829003601f168201915b5050505050815250509050919050565b610e9a8282613685565b33600090815260166020526040812054908190036126135760405163442d09d960e01b815260048101829052602401610aa1565b6000818152601460205260409020600501546001600160a01b0316331461264d5760405163075fd2b160e01b815260040160405180910390fd5b61265a86868686866136ce565b505050505050565b8260025414612687576040516367954e7760e01b815260048101849052602401610aa1565b6000838152600a60205260409020805460ff1916905560056126a983826158d0565b5060066126b682826158d0565b5081511561297d578160006126ca826138c6565b90506000600960006002548152602001908152602001600020805480602002602001604051908101604052809291908181526020016000905b828210156127995760008481526020908190206040805161010080820183526007870290930180546001600160a01b039081168352600180830154909116838701526002820154938301939093526003810154606083015260048101546080830152600581015460a08301526006015460ff808216151560c0840152939004909216151560e08301529083529092019101612703565b50505050905060005b815181101561297857600860008383815181106127c1576127c1615448565b6020026020010151600001516001600160a01b03166001600160a01b03168152602001908152602001600020600083838151811061280157612801615448565b602002602001015160600151815260200190815260200160002060060160019054906101000a900460ff166129705781818151811061284257612842615448565b6020026020010151600001516001600160a01b0316633216e1f683838151811061286e5761286e615448565b60200260200101516060015185848151811061288c5761288c615448565b60200260200101516040518363ffffffff1660e01b81526004016128b1929190615a25565b600060405180830381600087803b1580156128cb57600080fd5b505af11580156128df573d6000803e3d6000fd5b505050506001600860008484815181106128fb576128fb615448565b6020026020010151600001516001600160a01b03166001600160a01b03168152602001908152602001600020600084848151811061293b5761293b615448565b602002602001015160600151815260200190815260200160002060060160016101000a81548160ff0219169083151502179055505b6001016127a2565b505050505b827f7873807bf6ddc50401cd3d29bbe0decee23fd4d68d273f4b5eb83cded4d2f172600560066040516129b1929190615ac1565b60405180910390a2505050565b6129f96040518060a0016040528060608152602001606081526020016060815260200160006001600160a01b03168152602001606081525090565b604080516001808252818301909252600091816020015b6040805180820190915260008082526020820152815260200190600190039081612a105790505090506040518060400160405280866001600160a01b031681526020018581525081600081518110612a6a57612a6a615448565b60200260200101819052506040518060a0016040528087604051602001612a919190614cbb565b6040516020818303038152906040528152602001604051806020016040528060008152508152602001828152602001846001600160a01b03168152602001612b35604051806040016040528060008152602001600115158152506040805182516024820152602092830151151560448083019190915282518083039091018152606490910190915290810180516001600160e01b0316630181dcf160e41b17905290565b90529695505050505050565b63ffffffff8316600160e01b026001600160e01b036001600160401b038616600160a01b02166001600160a01b03871617176000556001829055600761265a82826158d0565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed196001600160a01b03841601612bb657610e9a8282613b88565b610e9a838383613ba4565b60408051602a808252606082810190935260009190602082018180368337019050509050600360fc1b81600081518110612bfd57612bfd615448565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110612c2c57612c2c615448565b60200101906001600160f81b031916908160001a90535060005b6014811015612d63576000612c5c82601361586f565b612c67906008615ae6565b612c72906002615be4565b612c85906001600160a01b038716615c06565b60f81b9050600060108260f81c612c9c9190615c1a565b60f81b905060008160f81c6010612cb39190615c3c565b8360f81c612cc19190615c58565b60f81b9050612ccf82613bf4565b85612cdb866002615ae6565b612ce690600261598e565b81518110612cf657612cf6615448565b60200101906001600160f81b031916908160001a905350612d1681613bf4565b85612d22866002615ae6565b612d2d90600361598e565b81518110612d3d57612d3d615448565b60200101906001600160f81b031916908160001a9053505060019092019150612c469050565b5092915050565b606081600003612d915750506040805180820190915260018152600360fc1b602082015290565b6000825b8015612dbb5781612da581615474565b9250612db49050600a82615c06565b9050612d95565b6000826001600160401b03811115612dd557612dd5614774565b6040519080825280601f01601f191660200182016040528015612dff576020820181803683370190505b5090505b841561197257612e1460018461586f565b9250612e21600a86615c71565b612e2c90603061598e565b60f81b818481518110612e4157612e41615448565b60200101906001600160f81b031916908160001a905350612e63600a86615c06565b9450612e03565b6000612ead6040805160e0810190915280600081526020016000815260200160008152602001606081526020016060815260200160608152602001606081525090565b8351612eba908290613c2f565b60208401515115612eda576020840151612ed5908290613c3c565b612f02565b60608401516001600160401b031615612f025760408401516060850151612f02918391613c6d565b60808401515115612f1d576080840151612f1d908290613d03565b60a08401515115612f385760a0840151612f38908290613d2d565b612f59612f4482613d57565b8560c001518660e00151876101000151613301565b60028190556000818152600a60205260408120805460ff191660011790559092505b83518110156132795760008381526009602052604090208451859083908110612fa657612fa6615448565b6020908102919091018101518254600180820185556000948552838520835160079093020180546001600160a01b03199081166001600160a01b03948516178255948401519181018054909516919092161790925560408101516002830155606081015160038301556080810151600483015560a0810151600583015560c08101516006909201805460e09092015161ffff1990921692151561ff00191692909217610100911515919091021790555b6004548110156132705784828151811061307257613072615448565b6020026020010151600001516001600160a01b03166004828154811061309a5761309a615448565b60009182526020909120600790910201546001600160a01b031614801561310157508482815181106130ce576130ce615448565b602002602001015160600151600482815481106130ed576130ed615448565b906000526020600020906007020160030154145b1561326857600480546131169060019061586f565b8154811061312657613126615448565b90600052602060002090600702016004828154811061314757613147615448565b60009182526020909120825460079092020180546001600160a01b039283166001600160a01b0319918216178255600180850154908301805491909416911617909155600280830154908201556003808301549082015560048083015481830155600580840154908301556006928301805493909201805460ff19811660ff95861615159081178355935461ffff1990911661ff00199094169390931761010093849004909416151590920292909217905580548061320857613208615c85565b60008281526020812060076000199093019283020180546001600160a01b0319908116825560018201805490911690556002810182905560038101829055600481018290556005810191909155600601805461ffff191690559055613270565b600101613056565b50600101612f7b565b50505b92915050565b604081015160009073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed196001600160a01b038516016132e357803410156132d0576040516374c5672b60e01b815260040160405180910390fd5b6132de836020015182613b88565b6132f7565b6132f784846000015185602001518461401f565b5060019392505050565b6000805460405163230e93b160e11b815282916001600160a01b03169063461d27629061333b9088908a906001908a908a90600401615c9b565b6020604051808303816000875af115801561335a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061337e91906152c9565b60405190915081907f1131472297a800fee664d1d89cfa8f7676ff07189ecc53f80bbb5f4969099db890600090a295945050505050565b6040516001600160601b0319606084901b1660208201526034810182905260009081906054016040516020818303038152906040528051906020012090506133fd858261407d565b95945050505050565b6001600160a01b03821663077f224a61341f83806159df565b61342c60208601866159df565b306040518663ffffffff1660e01b815260040161344d959493929190615ce4565b600060405180830381600087803b15801561346757600080fd5b505af115801561265a573d6000803e3d6000fd5b604080516000808252602082019081528183019283905263c4c4c7b360e01b9092526001600160a01b0384169163c4c4c7b39161344d918591903060448301615d61565b604080516101408101909152600090806134d985806159df565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050908252506001600160a01b0380891660208084019190915290881660408084019190915260609092019161354591908701908701615da6565b65ffffffffffff1681526020016135626060860160408701614c27565b63ffffffff168152606080860135602083015260808087013560408401529082018590520161359460a08601866159df565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050908252506020016135db60c08601866159df565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050915250601154604051633f329cd560e21b81529192506001600160a01b03808a169263fcca73549261364a9286928a9290911690600401615dc1565b600060405180830381600087803b15801561366457600080fd5b505af1158015613678573d6000803e3d6000fd5b5050505050505050505050565b600073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed196001600160a01b038416016136bd57506001600160a01b0381163161327c565b6136c7838361408b565b905061327c565b604080516101008082018352338083526001600160a01b0385811660208086018281528688018d815260608089018e815260808a018e815260a08b018e8152600060c08d0181815260e08e018281526004805460018101825593529d5160079092027f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b81018054938d166001600160a01b031994851617905597517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19c8901805491909c1692169190911790995593517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19d86015590517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19e850155517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19f84015590517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1a083015593517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1a190910180549751151590960261ff00199115159190911661ffff199097169690961795909517909355845188815293840187905293830191909152869288927fce2df6fbb048de1d0af3bc2af20822ee09ffb85d9115939f7cca593511811d0c910160405180910390a45050505050565b606081600160005b8251811015613918578281815181106138e9576138e9615448565b01602001516001600160f81b031916601f60fa1b03613910578161390c81615474565b9250505b6001016138ce565b506000816001600160401b0381111561393357613933614774565b60405190808252806020026020018201604052801561396657816020015b60608152602001906001900390816139515790505b50905060008060005b8551811015613a995785818151811061398a5761398a615448565b01602001516001600160f81b031916601f60fa1b03613a915760006139af848361586f565b6001600160401b038111156139c6576139c6614774565b6040519080825280601f01601f1916602001820160405280156139f0576020820181803683370190505b509050835b82811015613a5857878181518110613a0f57613a0f615448565b01602001516001600160f81b03191682613a29878461586f565b81518110613a3957613a39615448565b60200101906001600160f81b031916908160001a9053506001016139f5565b50808584613a6581615474565b955081518110613a7757613a77615448565b6020908102919091010152613a8d82600161598e565b9350505b60010161396f565b508451821015613b7d576000828651613ab2919061586f565b6001600160401b03811115613ac957613ac9614774565b6040519080825280601f01601f191660200182016040528015613af3576020820181803683370190505b509050825b8651811015613b5c57868181518110613b1357613b13615448565b01602001516001600160f81b03191682613b2d868461586f565b81518110613b3d57613b3d615448565b60200101906001600160f81b031916908160001a905350600101613af8565b5080848381518110613b7057613b70615448565b6020026020010181905250505b509095945050505050565b60003860003884865af1611ba55763b12d13eb6000526004601cfd5b816014528060345263a9059cbb60601b60005260206000604460106000875af18060016000511416613be957803d853b151710613be9576390b8ec186000526004601cfd5b506000603452505050565b6000600a60f883901c1015613c1b57613c1260f883901c6030615ea9565b60f81b92915050565b613c1260f883901c6057615ea9565b919050565b611ba582600080846140b7565b8051600003613c5e5760405163e889636f60e01b815260040160405180910390fd5b60016020830152608090910152565b6000613c7a610100614135565b9050613cad604051806040016040528060068152602001651cdb1bdd125160d21b8152508261415690919063ffffffff16565b613cba8160ff851661416f565b6040805180820190915260078152663b32b939b4b7b760c91b6020820152613ce3908290614156565b613ced818361416f565b6002602085015251516080909301929092525050565b8051600003613d255760405163fe936cb760e01b815260040160405180910390fd5b60a090910152565b8051600003613d4f5760405163fe936cb760e01b815260040160405180910390fd5b60c090910152565b60606000613d66610100614135565b9050613d9f6040518060400160405280600c81526020016b31b7b232a637b1b0ba34b7b760a11b8152508261415690919063ffffffff16565b8251613dbd906002811115613db657613db6615ec2565b829061417b565b6040805180820190915260088152676c616e677561676560c01b6020820152613de7908290614156565b6040830151613dfe908015613db657613db6615ec2565b604080518082019091526006815265736f7572636560d01b6020820152613e26908290614156565b6060830151613e36908290614156565b60a08301515115613ec2576040805180820190915260048152636172677360e01b6020820152613e67908290614156565b613e70816141b4565b60005b8360a0015151811015613eb857613eb08460a001518281518110613e9957613e99615448565b60200260200101518361415690919063ffffffff16565b600101613e73565b50613ec2816141d8565b60808301515115613f8657600083602001516002811115613ee557613ee5615ec2565b03613f035760405163a80d31f760e01b815260040160405180910390fd5b60408051808201909152600f81526e39b2b1b932ba39a637b1b0ba34b7b760891b6020820152613f34908290614156565b613f4d83602001516002811115613db657613db6615ec2565b6040805180820190915260078152667365637265747360c81b6020820152613f76908290614156565b6080830151613f869082906141f6565b60c083015151156140175760408051808201909152600981526862797465734172677360b81b6020820152613fbc908290614156565b613fc5816141b4565b60005b8360c001515181101561400d576140058460c001518281518110613fee57613fee615448565b6020026020010151836141f690919063ffffffff16565b600101613fc8565b50614017816141d8565b515192915050565b60405181606052826040528360601b602c526323b872dd60601b600c52602060006064601c6000895af1806001600051141661406e57803d873b15171061406e57637939f4246000526004601cfd5b50600060605260405250505050565b600061146c83836000614203565b6000816014526370a0823160601b60005260208060246010865afa601f3d111660205102905092915050565b80516000036140d9576040516322ce3edd60e01b815260040160405180910390fd5b838360028111156140ec576140ec615ec2565b908160028111156140ff576140ff615ec2565b9052506040840182801561411557614115615ec2565b9081801561412557614125615ec2565b9052506060909301929092525050565b61413d614658565b8051614149908361429a565b5060006020820152919050565b6141638260038351614304565b8151610e9a9082614423565b611ba582600083614304565b81516141889060c2614437565b50611ba582826040516020016141a091815260200190565b6040516020818303038152906040526141f6565b6141bf816004614493565b6001816020018181516141d2919061598e565b90525050565b6141e3816007614493565b6001816020018181516141d2919061586f565b6141638260028351614304565b60008147101561422f5760405163cf47918160e01b815247600482015260248101839052604401610aa1565b763d602d80600a3d3981f3363d3d373d3d3d363d730000008460601b60e81c176000526e5af43d82803e903d91602b57fd5bf38460781b17602052826037600984f590506001600160a01b03811661146c5760405163b06ebf3d60e01b815260040160405180910390fd5b6142a2614678565b6142ad602083615c71565b156142d5576142bd602083615c71565b6142c890602061586f565b6142d2908361598e565b91505b6020808401839052604051808552600081529081840101818110156142f957600080fd5b604052509192915050565b6017816001600160401b03161161433057825161432a9060e0600585901b168317614437565b50505050565b60ff816001600160401b031611614370578251614358906018611fe0600586901b1617614437565b50825161432a906001600160401b03831660016144aa565b61ffff816001600160401b0316116143b1578251614399906019611fe0600586901b1617614437565b50825161432a906001600160401b03831660026144aa565b63ffffffff816001600160401b0316116143f45782516143dc90601a611fe0600586901b1617614437565b50825161432a906001600160401b03831660046144aa565b825161440b90601b611fe0600586901b1617614437565b50825161432a906001600160401b03831660086144aa565b61442b614678565b61146c83838451614522565b61443f614678565b825151600061444f82600161598e565b905084602001518210614470576144708561446b836002615ae6565b6145e6565b8451602083820101858153508051821115614489578181525b5093949350505050565b8151610e9a90601f611fe0600585901b1617614437565b6144b2614678565b83515160006144c1828561598e565b905085602001518111156144de576144de8661446b836002615ae6565b600060016144ee86610100615be4565b6144f8919061586f565b90508651828101878319825116178152508051831115614516578281525b50959695505050505050565b61452a614678565b825182111561453857600080fd5b8351516000614547848361598e565b90508560200151811115614564576145648661446b836002615ae6565b85518051838201602001916000918085111561457e578482525b505050602086015b602086106145be578051825261459d60208361598e565b91506145aa60208261598e565b90506145b760208761586f565b9550614586565b51815160001960208890036101000a0190811690199190911617905250849150509392505050565b81516145f2838361429a565b5061432a8382614423565b60405180610100016040528060006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000151581526020016000151581525090565b604051806040016040528061466b614678565b8152602001600081525090565b604051806040016040528060608152602001600081525090565b6001600160a01b03169052565b602080825282518282018190526000918401906040840190835b81811015613b7d57835160018060a01b03815116845260018060a01b03602082015116602085015260408101516040850152606081015160608501526080810151608085015260a081015160a085015260c0810151151560c085015260e0810151905061472a60e085018215159052565b506020939093019261010092909201916001016146b9565b80356001600160401b0381168114613c2a57600080fd5b60006020828403121561476b57600080fd5b61146c82614742565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b03811182821017156147ac576147ac614774565b60405290565b60405161010081016001600160401b03811182821017156147ac576147ac614774565b604051601f8201601f191681016001600160401b03811182821017156147fd576147fd614774565b604052919050565b600082601f83011261481657600080fd5b8135602083016000806001600160401b0384111561483657614836614774565b50601f8301601f191660200161484b816147d5565b91505082815285838301111561486057600080fd5b82826020830137600092810160200192909252509392505050565b60008060006060848603121561489057600080fd5b8335925060208401356001600160401b038111156148ad57600080fd5b6148b986828701614805565b92505060408401356001600160401b038111156148d557600080fd5b6148e186828701614805565b9150509250925092565b6001600160a01b038116811461490057600080fd5b50565b8035613c2a816148eb565b6000806000806080858703121561492457600080fd5b843561492f816148eb565b9350602085013561493f816148eb565b93969395505050506040820135916060013590565b600060c0828403121561496657600080fd5b60405160c081016001600160401b038111828210171561498857614988614774565b6040529050808235614999816148eb565b815260208301356149a9816148eb565b602082015260408301356149bc816148eb565b604082015260608301356149cf816148eb565b606082015260808301356149e2816148eb565b60808201526149f360a08401614742565b60a08201525092915050565b803563ffffffff81168114613c2a57600080fd5b600080600080600080600080888a03610200811215614a3157600080fd5b6080811215614a3f57600080fd5b50614a4861478a565b8935614a53816148eb565b815260208a0135614a63816148eb565b602082015260408a0135614a76816148eb565b604082015260608a0135614a89816148eb565b60608201529750614a9d8a60808b01614954565b9650614aac6101408a01614903565b9550614abb6101608a01614903565b9450614aca6101808a01614742565b9350614ad96101a08a016149ff565b92506101c089013591506101e08901356001600160401b03811115614afd57600080fd5b614b098b828c01614805565b9150509295985092959890939650565b60008060408385031215614b2c57600080fd5b8235614b37816148eb565b91506020830135614b47816148eb565b809150509250929050565b60005b83811015614b6d578181015183820152602001614b55565b50506000910152565b60008151808452614b8e816020860160208601614b52565b601f01601f19169290920160200192915050565b60208152600061146c6020830184614b76565b60008060208385031215614bc857600080fd5b82356001600160401b03811115614bde57600080fd5b8301601f81018513614bef57600080fd5b80356001600160401b03811115614c0557600080fd5b856020828401011115614c1757600080fd5b6020919091019590945092505050565b600060208284031215614c3957600080fd5b61146c826149ff565b600060208284031215614c5457600080fd5b813561146c816148eb565b600080600060608486031215614c7457600080fd5b8335614c7f816148eb565b92506020840135614c8f816148eb565b929592945050506040919091013590565b82151581526040602082015260006114696040830184614b76565b6001600160a01b0391909116815260200190565b600060408284031215614ce157600080fd5b50919050565b600060e08284031215614ce157600080fd5b60008083601f840112614d0b57600080fd5b5081356001600160401b03811115614d2257600080fd5b6020830191508360208260051b850101111561179057600080fd5b60008060008060008060008060c0898b031215614d5957600080fd5b88356001600160401b03811115614d6f57600080fd5b614d7b8b828c01614ccf565b9850506020890135965060408901356001600160401b03811115614d9e57600080fd5b614daa8b828c01614ce7565b96505060608901356001600160401b03811115614dc657600080fd5b614dd28b828c01614cf9565b90965094505060808901356001600160401b03811115614df157600080fd5b614dfd8b828c01614cf9565b999c989b50969995989497949560a00135949350505050565b600060208284031215614e2857600080fd5b5035919050565b60008060008060808587031215614e4557600080fd5b84356001600160401b03811115614e5b57600080fd5b614e6787828801614805565b945050614e7660208601614742565b9250614e84604086016149ff565b9396929550929360600135925050565b801515811461490057600080fd5b8035613c2a81614e94565b60008060408385031215614ec057600080fd5b614ec983614742565b91506020830135614b4781614e94565b602080825282518282018190526000918401906040840190835b81811015613b7d57835180516001600160a01b0316845260208082015190614f1d90860182614692565b5060408101516040850152606081015160608501526080810151608085015260a081015160a085015260c081015160c085015260e0810151614f6360e086018215159052565b506101008101519050614f7b61010085018215159052565b50602093909301926101209290920191600101614ef3565b600060208284031215614fa557600080fd5b81356001600160401b03811115614fbb57600080fd5b61197284828501614805565b60008060008060008060008060c0898b031215614fe357600080fd5b88356001600160401b03811115614ff957600080fd5b6150058b828c01614ccf565b9850506020890135965060408901356001600160401b0381111561502857600080fd5b6150348b828c01614ce7565b96505060608901356001600160401b0381111561505057600080fd5b61505c8b828c01614cf9565b90965094505060808901356001600160401b0381111561507b57600080fd5b6150878b828c01614cf9565b909450925061509a905060a08a01614903565b90509295985092959890939650565b602081528151602082015260208201516040820152600060408301516150d26060840182614692565b5060608301516150e56080840182614692565b5060808301516150f860a0840182614692565b5060a083015161510b60c0840182614692565b5060c083015161012060e0840152615127610140840182614b76565b905060e0840151601f19848303016101008501526151458282614b76565b915050610100840151601f19848303016101208501526133fd8282614b76565b600080600080600060a0868803121561517d57600080fd5b8535945060208601359350604086013592506060860135915060808601356151a4816148eb565b809150509295509295909350565b6001600160a01b03929092168252602082015260400190565b6000602082840312156151dd57600080fd5b815161146c81614e94565b6001600160401b0383168152604060208201526000825160a0604084015261521360e0840182614b76565b90506020840151603f198483030160608501526152308282614b76565b6040860151858203603f19016080870152805180835260209182019450600093509101905b8083101561528c57835180516001600160a01b03168352602090810151818401529093019260019290920191604090910190615255565b50606086015192506152a160a0860184614692565b6080860151858203603f190160c087015292506152be8184614b76565b979650505050505050565b6000602082840312156152db57600080fd5b5051919050565b600181811c908216806152f657607f821691505b602082108103614ce157634e487b7160e01b600052602260045260246000fd5b60006020828403121561532857600080fd5b81356001600160401b0381111561533e57600080fd5b8201601f8101841361534f57600080fd5b80356001600160401b0381111561536857615368614774565b61537760208260051b016147d5565b8082825260208201915060208360081b85010192508683111561539957600080fd5b6020840193505b8284101561543e5761010084880312156153b957600080fd5b6153c16147b2565b84356153cc816148eb565b81526153da60208601614903565b602082015260408581013590820152606080860135908201526080808601359082015260a0808601359082015261541360c08601614ea2565b60c082015261542460e08601614ea2565b60e0820152825261010093909301926020909101906153a0565b9695505050505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016154865761548661545e565b5060010190565b6000815161549f818560208601614b52565b9290920192915050565b6364616f3d60e01b8152600087516154c8816004850160208c01614b52565b663b64616f49643d60c81b60049184019182015287516154ef81600b840160208c01614b52565b6004818301019150506b3b70726f706f73616c49643d60a01b60078201528651615520816013840160208b01614b52565b600781830101915050693b736e617073686f743d60b01b600c820152855161554f816016840160208a01614b52565b61559f61559961558261557c6016868601016e3b70726f706f73616c426c6f636b3d60881b8152600f0190565b8961548d565b6a3b766f7465546f6b656e3d60a81b8152600b0190565b8661548d565b9a9950505050505050505050565b60006080820186835285602084015260018060a01b03851660408401526080606084015280845180835260a08501915060a08160051b86010192506020860160005b8281101561562057609f1987860301845261560b858351614b76565b945060209384019391909101906001016155ef565b50929998505050505050505050565b6000808335601e1984360301811261564657600080fd5b83016020810192503590506001600160401b0381111561566557600080fd5b80360382131561179057600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b803565ffffffffffff81168114613c2a57600080fd5b81835260208301925060008160005b848110156144895781356156d5816148eb565b6001600160a01b0316865260209586019591909101906001016156c2565b81835260006001600160fb1b0383111561570c57600080fd5b8260051b80836020870137939093016020019392505050565b60e0815260006157358b8c61562f565b604060e085015261574b61012085018284615674565b91505061575b60208d018d61562f565b84830360df1901610100860152615773838284615674565b925050508a6020840152828103604084015261578f8a8b61562f565b60e083526157a160e084018284615674565b91505065ffffffffffff6157b760208d0161569d565b16602083015263ffffffff6157ce60408d016149ff565b16604083015260608b810135908301526080808c0135908301526157f560a08c018c61562f565b83830360a0850152615808838284615674565b9250505061581960c08c018c61562f565b83830360c085015261582c838284615674565b9350505050828103606084015261584481898b6156b3565b905082810360808401526158598187896156f3565b9150508360a083015261559f60c0830184614692565b8181038181111561327c5761327c61545e565b601f821115610e9a57806000526020600020601f840160051c810160208510156158a95750805b601f840160051c820191505b818110156158c957600081556001016158b5565b5050505050565b81516001600160401b038111156158e9576158e9614774565b6158fd816158f784546152e2565b84615882565b6020601f82116001811461593157600083156159195750848201515b600019600385901b1c1916600184901b1784556158c9565b600084815260208120601f198516915b828110156159615787850151825560209485019460019092019101615941565b508482101561597f5786840151600019600387901b60f8161c191681555b50505050600190811b01905550565b8082018082111561327c5761327c61545e565b9182526001600160a01b0316602082015260400190565b6040815260006159cc6040830186886156b3565b82810360208401526152be8185876156f3565b6000808335601e198436030181126159f657600080fd5b8301803591506001600160401b03821115615a1057600080fd5b60200191503681900382131561179057600080fd5b8281526040602082015260006114696040830184614b76565b60008154615a4b816152e2565b808552600182168015615a655760018114615a8157615ab8565b60ff1983166020870152602082151560051b8701019350615ab8565b84600052602060002060005b83811015615aaf5781546020828a010152600182019150602081019050615a8d565b87016020019450505b50505092915050565b604081526000615ad46040830185615a3e565b82810360208401526133fd8185615a3e565b808202811582820484141761327c5761327c61545e565b6001815b6001841115615b3857808504811115615b1c57615b1c61545e565b6001841615615b2a57908102905b60019390931c928002615b01565b935093915050565b600082615b4f5750600161327c565b81615b5c5750600061327c565b8160018114615b725760028114615b7c57615b98565b600191505061327c565b60ff841115615b8d57615b8d61545e565b50506001821b61327c565b5060208310610133831016604e8410600b8410161715615bbb575081810a61327c565b615bc86000198484615afd565b8060001904821115615bdc57615bdc61545e565b029392505050565b600061146c8383615b40565b634e487b7160e01b600052601260045260246000fd5b600082615c1557615c15615bf0565b500490565b600060ff831680615c2d57615c2d615bf0565b8060ff84160491505092915050565b60ff8181168382160290811690818114612d6357612d6361545e565b60ff828116828216039081111561327c5761327c61545e565b600082615c8057615c80615bf0565b500690565b634e487b7160e01b600052603160045260246000fd5b6001600160401b038616815260a060208201526000615cbd60a0830187614b76565b61ffff9590951660408301525063ffffffff92909216606083015260809091015292915050565b606081526000615cf8606083018789615674565b8281036020840152615d0b818688615674565b91505060018060a01b03831660408301529695505050505050565b600081518084526020840193506020830160005b828110156144895781516001600160a01b0316865260209586019590910190600101615d3a565b848152608060208201526000615d7a6080830186615d26565b8281036040840152615d8c8186615d26565b91505060018060a01b038316606083015295945050505050565b600060208284031215615db857600080fd5b61146c8261569d565b60608152600084516101406060840152615ddf6101a0840182614b76565b90506020860151615df36080850182614692565b506040860151615e0660a0850182614692565b50606086015165ffffffffffff811660c085015250608086015163ffffffff811660e08501525060a086015161010084015260c086015161012084015260e0860151610140840152610100860151605f1984830301610160850152615e6b8282614b76565b915050610120860151605f1984830301610180850152615e8b8282614b76565b92505050615e9c6020830185614692565b6119726040830184614692565b60ff818116838216019081111561327c5761327c61545e565b634e487b7160e01b600052602160045260246000fdfea26469706673582212203dbf572de2c943bd6f7383820d813cfdec4f53d54cf423627fb8ec49cf511f4764736f6c634300081c0033",
	"deployedBytecode": "0x6080604052600436106102365760003560e01c80639681096f1161012f578063c0cc3fcf116100b1578063c0cc3fcf14610735578063c42cf53514610753578063cfeaa3ec14610790578063d087d288146107b0578063d0a5e6ce146107d2578063d4fac45d1461080f578063d94c3bc91461082f578063da51c3ac14610865578063de3d9fb714610885578063e76d5168146108be578063ea7b4f77146108dc578063fb512c551461092457600080fd5b80639681096f1461059b57806396d3b83d146105bb578063976931071461060157806398d5fdca1461062357806399d25455146106385780639d3795e414610658578063a07b57f614610678578063a0cf0aea146106a5578063a2785f0b146106cd578063b1e21749146106e2578063bdacb303146106f857600080fd5b80634b0795a8116101b85780634b0795a8146103d557806352d84c62146103ea5780635bb478081461042a578063615f64fe1461046757806367e828bf146104c95780636a6339c1146104de5780636aac7002146104f35780636e04ff0d1461051357806388cc58e4146105415780638a8713641461056857806391b7f5ed1461057b57600080fd5b806301fce27e1461024257806309a16bd51461026d5780630bb106eb1461028c5780630ca76175146102cc5780631a3b149d146102ee5780631a93d1c31461030e5780631d41b5c41461034057806324ae6a27146103605780633944ea3a146103805780633b19e84a146103a25780634585e33b146103b557600080fd5b3661023d57005b600080fd5b34801561024e57600080fd5b50610257610949565b604051610264919061469f565b60405180910390f35b34801561027957600080fd5b50600c545b604051908152602001610264565b34801561029857600080fd5b506102bc6102a7366004614759565b60196020526000908152604090205460ff1681565b6040519015158152602001610264565b3480156102d857600080fd5b506102ec6102e736600461487b565b610a0c565b005b3480156102fa57600080fd5b5061027e61030936600461490e565b610a72565b34801561031a57600080fd5b50600054600160e01b900463ffffffff1660405163ffffffff9091168152602001610264565b34801561034c57600080fd5b506102ec61035b366004614a13565b610d27565b34801561036c57600080fd5b506102ec61037b366004614b19565b610df3565b34801561038c57600080fd5b50610395610e9f565b6040516102649190614ba2565b3480156103ae57600080fd5b504761027e565b3480156103c157600080fd5b506102ec6103d0366004614bb5565b610f2d565b3480156103e157600080fd5b506103956113b1565b3480156103f657600080fd5b506102ec610405366004614c27565b6000805463ffffffff909216600160e01b026001600160e01b03909216919091179055565b34801561043657600080fd5b506102ec610445366004614c42565b601380546001600160a01b0319166001600160a01b0392909216919091179055565b34801561047357600080fd5b50601354601154600d54600e54601054600f54604080516001600160a01b0397881681529587166020870152938616938501939093529084166060840152831660808301529190911660a082015260c001610264565b3480156104d557600080fd5b506103956113be565b3480156104ea57600080fd5b5060015461027e565b3480156104ff57600080fd5b5061027e61050e366004614c5f565b6113cb565b34801561051f57600080fd5b5061053361052e366004614bb5565b611473565b604051610264929190614ca0565b34801561054d57600080fd5b506013546001600160a01b03165b6040516102649190614cbb565b6102ec610576366004614d3d565b611797565b34801561058757600080fd5b506102ec610596366004614e16565b600b55565b3480156105a757600080fd5b5061027e6105b6366004614e2f565b611943565b3480156105c757600080fd5b506102ec6105d6366004614ead565b6001600160401b03919091166000908152601960205260409020805460ff1916911515919091179055565b34801561060d57600080fd5b5061061661197a565b6040516102649190614ed9565b34801561062f57600080fd5b50600b5461027e565b34801561064457600080fd5b506102ec610653366004614f93565b611b99565b34801561066457600080fd5b506102ec610673366004614fc7565b611ba9565b34801561068457600080fd5b50610698610693366004614e16565b6122ba565b60405161026491906150a9565b3480156106b157600080fd5b5061055b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee81565b3480156106d957600080fd5b5060035461027e565b3480156106ee57600080fd5b5061027e60025481565b34801561070457600080fd5b506102ec610713366004614c42565b600e80546001600160a01b0319166001600160a01b0392909216919091179055565b34801561074157600080fd5b506012546001600160a01b031661055b565b34801561075f57600080fd5b506102ec61076e366004614c42565b601080546001600160a01b0319166001600160a01b0392909216919091179055565b34801561079c57600080fd5b506102ec6107ab366004614e16565b600155565b3480156107bc57600080fd5b503360009081526018602052604090205461027e565b3480156107de57600080fd5b506102ec6107ed366004614c42565b600d80546001600160a01b0319166001600160a01b0392909216919091179055565b34801561081b57600080fd5b506102ec61082a366004614b19565b6125d5565b34801561083b57600080fd5b5061027e61084a366004614c42565b6001600160a01b031660009081526016602052604090205490565b34801561087157600080fd5b506102ec610880366004615165565b6125df565b34801561089157600080fd5b50600054600160a01b90046001600160401b03165b6040516001600160401b039091168152602001610264565b3480156108ca57600080fd5b506011546001600160a01b031661055b565b3480156108e857600080fd5b506102ec6108f7366004614759565b600080546001600160401b03909216600160a01b0267ffffffffffffffff60a01b19909216919091179055565b34801561093057600080fd5b50601354600160a01b90046001600160401b03166108a6565b60606004805480602002602001604051908101604052809291908181526020016000905b82821015610a035760008481526020908190206040805161010080820183526007870290930180546001600160a01b039081168352600180830154909116838701526002820154938301939093526003810154606083015260048101546080830152600581015460a08301526006015460ff808216151560c0840152939004909216151560e0830152908352909201910161096d565b50505050905090565b6000546001600160a01b03163314610a375760405163c6829f8360e01b815260040160405180910390fd5b610a42838383612662565b60405183907f85e1543bf2f84fe80c6badbce3648c8539ad1df4d2b3d822938ca0538be727e690600090a2505050565b33600090815260166020526040812054808203610aaa5760405163442d09d960e01b8152600481018290526024015b60405180910390fd5b6000818152601460205260409020600501546001600160a01b03163314610ae45760405163075fd2b160e01b815260040160405180910390fd5b856001600160a01b038116610b0c5760405163502ffa3f60e11b815260040160405180910390fd5b601154600090610b2a908990899089906001600160a01b03166129be565b60115460125460405163095ea7b360e01b81529293506001600160a01b039182169263095ea7b392610b6292169089906004016151b2565b6020604051808303816000875af1158015610b81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ba591906151cb565b5060125460405163095ea7b360e01b81526001600160a01b038981169263095ea7b392610bda92909116908a906004016151b2565b6020604051808303816000875af1158015610bf9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c1d91906151cb565b506012546013546040516396f4e9f960e01b81526001600160a01b03909216916396f4e9f991610c6391600160a01b9091046001600160401b03169085906004016151e8565b6020604051808303816000875af1158015610c82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ca691906152c9565b601354601154604080516001600160a01b03808e168252808d1660208301529181018b90529116606082015260808101889052919550600160a01b90046001600160401b03169085907fc15fb748c32ba4eb29c1c311e78533f93b4425eab49ea87c6fe4279ecadca0439060a00160405180910390a3505050949350505050565b8751600d80546001600160a01b03199081166001600160a01b03938416179091556020808b0151600e8054841691851691909117905560408b015160108054841691851691909117905560608b0151600f80548416918516919091179055895160118054841691851691909117905589015160128054831691841691909117905560a0890151601380546001600160e01b031916600160a01b6001600160401b039093169290920290921617918816919091179055610de98585858585612b41565b5050505050505050565b60006001600160a01b03831673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610e8b576040516370a0823160e01b81526001600160a01b038416906370a0823190610e45903090600401614cbb565b602060405180830381865afa158015610e62573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8691906152c9565b610e8d565b475b9050610e9a838383612b87565b505050565b60058054610eac906152e2565b80601f0160208091040260200160405190810160405280929190818152602001828054610ed8906152e2565b8015610f255780601f10610efa57610100808354040283529160200191610f25565b820191906000526020600020905b815481529060010190602001808311610f0857829003601f168201915b505050505081565b6000610f3b82840184615316565b90506000805b8251811015610fdf5760086000848381518110610f6057610f60615448565b6020026020010151600001516001600160a01b03166001600160a01b031681526020019081526020016000206000848381518110610fa057610fa0615448565b6020908102919091018101516060015182528101919091526040016000206006015460ff16610fd75781610fd381615474565b9250505b600101610f41565b506000816001600160401b03811115610ffa57610ffa614774565b60405190808252806020026020018201604052801561102d57816020015b60608152602001906001900390816110185790505b5090506000826001600160401b0381111561104a5761104a614774565b60405190808252806020026020018201604052801561108357816020015b6110706145fd565b8152602001906001900390816110685790505b5090506000805b85518110156112455760008682815181106110a7576110a7615448565b60209081029190910181015180516001600160a01b0316600090815260088352604080822060608401518352909352919091206006015490915060ff1661123c5780516001600160a01b03166000908152600860209081526040808320606085015184529091528120600601805460ff19166001179055815161112990612bc1565b6111368360400151612d6a565b6111438460600151612d6a565b6111508560800151612d6a565b61115d8660a00151612d6a565b61116a8760200151612bc1565b60405160200161117f969594939291906154a9565b6040516020818303038152906040529050808685815181106111a3576111a3615448565b6020026020010181905250818585815181106111c1576111c1615448565b60200260200101819052508160600151826040015183600001516001600160a01b03167f4faaacddef25e33933b6bb8be5852d80c222368e2f127653865bda8b517a440c85608001518660a0015187602001518c60405161122594939291906155ad565b60405180910390a48361123781615474565b945050505b5060010161108a565b5083156113a857610de960405180610120016040528060078054611268906152e2565b80601f0160208091040260200160405190810160405280929190818152602001828054611294906152e2565b80156112e15780601f106112b6576101008083540402835291602001916112e1565b820191906000526020600020905b8154815290600101906020018083116112c457829003601f168201915b50505050508152602001604051806020016040528060008152508152602001600060ff16815260200160006001600160401b0316815260200185815260200160006001600160401b0381111561133957611339614774565b60405190808252806020026020018201604052801561136c57816020015b60608152602001906001900390816113575790505b508152600054600160a01b81046001600160401b03166020830152600160e01b900463ffffffff16604082015260015460609091015283612e6a565b50505050505050565b60068054610eac906152e2565b60078054610eac906152e2565b6012546013546011546000926001600160a01b03908116926320487ded92600160a01b9091046001600160401b03169161140b91899189918991166129be565b6040518363ffffffff1660e01b81526004016114289291906151e8565b602060405180830381865afa158015611445573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061146991906152c9565b90505b9392505050565b600060606000805b60045481101561155957426004828154811061149957611499615448565b9060005260206000209060070201600401541115801561153e575060086000600483815481106114cb576114cb615448565b600091825260208083206007909202909101546001600160a01b031683528201929092526040018120600480549192918490811061150b5761150b615448565b906000526020600020906007020160030154815260200190815260200160002060060160009054906101000a900460ff16155b15611551578161154d81615474565b9250505b60010161147b565b508060000361157b575050604080516020810190915260008082529150611790565b6000816001600160401b0381111561159557611595614774565b6040519080825280602002602001820160405280156115ce57816020015b6115bb6145fd565b8152602001906001900390816115b35790505b5090506000805b6004548110156117655742600482815481106115f3576115f3615448565b906000526020600020906007020160040154111580156116985750600860006004838154811061162557611625615448565b600091825260208083206007909202909101546001600160a01b031683528201929092526040018120600480549192918490811061166557611665615448565b906000526020600020906007020160030154815260200190815260200160002060060160009054906101000a900460ff16155b1561175d57600481815481106116b0576116b0615448565b6000918252602091829020604080516101008082018352600790940290920180546001600160a01b039081168452600182015416948301949094526002840154908201526003830154606082015260048301546080820152600583015460a082015260069092015460ff808216151560c085015291900416151560e0820152835184908490811061174357611743615448565b6020026020010181905250818061175990615474565b9250505b6001016115d5565b5081604051602001611777919061469f565b6040516020818303038152906040529350600194505050505b9250929050565b600b546011546040516370a0823160e01b81526001600160a01b03909116906370a08231906117ca903390600401614cbb565b602060405180830381865afa1580156117e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061180b91906152c9565b101561182a57604051631cf2628760e31b815260040160405180910390fd5b600b54601154604051636eb1769f60e11b81523360048201523060248201526001600160a01b039091169063dd62ed3e90604401602060405180830381865afa15801561187b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061189f91906152c9565b10156118be57604051630fd3919360e01b815260040160405180910390fd5b60115460408051606081018252338152306020820152600b54918101919091526118f1916001600160a01b031690613282565b507f76dce1c3fdc4d27b2f00ebc0d6d819bda910678c5aa4b6c30bea2bff32f526ab88888888888888883360405161193199989796959493929190615725565b60405180910390a15050505050505050565b600061195185858585613301565b60028190556000818152600a60205260409020805460ff1916600117905590505b949350505050565b600454606090806001600160401b0381111561199857611998614774565b604051908082528060200260200182016040528015611a2e57816020015b611a1b60405180610120016040528060006001600160a01b0316815260200160006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581526020016000151581525090565b8152602001906001900390816119b65790505b50915060005b81811015611b9457600060048281548110611a5157611a51615448565b60009182526020808320604080516101008082018352600790950290920180546001600160a01b0390811684526001820154169383019390935260028301549082015260038201546060820152600482015460808201819052600583015460a083015260069092015460ff808216151560c0840152939004909216151560e0830152909250421015611af257428260800151611aed919061586f565b611af5565b60005b905060405180610120016040528083600001516001600160a01b0316815260200183602001516001600160a01b031681526020018360400151815260200183606001518152602001836080015181526020018360a0015181526020018281526020018360c00151151581526020018360e001511515815250858481518110611b7f57611b7f615448565b60209081029190910101525050600101611a34565b505090565b6007611ba582826158d0565b5050565b6013546001600160a01b03163314611bd45760405163075fd2b160e01b815260040160405180910390fd5b838214611bf45760405163636e39bb60e01b815260040160405180910390fd5b33600090815260186020526040812080548290611c1090615474565b91905081905590506000600c60008154611c2990615474565b9182905550600d54909150600090611c4b906001600160a01b031633856133b5565b600e54909150600090611c72906001600160a01b031633611c6d87600161598e565b6133b5565b601054909150600090611c94906001600160a01b031633611c6d88600261598e565b9050611ca185600261598e565b33600090815260186020526040902055611cbb838e613406565b611cc5828d61347b565b600f54611ce2908290859085906001600160a01b03168f896134bf565b816001600160a01b0316632f2ff15d836001600160a01b0316638f61f4f56040518163ffffffff1660e01b8152600401602060405180830381865afa158015611d2f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d5391906152c9565b836040518363ffffffff1660e01b8152600401611d719291906159a1565b600060405180830381600087803b158015611d8b57600080fd5b505af1158015611d9f573d6000803e3d6000fd5b50505050816001600160a01b0316632f2ff15d836001600160a01b03166307bd02656040518163ffffffff1660e01b8152600401602060405180830381865afa158015611df0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e1491906152c9565b60006040518363ffffffff1660e01b8152600401611e339291906159a1565b600060405180830381600087803b158015611e4d57600080fd5b505af1158015611e61573d6000803e3d6000fd5b50505050816001600160a01b03166336568abe836001600160a01b031663a217fddf6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611eb2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ed691906152c9565b306040518363ffffffff1660e01b8152600401611ef49291906159a1565b600060405180830381600087803b158015611f0e57600080fd5b505af1158015611f22573d6000803e3d6000fd5b5050604051637c88e3d960e01b81526001600160a01b0386169250637c88e3d99150611f58908d908d908d908d906004016159b8565b600060405180830381600087803b158015611f7257600080fd5b505af1158015611f86573d6000803e3d6000fd5b505060405163f2fde38b60e01b81526001600160a01b038616925063f2fde38b9150611fb6908590600401614cbb565b600060405180830381600087803b158015611fd057600080fd5b505af1158015611fe4573d6000803e3d6000fd5b5050601154600b5460405163a9059cbb60e01b81526001600160a01b03909216935063a9059cbb925061201c918591906004016151b2565b6020604051808303816000875af115801561203b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061205f91906151cb565b506001600160a01b038083166000818152601760209081526040808320899055858516808452601683529281902089905580516101208101825289815242928101929092528a8516908201529286166060840152608083019190915260a082015260c081016120ce8d806159df565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509082525060200161211560a08e018e6159df565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509082525060200161215c60c08e018e6159df565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052509390945250508681526014602090815260409182902084518155908401516001820155908301516002820180546001600160a01b039283166001600160a01b0319918216179091556060850151600384018054918416918316919091179055608085015160048401805491841691831691909117905560a085015160058401805491909316911617905560c0830151909150600682019061222d90826158d0565b5060e0820151600782019061224290826158d0565b50610100820151600882019061225890826158d0565b5050604080516001600160a01b0386811682528581166020830152841681830152905133925086917f3b785ea6f499a552d583841394f9e27727de143f34ed2585796814f93887d84f919081900360600190a350505050505050505050505050565b61232d604051806101200160405280600081526020016000815260200160006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b031681526020016060815260200160608152602001606081525090565b81158061233b5750600c5482115b156123a9575050604080516101208101825260008082526020808301829052828401829052606083018290526080830182905260a083018290528351808201855282815260c08401528351808201855282815260e08401528351908101909352825261010081019190915290565b6000828152601460209081526040918290208251610120810184528154815260018201549281019290925260028101546001600160a01b0390811693830193909352600381015483166060830152600481015483166080830152600581015490921660a082015260068201805491929160c084019190612428906152e2565b80601f0160208091040260200160405190810160405280929190818152602001828054612454906152e2565b80156124a15780601f10612476576101008083540402835291602001916124a1565b820191906000526020600020905b81548152906001019060200180831161248457829003601f168201915b505050505081526020016007820180546124ba906152e2565b80601f01602080910402602001604051908101604052809291908181526020018280546124e6906152e2565b80156125335780601f1061250857610100808354040283529160200191612533565b820191906000526020600020905b81548152906001019060200180831161251657829003601f168201915b5050505050815260200160088201805461254c906152e2565b80601f0160208091040260200160405190810160405280929190818152602001828054612578906152e2565b80156125c55780601f1061259a576101008083540402835291602001916125c5565b820191906000526020600020905b8154815290600101906020018083116125a857829003601f168201915b5050505050815250509050919050565b610e9a8282613685565b33600090815260166020526040812054908190036126135760405163442d09d960e01b815260048101829052602401610aa1565b6000818152601460205260409020600501546001600160a01b0316331461264d5760405163075fd2b160e01b815260040160405180910390fd5b61265a86868686866136ce565b505050505050565b8260025414612687576040516367954e7760e01b815260048101849052602401610aa1565b6000838152600a60205260409020805460ff1916905560056126a983826158d0565b5060066126b682826158d0565b5081511561297d578160006126ca826138c6565b90506000600960006002548152602001908152602001600020805480602002602001604051908101604052809291908181526020016000905b828210156127995760008481526020908190206040805161010080820183526007870290930180546001600160a01b039081168352600180830154909116838701526002820154938301939093526003810154606083015260048101546080830152600581015460a08301526006015460ff808216151560c0840152939004909216151560e08301529083529092019101612703565b50505050905060005b815181101561297857600860008383815181106127c1576127c1615448565b6020026020010151600001516001600160a01b03166001600160a01b03168152602001908152602001600020600083838151811061280157612801615448565b602002602001015160600151815260200190815260200160002060060160019054906101000a900460ff166129705781818151811061284257612842615448565b6020026020010151600001516001600160a01b0316633216e1f683838151811061286e5761286e615448565b60200260200101516060015185848151811061288c5761288c615448565b60200260200101516040518363ffffffff1660e01b81526004016128b1929190615a25565b600060405180830381600087803b1580156128cb57600080fd5b505af11580156128df573d6000803e3d6000fd5b505050506001600860008484815181106128fb576128fb615448565b6020026020010151600001516001600160a01b03166001600160a01b03168152602001908152602001600020600084848151811061293b5761293b615448565b602002602001015160600151815260200190815260200160002060060160016101000a81548160ff0219169083151502179055505b6001016127a2565b505050505b827f7873807bf6ddc50401cd3d29bbe0decee23fd4d68d273f4b5eb83cded4d2f172600560066040516129b1929190615ac1565b60405180910390a2505050565b6129f96040518060a0016040528060608152602001606081526020016060815260200160006001600160a01b03168152602001606081525090565b604080516001808252818301909252600091816020015b6040805180820190915260008082526020820152815260200190600190039081612a105790505090506040518060400160405280866001600160a01b031681526020018581525081600081518110612a6a57612a6a615448565b60200260200101819052506040518060a0016040528087604051602001612a919190614cbb565b6040516020818303038152906040528152602001604051806020016040528060008152508152602001828152602001846001600160a01b03168152602001612b35604051806040016040528060008152602001600115158152506040805182516024820152602092830151151560448083019190915282518083039091018152606490910190915290810180516001600160e01b0316630181dcf160e41b17905290565b90529695505050505050565b63ffffffff8316600160e01b026001600160e01b036001600160401b038616600160a01b02166001600160a01b03871617176000556001829055600761265a82826158d0565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed196001600160a01b03841601612bb657610e9a8282613b88565b610e9a838383613ba4565b60408051602a808252606082810190935260009190602082018180368337019050509050600360fc1b81600081518110612bfd57612bfd615448565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110612c2c57612c2c615448565b60200101906001600160f81b031916908160001a90535060005b6014811015612d63576000612c5c82601361586f565b612c67906008615ae6565b612c72906002615be4565b612c85906001600160a01b038716615c06565b60f81b9050600060108260f81c612c9c9190615c1a565b60f81b905060008160f81c6010612cb39190615c3c565b8360f81c612cc19190615c58565b60f81b9050612ccf82613bf4565b85612cdb866002615ae6565b612ce690600261598e565b81518110612cf657612cf6615448565b60200101906001600160f81b031916908160001a905350612d1681613bf4565b85612d22866002615ae6565b612d2d90600361598e565b81518110612d3d57612d3d615448565b60200101906001600160f81b031916908160001a9053505060019092019150612c469050565b5092915050565b606081600003612d915750506040805180820190915260018152600360fc1b602082015290565b6000825b8015612dbb5781612da581615474565b9250612db49050600a82615c06565b9050612d95565b6000826001600160401b03811115612dd557612dd5614774565b6040519080825280601f01601f191660200182016040528015612dff576020820181803683370190505b5090505b841561197257612e1460018461586f565b9250612e21600a86615c71565b612e2c90603061598e565b60f81b818481518110612e4157612e41615448565b60200101906001600160f81b031916908160001a905350612e63600a86615c06565b9450612e03565b6000612ead6040805160e0810190915280600081526020016000815260200160008152602001606081526020016060815260200160608152602001606081525090565b8351612eba908290613c2f565b60208401515115612eda576020840151612ed5908290613c3c565b612f02565b60608401516001600160401b031615612f025760408401516060850151612f02918391613c6d565b60808401515115612f1d576080840151612f1d908290613d03565b60a08401515115612f385760a0840151612f38908290613d2d565b612f59612f4482613d57565b8560c001518660e00151876101000151613301565b60028190556000818152600a60205260408120805460ff191660011790559092505b83518110156132795760008381526009602052604090208451859083908110612fa657612fa6615448565b6020908102919091018101518254600180820185556000948552838520835160079093020180546001600160a01b03199081166001600160a01b03948516178255948401519181018054909516919092161790925560408101516002830155606081015160038301556080810151600483015560a0810151600583015560c08101516006909201805460e09092015161ffff1990921692151561ff00191692909217610100911515919091021790555b6004548110156132705784828151811061307257613072615448565b6020026020010151600001516001600160a01b03166004828154811061309a5761309a615448565b60009182526020909120600790910201546001600160a01b031614801561310157508482815181106130ce576130ce615448565b602002602001015160600151600482815481106130ed576130ed615448565b906000526020600020906007020160030154145b1561326857600480546131169060019061586f565b8154811061312657613126615448565b90600052602060002090600702016004828154811061314757613147615448565b60009182526020909120825460079092020180546001600160a01b039283166001600160a01b0319918216178255600180850154908301805491909416911617909155600280830154908201556003808301549082015560048083015481830155600580840154908301556006928301805493909201805460ff19811660ff95861615159081178355935461ffff1990911661ff00199094169390931761010093849004909416151590920292909217905580548061320857613208615c85565b60008281526020812060076000199093019283020180546001600160a01b0319908116825560018201805490911690556002810182905560038101829055600481018290556005810191909155600601805461ffff191690559055613270565b600101613056565b50600101612f7b565b50505b92915050565b604081015160009073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed196001600160a01b038516016132e357803410156132d0576040516374c5672b60e01b815260040160405180910390fd5b6132de836020015182613b88565b6132f7565b6132f784846000015185602001518461401f565b5060019392505050565b6000805460405163230e93b160e11b815282916001600160a01b03169063461d27629061333b9088908a906001908a908a90600401615c9b565b6020604051808303816000875af115801561335a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061337e91906152c9565b60405190915081907f1131472297a800fee664d1d89cfa8f7676ff07189ecc53f80bbb5f4969099db890600090a295945050505050565b6040516001600160601b0319606084901b1660208201526034810182905260009081906054016040516020818303038152906040528051906020012090506133fd858261407d565b95945050505050565b6001600160a01b03821663077f224a61341f83806159df565b61342c60208601866159df565b306040518663ffffffff1660e01b815260040161344d959493929190615ce4565b600060405180830381600087803b15801561346757600080fd5b505af115801561265a573d6000803e3d6000fd5b604080516000808252602082019081528183019283905263c4c4c7b360e01b9092526001600160a01b0384169163c4c4c7b39161344d918591903060448301615d61565b604080516101408101909152600090806134d985806159df565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050908252506001600160a01b0380891660208084019190915290881660408084019190915260609092019161354591908701908701615da6565b65ffffffffffff1681526020016135626060860160408701614c27565b63ffffffff168152606080860135602083015260808087013560408401529082018590520161359460a08601866159df565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050908252506020016135db60c08601866159df565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050915250601154604051633f329cd560e21b81529192506001600160a01b03808a169263fcca73549261364a9286928a9290911690600401615dc1565b600060405180830381600087803b15801561366457600080fd5b505af1158015613678573d6000803e3d6000fd5b5050505050505050505050565b600073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed196001600160a01b038416016136bd57506001600160a01b0381163161327c565b6136c7838361408b565b905061327c565b604080516101008082018352338083526001600160a01b0385811660208086018281528688018d815260608089018e815260808a018e815260a08b018e8152600060c08d0181815260e08e018281526004805460018101825593529d5160079092027f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b81018054938d166001600160a01b031994851617905597517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19c8901805491909c1692169190911790995593517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19d86015590517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19e850155517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19f84015590517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1a083015593517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1a190910180549751151590960261ff00199115159190911661ffff199097169690961795909517909355845188815293840187905293830191909152869288927fce2df6fbb048de1d0af3bc2af20822ee09ffb85d9115939f7cca593511811d0c910160405180910390a45050505050565b606081600160005b8251811015613918578281815181106138e9576138e9615448565b01602001516001600160f81b031916601f60fa1b03613910578161390c81615474565b9250505b6001016138ce565b506000816001600160401b0381111561393357613933614774565b60405190808252806020026020018201604052801561396657816020015b60608152602001906001900390816139515790505b50905060008060005b8551811015613a995785818151811061398a5761398a615448565b01602001516001600160f81b031916601f60fa1b03613a915760006139af848361586f565b6001600160401b038111156139c6576139c6614774565b6040519080825280601f01601f1916602001820160405280156139f0576020820181803683370190505b509050835b82811015613a5857878181518110613a0f57613a0f615448565b01602001516001600160f81b03191682613a29878461586f565b81518110613a3957613a39615448565b60200101906001600160f81b031916908160001a9053506001016139f5565b50808584613a6581615474565b955081518110613a7757613a77615448565b6020908102919091010152613a8d82600161598e565b9350505b60010161396f565b508451821015613b7d576000828651613ab2919061586f565b6001600160401b03811115613ac957613ac9614774565b6040519080825280601f01601f191660200182016040528015613af3576020820181803683370190505b509050825b8651811015613b5c57868181518110613b1357613b13615448565b01602001516001600160f81b03191682613b2d868461586f565b81518110613b3d57613b3d615448565b60200101906001600160f81b031916908160001a905350600101613af8565b5080848381518110613b7057613b70615448565b6020026020010181905250505b509095945050505050565b60003860003884865af1611ba55763b12d13eb6000526004601cfd5b816014528060345263a9059cbb60601b60005260206000604460106000875af18060016000511416613be957803d853b151710613be9576390b8ec186000526004601cfd5b506000603452505050565b6000600a60f883901c1015613c1b57613c1260f883901c6030615ea9565b60f81b92915050565b613c1260f883901c6057615ea9565b919050565b611ba582600080846140b7565b8051600003613c5e5760405163e889636f60e01b815260040160405180910390fd5b60016020830152608090910152565b6000613c7a610100614135565b9050613cad604051806040016040528060068152602001651cdb1bdd125160d21b8152508261415690919063ffffffff16565b613cba8160ff851661416f565b6040805180820190915260078152663b32b939b4b7b760c91b6020820152613ce3908290614156565b613ced818361416f565b6002602085015251516080909301929092525050565b8051600003613d255760405163fe936cb760e01b815260040160405180910390fd5b60a090910152565b8051600003613d4f5760405163fe936cb760e01b815260040160405180910390fd5b60c090910152565b60606000613d66610100614135565b9050613d9f6040518060400160405280600c81526020016b31b7b232a637b1b0ba34b7b760a11b8152508261415690919063ffffffff16565b8251613dbd906002811115613db657613db6615ec2565b829061417b565b6040805180820190915260088152676c616e677561676560c01b6020820152613de7908290614156565b6040830151613dfe908015613db657613db6615ec2565b604080518082019091526006815265736f7572636560d01b6020820152613e26908290614156565b6060830151613e36908290614156565b60a08301515115613ec2576040805180820190915260048152636172677360e01b6020820152613e67908290614156565b613e70816141b4565b60005b8360a0015151811015613eb857613eb08460a001518281518110613e9957613e99615448565b60200260200101518361415690919063ffffffff16565b600101613e73565b50613ec2816141d8565b60808301515115613f8657600083602001516002811115613ee557613ee5615ec2565b03613f035760405163a80d31f760e01b815260040160405180910390fd5b60408051808201909152600f81526e39b2b1b932ba39a637b1b0ba34b7b760891b6020820152613f34908290614156565b613f4d83602001516002811115613db657613db6615ec2565b6040805180820190915260078152667365637265747360c81b6020820152613f76908290614156565b6080830151613f869082906141f6565b60c083015151156140175760408051808201909152600981526862797465734172677360b81b6020820152613fbc908290614156565b613fc5816141b4565b60005b8360c001515181101561400d576140058460c001518281518110613fee57613fee615448565b6020026020010151836141f690919063ffffffff16565b600101613fc8565b50614017816141d8565b515192915050565b60405181606052826040528360601b602c526323b872dd60601b600c52602060006064601c6000895af1806001600051141661406e57803d873b15171061406e57637939f4246000526004601cfd5b50600060605260405250505050565b600061146c83836000614203565b6000816014526370a0823160601b60005260208060246010865afa601f3d111660205102905092915050565b80516000036140d9576040516322ce3edd60e01b815260040160405180910390fd5b838360028111156140ec576140ec615ec2565b908160028111156140ff576140ff615ec2565b9052506040840182801561411557614115615ec2565b9081801561412557614125615ec2565b9052506060909301929092525050565b61413d614658565b8051614149908361429a565b5060006020820152919050565b6141638260038351614304565b8151610e9a9082614423565b611ba582600083614304565b81516141889060c2614437565b50611ba582826040516020016141a091815260200190565b6040516020818303038152906040526141f6565b6141bf816004614493565b6001816020018181516141d2919061598e565b90525050565b6141e3816007614493565b6001816020018181516141d2919061586f565b6141638260028351614304565b60008147101561422f5760405163cf47918160e01b815247600482015260248101839052604401610aa1565b763d602d80600a3d3981f3363d3d373d3d3d363d730000008460601b60e81c176000526e5af43d82803e903d91602b57fd5bf38460781b17602052826037600984f590506001600160a01b03811661146c5760405163b06ebf3d60e01b815260040160405180910390fd5b6142a2614678565b6142ad602083615c71565b156142d5576142bd602083615c71565b6142c890602061586f565b6142d2908361598e565b91505b6020808401839052604051808552600081529081840101818110156142f957600080fd5b604052509192915050565b6017816001600160401b03161161433057825161432a9060e0600585901b168317614437565b50505050565b60ff816001600160401b031611614370578251614358906018611fe0600586901b1617614437565b50825161432a906001600160401b03831660016144aa565b61ffff816001600160401b0316116143b1578251614399906019611fe0600586901b1617614437565b50825161432a906001600160401b03831660026144aa565b63ffffffff816001600160401b0316116143f45782516143dc90601a611fe0600586901b1617614437565b50825161432a906001600160401b03831660046144aa565b825161440b90601b611fe0600586901b1617614437565b50825161432a906001600160401b03831660086144aa565b61442b614678565b61146c83838451614522565b61443f614678565b825151600061444f82600161598e565b905084602001518210614470576144708561446b836002615ae6565b6145e6565b8451602083820101858153508051821115614489578181525b5093949350505050565b8151610e9a90601f611fe0600585901b1617614437565b6144b2614678565b83515160006144c1828561598e565b905085602001518111156144de576144de8661446b836002615ae6565b600060016144ee86610100615be4565b6144f8919061586f565b90508651828101878319825116178152508051831115614516578281525b50959695505050505050565b61452a614678565b825182111561453857600080fd5b8351516000614547848361598e565b90508560200151811115614564576145648661446b836002615ae6565b85518051838201602001916000918085111561457e578482525b505050602086015b602086106145be578051825261459d60208361598e565b91506145aa60208261598e565b90506145b760208761586f565b9550614586565b51815160001960208890036101000a0190811690199190911617905250849150509392505050565b81516145f2838361429a565b5061432a8382614423565b60405180610100016040528060006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000151581526020016000151581525090565b604051806040016040528061466b614678565b8152602001600081525090565b604051806040016040528060608152602001600081525090565b6001600160a01b03169052565b602080825282518282018190526000918401906040840190835b81811015613b7d57835160018060a01b03815116845260018060a01b03602082015116602085015260408101516040850152606081015160608501526080810151608085015260a081015160a085015260c0810151151560c085015260e0810151905061472a60e085018215159052565b506020939093019261010092909201916001016146b9565b80356001600160401b0381168114613c2a57600080fd5b60006020828403121561476b57600080fd5b61146c82614742565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b03811182821017156147ac576147ac614774565b60405290565b60405161010081016001600160401b03811182821017156147ac576147ac614774565b604051601f8201601f191681016001600160401b03811182821017156147fd576147fd614774565b604052919050565b600082601f83011261481657600080fd5b8135602083016000806001600160401b0384111561483657614836614774565b50601f8301601f191660200161484b816147d5565b91505082815285838301111561486057600080fd5b82826020830137600092810160200192909252509392505050565b60008060006060848603121561489057600080fd5b8335925060208401356001600160401b038111156148ad57600080fd5b6148b986828701614805565b92505060408401356001600160401b038111156148d557600080fd5b6148e186828701614805565b9150509250925092565b6001600160a01b038116811461490057600080fd5b50565b8035613c2a816148eb565b6000806000806080858703121561492457600080fd5b843561492f816148eb565b9350602085013561493f816148eb565b93969395505050506040820135916060013590565b600060c0828403121561496657600080fd5b60405160c081016001600160401b038111828210171561498857614988614774565b6040529050808235614999816148eb565b815260208301356149a9816148eb565b602082015260408301356149bc816148eb565b604082015260608301356149cf816148eb565b606082015260808301356149e2816148eb565b60808201526149f360a08401614742565b60a08201525092915050565b803563ffffffff81168114613c2a57600080fd5b600080600080600080600080888a03610200811215614a3157600080fd5b6080811215614a3f57600080fd5b50614a4861478a565b8935614a53816148eb565b815260208a0135614a63816148eb565b602082015260408a0135614a76816148eb565b604082015260608a0135614a89816148eb565b60608201529750614a9d8a60808b01614954565b9650614aac6101408a01614903565b9550614abb6101608a01614903565b9450614aca6101808a01614742565b9350614ad96101a08a016149ff565b92506101c089013591506101e08901356001600160401b03811115614afd57600080fd5b614b098b828c01614805565b9150509295985092959890939650565b60008060408385031215614b2c57600080fd5b8235614b37816148eb565b91506020830135614b47816148eb565b809150509250929050565b60005b83811015614b6d578181015183820152602001614b55565b50506000910152565b60008151808452614b8e816020860160208601614b52565b601f01601f19169290920160200192915050565b60208152600061146c6020830184614b76565b60008060208385031215614bc857600080fd5b82356001600160401b03811115614bde57600080fd5b8301601f81018513614bef57600080fd5b80356001600160401b03811115614c0557600080fd5b856020828401011115614c1757600080fd5b6020919091019590945092505050565b600060208284031215614c3957600080fd5b61146c826149ff565b600060208284031215614c5457600080fd5b813561146c816148eb565b600080600060608486031215614c7457600080fd5b8335614c7f816148eb565b92506020840135614c8f816148eb565b929592945050506040919091013590565b82151581526040602082015260006114696040830184614b76565b6001600160a01b0391909116815260200190565b600060408284031215614ce157600080fd5b50919050565b600060e08284031215614ce157600080fd5b60008083601f840112614d0b57600080fd5b5081356001600160401b03811115614d2257600080fd5b6020830191508360208260051b850101111561179057600080fd5b60008060008060008060008060c0898b031215614d5957600080fd5b88356001600160401b03811115614d6f57600080fd5b614d7b8b828c01614ccf565b9850506020890135965060408901356001600160401b03811115614d9e57600080fd5b614daa8b828c01614ce7565b96505060608901356001600160401b03811115614dc657600080fd5b614dd28b828c01614cf9565b90965094505060808901356001600160401b03811115614df157600080fd5b614dfd8b828c01614cf9565b999c989b50969995989497949560a00135949350505050565b600060208284031215614e2857600080fd5b5035919050565b60008060008060808587031215614e4557600080fd5b84356001600160401b03811115614e5b57600080fd5b614e6787828801614805565b945050614e7660208601614742565b9250614e84604086016149ff565b9396929550929360600135925050565b801515811461490057600080fd5b8035613c2a81614e94565b60008060408385031215614ec057600080fd5b614ec983614742565b91506020830135614b4781614e94565b602080825282518282018190526000918401906040840190835b81811015613b7d57835180516001600160a01b0316845260208082015190614f1d90860182614692565b5060408101516040850152606081015160608501526080810151608085015260a081015160a085015260c081015160c085015260e0810151614f6360e086018215159052565b506101008101519050614f7b61010085018215159052565b50602093909301926101209290920191600101614ef3565b600060208284031215614fa557600080fd5b81356001600160401b03811115614fbb57600080fd5b61197284828501614805565b60008060008060008060008060c0898b031215614fe357600080fd5b88356001600160401b03811115614ff957600080fd5b6150058b828c01614ccf565b9850506020890135965060408901356001600160401b0381111561502857600080fd5b6150348b828c01614ce7565b96505060608901356001600160401b0381111561505057600080fd5b61505c8b828c01614cf9565b90965094505060808901356001600160401b0381111561507b57600080fd5b6150878b828c01614cf9565b909450925061509a905060a08a01614903565b90509295985092959890939650565b602081528151602082015260208201516040820152600060408301516150d26060840182614692565b5060608301516150e56080840182614692565b5060808301516150f860a0840182614692565b5060a083015161510b60c0840182614692565b5060c083015161012060e0840152615127610140840182614b76565b905060e0840151601f19848303016101008501526151458282614b76565b915050610100840151601f19848303016101208501526133fd8282614b76565b600080600080600060a0868803121561517d57600080fd5b8535945060208601359350604086013592506060860135915060808601356151a4816148eb565b809150509295509295909350565b6001600160a01b03929092168252602082015260400190565b6000602082840312156151dd57600080fd5b815161146c81614e94565b6001600160401b0383168152604060208201526000825160a0604084015261521360e0840182614b76565b90506020840151603f198483030160608501526152308282614b76565b6040860151858203603f19016080870152805180835260209182019450600093509101905b8083101561528c57835180516001600160a01b03168352602090810151818401529093019260019290920191604090910190615255565b50606086015192506152a160a0860184614692565b6080860151858203603f190160c087015292506152be8184614b76565b979650505050505050565b6000602082840312156152db57600080fd5b5051919050565b600181811c908216806152f657607f821691505b602082108103614ce157634e487b7160e01b600052602260045260246000fd5b60006020828403121561532857600080fd5b81356001600160401b0381111561533e57600080fd5b8201601f8101841361534f57600080fd5b80356001600160401b0381111561536857615368614774565b61537760208260051b016147d5565b8082825260208201915060208360081b85010192508683111561539957600080fd5b6020840193505b8284101561543e5761010084880312156153b957600080fd5b6153c16147b2565b84356153cc816148eb565b81526153da60208601614903565b602082015260408581013590820152606080860135908201526080808601359082015260a0808601359082015261541360c08601614ea2565b60c082015261542460e08601614ea2565b60e0820152825261010093909301926020909101906153a0565b9695505050505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016154865761548661545e565b5060010190565b6000815161549f818560208601614b52565b9290920192915050565b6364616f3d60e01b8152600087516154c8816004850160208c01614b52565b663b64616f49643d60c81b60049184019182015287516154ef81600b840160208c01614b52565b6004818301019150506b3b70726f706f73616c49643d60a01b60078201528651615520816013840160208b01614b52565b600781830101915050693b736e617073686f743d60b01b600c820152855161554f816016840160208a01614b52565b61559f61559961558261557c6016868601016e3b70726f706f73616c426c6f636b3d60881b8152600f0190565b8961548d565b6a3b766f7465546f6b656e3d60a81b8152600b0190565b8661548d565b9a9950505050505050505050565b60006080820186835285602084015260018060a01b03851660408401526080606084015280845180835260a08501915060a08160051b86010192506020860160005b8281101561562057609f1987860301845261560b858351614b76565b945060209384019391909101906001016155ef565b50929998505050505050505050565b6000808335601e1984360301811261564657600080fd5b83016020810192503590506001600160401b0381111561566557600080fd5b80360382131561179057600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b803565ffffffffffff81168114613c2a57600080fd5b81835260208301925060008160005b848110156144895781356156d5816148eb565b6001600160a01b0316865260209586019591909101906001016156c2565b81835260006001600160fb1b0383111561570c57600080fd5b8260051b80836020870137939093016020019392505050565b60e0815260006157358b8c61562f565b604060e085015261574b61012085018284615674565b91505061575b60208d018d61562f565b84830360df1901610100860152615773838284615674565b925050508a6020840152828103604084015261578f8a8b61562f565b60e083526157a160e084018284615674565b91505065ffffffffffff6157b760208d0161569d565b16602083015263ffffffff6157ce60408d016149ff565b16604083015260608b810135908301526080808c0135908301526157f560a08c018c61562f565b83830360a0850152615808838284615674565b9250505061581960c08c018c61562f565b83830360c085015261582c838284615674565b9350505050828103606084015261584481898b6156b3565b905082810360808401526158598187896156f3565b9150508360a083015261559f60c0830184614692565b8181038181111561327c5761327c61545e565b601f821115610e9a57806000526020600020601f840160051c810160208510156158a95750805b601f840160051c820191505b818110156158c957600081556001016158b5565b5050505050565b81516001600160401b038111156158e9576158e9614774565b6158fd816158f784546152e2565b84615882565b6020601f82116001811461593157600083156159195750848201515b600019600385901b1c1916600184901b1784556158c9565b600084815260208120601f198516915b828110156159615787850151825560209485019460019092019101615941565b508482101561597f5786840151600019600387901b60f8161c191681555b50505050600190811b01905550565b8082018082111561327c5761327c61545e565b9182526001600160a01b0316602082015260400190565b6040815260006159cc6040830186886156b3565b82810360208401526152be8185876156f3565b6000808335601e198436030181126159f657600080fd5b8301803591506001600160401b03821115615a1057600080fd5b60200191503681900382131561179057600080fd5b8281526040602082015260006114696040830184614b76565b60008154615a4b816152e2565b808552600182168015615a655760018114615a8157615ab8565b60ff1983166020870152602082151560051b8701019350615ab8565b84600052602060002060005b83811015615aaf5781546020828a010152600182019150602081019050615a8d565b87016020019450505b50505092915050565b604081526000615ad46040830185615a3e565b82810360208401526133fd8185615a3e565b808202811582820484141761327c5761327c61545e565b6001815b6001841115615b3857808504811115615b1c57615b1c61545e565b6001841615615b2a57908102905b60019390931c928002615b01565b935093915050565b600082615b4f5750600161327c565b81615b5c5750600061327c565b8160018114615b725760028114615b7c57615b98565b600191505061327c565b60ff841115615b8d57615b8d61545e565b50506001821b61327c565b5060208310610133831016604e8410600b8410161715615bbb575081810a61327c565b615bc86000198484615afd565b8060001904821115615bdc57615bdc61545e565b029392505050565b600061146c8383615b40565b634e487b7160e01b600052601260045260246000fd5b600082615c1557615c15615bf0565b500490565b600060ff831680615c2d57615c2d615bf0565b8060ff84160491505092915050565b60ff8181168382160290811690818114612d6357612d6361545e565b60ff828116828216039081111561327c5761327c61545e565b600082615c8057615c80615bf0565b500690565b634e487b7160e01b600052603160045260246000fd5b6001600160401b038616815260a060208201526000615cbd60a0830187614b76565b61ffff9590951660408301525063ffffffff92909216606083015260809091015292915050565b606081526000615cf8606083018789615674565b8281036020840152615d0b818688615674565b91505060018060a01b03831660408301529695505050505050565b600081518084526020840193506020830160005b828110156144895781516001600160a01b0316865260209586019590910190600101615d3a565b848152608060208201526000615d7a6080830186615d26565b8281036040840152615d8c8186615d26565b91505060018060a01b038316606083015295945050505050565b600060208284031215615db857600080fd5b61146c8261569d565b60608152600084516101406060840152615ddf6101a0840182614b76565b90506020860151615df36080850182614692565b506040860151615e0660a0850182614692565b50606086015165ffffffffffff811660c085015250608086015163ffffffff811660e08501525060a086015161010084015260c086015161012084015260e0860151610140840152610100860151605f1984830301610160850152615e6b8282614b76565b915050610120860151605f1984830301610180850152615e8b8282614b76565b92505050615e9c6020830185614692565b6119726040830184614692565b60ff818116838216019081111561327c5761327c61545e565b634e487b7160e01b600052602160045260246000fdfea26469706673582212203dbf572de2c943bd6f7383820d813cfdec4f53d54cf423627fb8ec49cf511f4764736f6c634300081c0033",
	"devdoc": {
		"errors": {
			"FailedDeployment()": [
				{
					"details": "The deployment failed."
				}
			],
			"InsufficientBalance(uint256,uint256)": [
				{
					"details": "The ETH balance of the account is not enough to perform the operation."
				}
			]
		},
		"kind": "dev",
		"methods": {
			"handleOracleFulfillment(bytes32,bytes,bytes)": {
				"details": "Either response or error parameter will be set, but never both.",
				"params": {
					"err": "Aggregated error either from the request's source code or from the execution pipeline.",
					"requestId": "The requestId returned by FunctionsClient.sendRequest().",
					"response": "Aggregated response from the request's source code."
				}
			},
			"performUpkeep(bytes)": {
				"details": "The input to this method should not be trusted, and the caller of the method should not even be restricted to any single registry. Anyone should be able call it, and the input should be validated, there is no guarantee that the data passed in is the performData returned from checkUpkeep. This could happen due to malicious keepers, racing keepers, or simply a state change while the performUpkeep transaction is waiting for confirmation. Always validate the data passed in.",
				"params": {
					"performData": "is the data which was passed back from the checkData simulation. If it is encoded, it can easily be decoded into other types by calling `abi.decode`. This data should not be trusted, and should be validated against the contract's current state."
				}
			},
			"sendRequestCBOR(bytes,uint64,uint32,bytes32)": {
				"params": {
					"_donID": "ID of the job to be invoked",
					"_gasLimit": "The maximum amount of gas the request can consume",
					"_request": "CBOR-encoded request data",
					"_subscriptionId": "Billing ID"
				},
				"returns": {
					"requestId": "The ID of the sent request"
				}
			}
		},
		"version": 1
	},
	"userdoc": {
		"errors": {
			"DAO_NOT_FOUND(uint256)": [
				{
					"notice": "====================== ======= ZK DAO ======= ======================"
				}
			],
			"INSUFFICIENT_ALLOWANCE()": [
				{
					"notice": "====================== ====== Generic ======= ======================"
				}
			],
			"INVALID_VOTE_TYPE()": [
				{
					"notice": "====================== ====== Governor ====== ======================"
				}
			],
			"NotEnoughBalance(uint256,uint256)": [
				{
					"notice": "====================== ======= Errors ======= ======================"
				}
			]
		},
		"events": {
			"DaoCreated(uint256,address,address,address,address)": {
				"notice": "====================== ======= Events ======= ======================"
			},
			"ProposalQueued(address,uint256,uint256,uint256,uint256,address)": {
				"notice": "====================== ======= Events ======= ======================"
			},
			"Response(bytes32,bytes,bytes)": {
				"notice": "====================== ======= Events ======= ======================"
			}
		},
		"kind": "user",
		"methods": {
			"checkUpkeep(bytes)": {
				"notice": "========================== === External Functions === =========================="
			},
			"getPrice()": {
				"notice": "========================== === External Functions === =========================="
			},
			"getSubscriptionId()": {
				"notice": "========================== === External Functions === =========================="
			},
			"handleOracleFulfillment(bytes32,bytes,bytes)": {
				"notice": "Chainlink Functions response handler called by the Functions Router during fullilment from the designated transmitter node in an OCR round."
			},
			"initialize((address,address,address,address),(address,address,address,address,address,uint64),address,address,uint64,uint32,bytes32,string)": {
				"notice": "========================= ====== Initializer ====== ========================="
			},
			"performUpkeep(bytes)": {
				"notice": "method that is actually executed by the keepers, via the registry. The data returned by the checkUpkeep simulation will be passed into this method to actually be executed."
			},
			"sendRequestCBOR(bytes,uint64,uint32,bytes32)": {
				"notice": "Send a pre-encoded CBOR request"
			}
		},
		"version": 1
	},
	"storageLayout": {
		"storage": [
			{
				"astId": 30405,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "i_router",
				"offset": 0,
				"slot": "0",
				"type": "t_contract(IFunctionsRouter)407"
			},
			{
				"astId": 29614,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "subscriptionId",
				"offset": 20,
				"slot": "0",
				"type": "t_uint64"
			},
			{
				"astId": 29616,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "gasLimit",
				"offset": 28,
				"slot": "0",
				"type": "t_uint32"
			},
			{
				"astId": 29618,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "donID",
				"offset": 0,
				"slot": "1",
				"type": "t_bytes32"
			},
			{
				"astId": 29620,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "s_lastRequestId",
				"offset": 0,
				"slot": "2",
				"type": "t_bytes32"
			},
			{
				"astId": 29622,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "requestCounter",
				"offset": 0,
				"slot": "3",
				"type": "t_uint256"
			},
			{
				"astId": 29626,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "queue",
				"offset": 0,
				"slot": "4",
				"type": "t_array(t_struct(Proposal)29570_storage)dyn_storage"
			},
			{
				"astId": 29628,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "s_lastResponse",
				"offset": 0,
				"slot": "5",
				"type": "t_bytes_storage"
			},
			{
				"astId": 29630,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "s_lastError",
				"offset": 0,
				"slot": "6",
				"type": "t_bytes_storage"
			},
			{
				"astId": 29632,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "source",
				"offset": 0,
				"slot": "7",
				"type": "t_string_storage"
			},
			{
				"astId": 29640,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "proposals",
				"offset": 0,
				"slot": "8",
				"type": "t_mapping(t_contract(IGovernor)28971,t_mapping(t_uint256,t_struct(Proposal)29570_storage))"
			},
			{
				"astId": 29646,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "pendingProposals",
				"offset": 0,
				"slot": "9",
				"type": "t_mapping(t_bytes32,t_array(t_struct(Proposal)29570_storage)dyn_storage)"
			},
			{
				"astId": 29650,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "pendingRequests",
				"offset": 0,
				"slot": "10",
				"type": "t_mapping(t_bytes32,t_bool)"
			},
			{
				"astId": 27666,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "price",
				"offset": 0,
				"slot": "11",
				"type": "t_uint256"
			},
			{
				"astId": 27668,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "daoCounter",
				"offset": 0,
				"slot": "12",
				"type": "t_uint256"
			},
			{
				"astId": 27671,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "governorToken",
				"offset": 0,
				"slot": "13",
				"type": "t_contract(IGovernorToken)29006"
			},
			{
				"astId": 27674,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "timelock",
				"offset": 0,
				"slot": "14",
				"type": "t_contract(ITimeLock)29054"
			},
			{
				"astId": 27677,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "verifier",
				"offset": 0,
				"slot": "15",
				"type": "t_contract(IVerifier)25966"
			},
			{
				"astId": 27680,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "governor",
				"offset": 0,
				"slot": "16",
				"type": "t_contract(IGovernor)28971"
			},
			{
				"astId": 27683,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "linkToken",
				"offset": 0,
				"slot": "17",
				"type": "t_contract(IERC20)10243"
			},
			{
				"astId": 27686,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "ccipRouter",
				"offset": 0,
				"slot": "18",
				"type": "t_contract(IRouterClient)42"
			},
			{
				"astId": 27688,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "factory",
				"offset": 0,
				"slot": "19",
				"type": "t_address"
			},
			{
				"astId": 27690,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "destinationChainSelector",
				"offset": 20,
				"slot": "19",
				"type": "t_uint64"
			},
			{
				"astId": 27695,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "daos",
				"offset": 0,
				"slot": "20",
				"type": "t_mapping(t_uint256,t_struct(Dao)27662_storage)"
			},
			{
				"astId": 27699,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "daoIdByProposalId",
				"offset": 0,
				"slot": "21",
				"type": "t_mapping(t_uint256,t_uint256)"
			},
			{
				"astId": 27703,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "daoIdByAddress",
				"offset": 0,
				"slot": "22",
				"type": "t_mapping(t_address,t_uint256)"
			},
			{
				"astId": 27707,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "daoIdByTimelock",
				"offset": 0,
				"slot": "23",
				"type": "t_mapping(t_address,t_uint256)"
			},
			{
				"astId": 27711,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "nonces",
				"offset": 0,
				"slot": "24",
				"type": "t_mapping(t_address,t_uint256)"
			},
			{
				"astId": 27715,
				"contract": "contracts/core/ZKDAO.sol:ZKDAO",
				"label": "allowlistedChains",
				"offset": 0,
				"slot": "25",
				"type": "t_mapping(t_uint64,t_bool)"
			}
		],
		"types": {
			"t_address": {
				"encoding": "inplace",
				"label": "address",
				"numberOfBytes": "20"
			},
			"t_array(t_struct(Proposal)29570_storage)dyn_storage": {
				"base": "t_struct(Proposal)29570_storage",
				"encoding": "dynamic_array",
				"label": "struct ConsumerUpgradable.Proposal[]",
				"numberOfBytes": "32"
			},
			"t_bool": {
				"encoding": "inplace",
				"label": "bool",
				"numberOfBytes": "1"
			},
			"t_bytes32": {
				"encoding": "inplace",
				"label": "bytes32",
				"numberOfBytes": "32"
			},
			"t_bytes_storage": {
				"encoding": "bytes",
				"label": "bytes",
				"numberOfBytes": "32"
			},
			"t_contract(IERC20)10243": {
				"encoding": "inplace",
				"label": "contract IERC20",
				"numberOfBytes": "20"
			},
			"t_contract(IFunctionsRouter)407": {
				"encoding": "inplace",
				"label": "contract IFunctionsRouter",
				"numberOfBytes": "20"
			},
			"t_contract(IGovernor)28971": {
				"encoding": "inplace",
				"label": "contract IGovernor",
				"numberOfBytes": "20"
			},
			"t_contract(IGovernorToken)29006": {
				"encoding": "inplace",
				"label": "contract IGovernorToken",
				"numberOfBytes": "20"
			},
			"t_contract(IRouterClient)42": {
				"encoding": "inplace",
				"label": "contract IRouterClient",
				"numberOfBytes": "20"
			},
			"t_contract(ITimeLock)29054": {
				"encoding": "inplace",
				"label": "contract ITimeLock",
				"numberOfBytes": "20"
			},
			"t_contract(IVerifier)25966": {
				"encoding": "inplace",
				"label": "contract IVerifier",
				"numberOfBytes": "20"
			},
			"t_mapping(t_address,t_uint256)": {
				"encoding": "mapping",
				"key": "t_address",
				"label": "mapping(address => uint256)",
				"numberOfBytes": "32",
				"value": "t_uint256"
			},
			"t_mapping(t_bytes32,t_array(t_struct(Proposal)29570_storage)dyn_storage)": {
				"encoding": "mapping",
				"key": "t_bytes32",
				"label": "mapping(bytes32 => struct ConsumerUpgradable.Proposal[])",
				"numberOfBytes": "32",
				"value": "t_array(t_struct(Proposal)29570_storage)dyn_storage"
			},
			"t_mapping(t_bytes32,t_bool)": {
				"encoding": "mapping",
				"key": "t_bytes32",
				"label": "mapping(bytes32 => bool)",
				"numberOfBytes": "32",
				"value": "t_bool"
			},
			"t_mapping(t_contract(IGovernor)28971,t_mapping(t_uint256,t_struct(Proposal)29570_storage))": {
				"encoding": "mapping",
				"key": "t_contract(IGovernor)28971",
				"label": "mapping(contract IGovernor => mapping(uint256 => struct ConsumerUpgradable.Proposal))",
				"numberOfBytes": "32",
				"value": "t_mapping(t_uint256,t_struct(Proposal)29570_storage)"
			},
			"t_mapping(t_uint256,t_struct(Dao)27662_storage)": {
				"encoding": "mapping",
				"key": "t_uint256",
				"label": "mapping(uint256 => struct ZKDAO.Dao)",
				"numberOfBytes": "32",
				"value": "t_struct(Dao)27662_storage"
			},
			"t_mapping(t_uint256,t_struct(Proposal)29570_storage)": {
				"encoding": "mapping",
				"key": "t_uint256",
				"label": "mapping(uint256 => struct ConsumerUpgradable.Proposal)",
				"numberOfBytes": "32",
				"value": "t_struct(Proposal)29570_storage"
			},
			"t_mapping(t_uint256,t_uint256)": {
				"encoding": "mapping",
				"key": "t_uint256",
				"label": "mapping(uint256 => uint256)",
				"numberOfBytes": "32",
				"value": "t_uint256"
			},
			"t_mapping(t_uint64,t_bool)": {
				"encoding": "mapping",
				"key": "t_uint64",
				"label": "mapping(uint64 => bool)",
				"numberOfBytes": "32",
				"value": "t_bool"
			},
			"t_string_storage": {
				"encoding": "bytes",
				"label": "string",
				"numberOfBytes": "32"
			},
			"t_struct(Dao)27662_storage": {
				"encoding": "inplace",
				"label": "struct ZKDAO.Dao",
				"members": [
					{
						"astId": 27642,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "id",
						"offset": 0,
						"slot": "0",
						"type": "t_uint256"
					},
					{
						"astId": 27644,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "createdAt",
						"offset": 0,
						"slot": "1",
						"type": "t_uint256"
					},
					{
						"astId": 27646,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "creator",
						"offset": 0,
						"slot": "2",
						"type": "t_address"
					},
					{
						"astId": 27649,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "token",
						"offset": 0,
						"slot": "3",
						"type": "t_contract(IGovernorToken)29006"
					},
					{
						"astId": 27652,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "timelock",
						"offset": 0,
						"slot": "4",
						"type": "t_contract(ITimeLock)29054"
					},
					{
						"astId": 27655,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "governor",
						"offset": 0,
						"slot": "5",
						"type": "t_contract(IGovernor)28971"
					},
					{
						"astId": 27657,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "name",
						"offset": 0,
						"slot": "6",
						"type": "t_string_storage"
					},
					{
						"astId": 27659,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "description",
						"offset": 0,
						"slot": "7",
						"type": "t_string_storage"
					},
					{
						"astId": 27661,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "logo",
						"offset": 0,
						"slot": "8",
						"type": "t_string_storage"
					}
				],
				"numberOfBytes": "288"
			},
			"t_struct(Proposal)29570_storage": {
				"encoding": "inplace",
				"label": "struct ConsumerUpgradable.Proposal",
				"members": [
					{
						"astId": 29555,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "dao",
						"offset": 0,
						"slot": "0",
						"type": "t_contract(IGovernor)28971"
					},
					{
						"astId": 29557,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "voteToken",
						"offset": 0,
						"slot": "1",
						"type": "t_address"
					},
					{
						"astId": 29559,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "daoId",
						"offset": 0,
						"slot": "2",
						"type": "t_uint256"
					},
					{
						"astId": 29561,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "proposalId",
						"offset": 0,
						"slot": "3",
						"type": "t_uint256"
					},
					{
						"astId": 29563,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "snapshot",
						"offset": 0,
						"slot": "4",
						"type": "t_uint256"
					},
					{
						"astId": 29565,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "proposalBlock",
						"offset": 0,
						"slot": "5",
						"type": "t_uint256"
					},
					{
						"astId": 29567,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "queued",
						"offset": 0,
						"slot": "6",
						"type": "t_bool"
					},
					{
						"astId": 29569,
						"contract": "contracts/core/ZKDAO.sol:ZKDAO",
						"label": "executed",
						"offset": 1,
						"slot": "6",
						"type": "t_bool"
					}
				],
				"numberOfBytes": "224"
			},
			"t_uint256": {
				"encoding": "inplace",
				"label": "uint256",
				"numberOfBytes": "32"
			},
			"t_uint32": {
				"encoding": "inplace",
				"label": "uint32",
				"numberOfBytes": "4"
			},
			"t_uint64": {
				"encoding": "inplace",
				"label": "uint64",
				"numberOfBytes": "8"
			}
		}
	}
}
